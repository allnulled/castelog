"\n\n//Included:lib/000.inicializacion.part.js\n// CASTELOG@0.0.1\n\n/***************************************************************************************\n ***[ Manifiesto de Castelog v.0.0.1 ]**********************************[ 2022/08 ]*****\n ***************************************************************************************\n ***                                                                                 ***\n *** Castelog es un software construido por «allnulled» o «Carlos Jimeno Hernández». ***\n ***                                                                                 ***\n *** No tiene licencia, haz lo que quieras con él.                                   ***\n ***                                                                                 ***\n *************************************************[ Carlos J. / +34 619 98 26 22 ]******\n ******************************************************************************[ ]******\n ***************************************************[ Licencia gratis siempre ya ]******\n ******************************************************************************[ ]******\n ******************************************************************************[ ]******/\n\n////////////////////////////////////////////////////////////////////////////////\n// Aquí empieza el script de Castelog //////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n//Included:lib/001.01.xhr2-v.part.js\n/*lib:xhr2 v0.2.1 + modifications*/\n// Generated by CoffeeScript 2.5.1\n(function () {\n    const is_nodejs_environment = (typeof global !== \"undefined\") && (typeof require !== \"undefined\");\n    if(!is_nodejs_environment) return;\n    // This file's name is set up in such a way that it will always show up first in\n    // the list of files given to coffee --join, so that the other files can assume\n    // that XMLHttpRequestEventTarget was already defined.\n\n    // The DOM EventTarget subclass used by XMLHttpRequest.\n\n    // @see http://xhr.spec.whatwg.org/#interface-xmlhttprequest\n    var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os, url;\n\n    XMLHttpRequestEventTarget = (function () {\n        class XMLHttpRequestEventTarget {\n            // @private\n            // This is an abstract class and should not be instantiated directly.\n            constructor() {\n                this.onloadstart = null;\n                this.onprogress = null;\n                this.onabort = null;\n                this.onerror = null;\n                this.onload = null;\n                this.ontimeout = null;\n                this.onloadend = null;\n                this._listeners = {};\n            }\n\n            // Adds a new-style listener for one of the XHR events.\n\n            // @see http://www.w3.org/TR/XMLHttpRequest/#events\n\n            // @param {String} eventType an XHR event type, such as 'readystatechange'\n            // @param {function(ProgressEvent)} listener function that will be called when\n            //   the event fires\n            // @return {undefined} undefined\n            addEventListener(eventType, listener) {\n                var base;\n                eventType = eventType.toLowerCase();\n                (base = this._listeners)[eventType] || (base[eventType] = []);\n                this._listeners[eventType].push(listener);\n                return void 0;\n            }\n\n            // Removes an event listener added by calling addEventListener.\n\n            // @param {String} eventType an XHR event type, such as 'readystatechange'\n            // @param {function(ProgressEvent)} listener the value passed in a previous\n            //   call to addEventListener.\n            // @return {undefined} undefined\n            removeEventListener(eventType, listener) {\n                var index;\n                eventType = eventType.toLowerCase();\n                if (this._listeners[eventType]) {\n                    index = this._listeners[eventType].indexOf(listener);\n                    if (index !== -1) {\n                        this._listeners[eventType].splice(index, 1);\n                    }\n                }\n                return void 0;\n            }\n\n            // Calls all the listeners for an event.\n\n            // @param {ProgressEvent} event the event to be dispatched\n            // @return {undefined} undefined\n            dispatchEvent(event) {\n                var eventType, j, len, listener, listeners;\n                event.currentTarget = event.target = this;\n                eventType = event.type;\n                if (listeners = this._listeners[eventType]) {\n                    for (j = 0, len = listeners.length; j < len; j++) {\n                        listener = listeners[j];\n                        listener.call(this, event);\n                    }\n                }\n                if (listener = this[`on${eventType}`]) {\n                    listener.call(this, event);\n                }\n                return void 0;\n            }\n\n        };\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'loadstart' event\n        XMLHttpRequestEventTarget.prototype.onloadstart = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'progress' event\n        XMLHttpRequestEventTarget.prototype.onprogress = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'abort' event\n        XMLHttpRequestEventTarget.prototype.onabort = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'error' event\n        XMLHttpRequestEventTarget.prototype.onerror = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'load' event\n        XMLHttpRequestEventTarget.prototype.onload = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'timeout' event\n        XMLHttpRequestEventTarget.prototype.ontimeout = null;\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler\n        //   for the 'loadend' event\n        XMLHttpRequestEventTarget.prototype.onloadend = null;\n\n        return XMLHttpRequestEventTarget;\n\n    }).call(this);\n\n    // This file's name is set up in such a way that it will always show up second\n    // in the list of files given to coffee --join, so it can use the\n    // XMLHttpRequestEventTarget definition and so that the other files can assume\n    // that XMLHttpRequest was already defined.\n    http = require('http');\n\n    https = require('https');\n\n    os = require('os');\n\n    url = require('url');\n\n    XMLHttpRequest = (function () {\n        // The ECMAScript HTTP API.\n\n        // @see http://www.w3.org/TR/XMLHttpRequest/#introduction\n        class XMLHttpRequest extends XMLHttpRequestEventTarget {\n            // Creates a new request.\n\n            // @param {Object} options one or more of the options below\n            // @option options {Boolean} anon if true, the request's anonymous flag\n            //   will be set\n            // @see http://www.w3.org/TR/XMLHttpRequest/#constructors\n            // @see http://www.w3.org/TR/XMLHttpRequest/#anonymous-flag\n            constructor(options) {\n                super();\n                this.onreadystatechange = null;\n                this._anonymous = options && options.anon;\n                this.readyState = XMLHttpRequest.UNSENT;\n                this.response = null;\n                this.responseText = '';\n                this.responseType = '';\n                this.responseURL = '';\n                this.status = 0;\n                this.statusText = '';\n                this.timeout = 0;\n                this.upload = new XMLHttpRequestUpload(this);\n                this._method = null; // String\n                this._url = null; // Return value of url.parse()\n                this._sync = false;\n                this._headers = null; // Object<String, String>\n                this._loweredHeaders = null; // Object<lowercase String, String>\n                this._mimeOverride = null;\n                this._request = null; // http.ClientRequest\n                this._response = null; // http.ClientResponse\n                this._responseParts = null; // Array<Buffer, String>\n                this._responseHeaders = null; // Object<lowercase String, String>\n                this._aborting = null;\n                this._error = null;\n                this._loadedBytes = 0;\n                this._totalBytes = 0;\n                this._lengthComputable = false;\n            }\n\n            // Sets the XHR's method, URL, synchronous flag, and authentication params.\n\n            // @param {String} method the HTTP method to be used\n            // @param {String} url the URL that the request will be made to\n            // @param {?Boolean} async if false, the XHR should be processed\n            //   synchronously; true by default\n            // @param {?String} user the user credential to be used in HTTP basic\n            //   authentication\n            // @param {?String} password the password credential to be used in HTTP basic\n            //   authentication\n            // @return {undefined} undefined\n            // @throw {SecurityError} method is not one of the allowed methods\n            // @throw {SyntaxError} urlString is not a valid URL\n            // @throw {Error} the URL contains an unsupported protocol; the supported\n            //   protocols are file, http and https\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method\n            open(method, url, async, user, password) {\n                var xhrUrl;\n                method = method.toUpperCase();\n                if (method in this._restrictedMethods) {\n                    throw new SecurityError(`HTTP method ${method} is not allowed in XHR`);\n                }\n                xhrUrl = this._parseUrl(url);\n                if (async === void 0) {\n                    async = true;\n                }\n                switch (this.readyState) {\n                    case XMLHttpRequest.UNSENT:\n                    case XMLHttpRequest.OPENED:\n                    case XMLHttpRequest.DONE:\n                        // Nothing to do here.\n                        null;\n                        break;\n                    case XMLHttpRequest.HEADERS_RECEIVED:\n                    case XMLHttpRequest.LOADING:\n                        // TODO(pwnall): terminate abort(), terminate send()\n                        null;\n                }\n                this._method = method;\n                this._url = xhrUrl;\n                this._sync = !async;\n                this._headers = {};\n                this._loweredHeaders = {};\n                this._mimeOverride = null;\n                this._setReadyState(XMLHttpRequest.OPENED);\n                this._request = null;\n                this._response = null;\n                this.status = 0;\n                this.statusText = '';\n                this._responseParts = [];\n                this._responseHeaders = null;\n                this._loadedBytes = 0;\n                this._totalBytes = 0;\n                this._lengthComputable = false;\n                return void 0;\n            }\n\n            // Appends a header to the list of author request headers.\n\n            // @param {String} name the HTTP header name\n            // @param {String} value the HTTP header value\n            // @return {undefined} undefined\n            // @throw {InvalidStateError} readyState is not OPENED\n            // @throw {SyntaxError} name is not a valid HTTP header name or value is not\n            //   a valid HTTP header value\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method\n            setRequestHeader(name, value) {\n                var loweredName;\n                if (this.readyState !== XMLHttpRequest.OPENED) {\n                    throw new InvalidStateError(\"XHR readyState must be OPENED\");\n                }\n                loweredName = name.toLowerCase();\n                if (this._restrictedHeaders[loweredName] || /^sec\\-/.test(loweredName) || /^proxy-/.test(loweredName)) {\n                    console.warn(`Refused to set unsafe header \\\"${name}\\\"`);\n                    return void 0;\n                }\n                value = value.toString();\n                if (loweredName in this._loweredHeaders) {\n                    // Combine value with the existing header value.\n                    name = this._loweredHeaders[loweredName];\n                    this._headers[name] = this._headers[name] + ', ' + value;\n                } else {\n                    // New header.\n                    this._loweredHeaders[loweredName] = name;\n                    this._headers[name] = value;\n                }\n                return void 0;\n            }\n\n            // Initiates the request.\n\n            // @param {?String, ?ArrayBufferView} data the data to be sent; ignored for\n            //   GET and HEAD requests\n            // @return {undefined} undefined\n            // @throw {InvalidStateError} readyState is not OPENED\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method\n            send(data) {\n                if (this.readyState !== XMLHttpRequest.OPENED) {\n                    throw new InvalidStateError(\"XHR readyState must be OPENED\");\n                }\n                if (this._request) {\n                    throw new InvalidStateError(\"send() already called\");\n                }\n                switch (this._url.protocol) {\n                    case 'file:':\n                        this._sendFile(data);\n                        break;\n                    case 'http:':\n                    case 'https:':\n                        this._sendHttp(data);\n                        break;\n                    default:\n                        throw new NetworkError(`Unsupported protocol ${this._url.protocol}`);\n                }\n                return void 0;\n            }\n\n            // Cancels the network activity performed by this request.\n\n            // @return {undefined} undefined\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method\n            abort() {\n                if (!this._request) {\n                    return;\n                }\n                this._request.abort();\n                this._setError();\n                this._dispatchProgress('abort');\n                this._dispatchProgress('loadend');\n                return void 0;\n            }\n\n            // Returns a header value in the HTTP response for this XHR.\n\n            // @param {String} name case-insensitive HTTP header name\n            // @return {?String} value the value of the header whose name matches the\n            //   given name, or null if there is no such header\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n            getResponseHeader(name) {\n                var loweredName;\n                if (!this._responseHeaders) {\n                    return null;\n                }\n                loweredName = name.toLowerCase();\n                if (loweredName in this._responseHeaders) {\n                    return this._responseHeaders[loweredName];\n                } else {\n                    return null;\n                }\n            }\n\n            // Returns all the HTTP headers in this XHR's response.\n\n            // @return {String} header lines separated by CR LF, where each header line\n            //   has the name and value separated by a \": \" (colon, space); the empty\n            //   string is returned if the headers are not available\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method\n            getAllResponseHeaders() {\n                var lines, name, value;\n                if (!this._responseHeaders) {\n                    return '';\n                }\n                lines = (function () {\n                    var ref, results;\n                    ref = this._responseHeaders;\n                    results = [];\n                    for (name in ref) {\n                        value = ref[name];\n                        results.push(`${name}: ${value}`);\n                    }\n                    return results;\n                }).call(this);\n                return lines.join(\"\\r\\n\");\n            }\n\n            // Overrides the Content-Type\n\n            // @return {undefined} undefined\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-overridemimetype()-method\n            overrideMimeType(newMimeType) {\n                if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n                    throw new InvalidStateError(\"overrideMimeType() not allowed in LOADING or DONE\");\n                }\n                this._mimeOverride = newMimeType.toLowerCase();\n                return void 0;\n            }\n\n            // Network configuration not exposed in the XHR API.\n\n            // Although the XMLHttpRequest specification calls itself \"ECMAScript HTTP\",\n            // it assumes that requests are always performed in the context of a browser\n            // application, where some network parameters are set by the browser user and\n            // should not be modified by Web applications. This API provides access to\n            // these network parameters.\n\n            // NOTE: this is not in the XMLHttpRequest API, and will not work in\n            // browsers.  It is a stable node-xhr2 API.\n\n            // @param {Object} options one or more of the options below\n            // @option options {?http.Agent} httpAgent the value for the nodejsHttpAgent\n            //   property (the agent used for HTTP requests)\n            // @option options {?https.Agent} httpsAgent the value for the\n            //   nodejsHttpsAgent property (the agent used for HTTPS requests)\n            // @return {undefined} undefined\n            nodejsSet(options) {\n                var baseUrl, parsedUrl;\n                if ('httpAgent' in options) {\n                    this.nodejsHttpAgent = options.httpAgent;\n                }\n                if ('httpsAgent' in options) {\n                    this.nodejsHttpsAgent = options.httpsAgent;\n                }\n                if ('baseUrl' in options) {\n                    baseUrl = options.baseUrl;\n                    if (baseUrl !== null) {\n                        parsedUrl = url.parse(baseUrl, false, true);\n                        if (!parsedUrl.protocol) {\n                            throw new SyntaxError(\"baseUrl must be an absolute URL\");\n                        }\n                    }\n                    this.nodejsBaseUrl = baseUrl;\n                }\n                return void 0;\n            }\n\n            // Default settings for the network configuration not exposed in the XHR API.\n\n            // NOTE: this is not in the XMLHttpRequest API, and will not work in\n            // browsers.  It is a stable node-xhr2 API.\n\n            // @param {Object} options one or more of the options below\n            // @option options {?http.Agent} httpAgent the default value for the\n            //   nodejsHttpAgent property (the agent used for HTTP requests)\n            // @option options {https.Agent} httpsAgent the default value for the\n            //   nodejsHttpsAgent property (the agent used for HTTPS requests)\n            // @return {undefined} undefined\n            // @see XMLHttpRequest.nodejsSet\n            static nodejsSet(options) {\n                // \"this\" will be set to XMLHttpRequest.prototype, so the instance nodejsSet\n                // operates on default property values.\n                XMLHttpRequest.prototype.nodejsSet(options);\n                return void 0;\n            }\n\n            // Sets the readyState property and fires the readystatechange event.\n\n            // @private\n            // @param {Number} newReadyState the new value of readyState\n            // @return {undefined} undefined\n            _setReadyState(newReadyState) {\n                var event;\n                this.readyState = newReadyState;\n                event = new ProgressEvent('readystatechange');\n                this.dispatchEvent(event);\n                return void 0;\n            }\n\n            // XMLHttpRequest#send() implementation for the file: protocol.\n\n            // @private\n            _sendFile() {\n                if (this._url.method !== 'GET') {\n                    throw new NetworkError('The file protocol only supports GET');\n                }\n                throw new Error(\"Protocol file: not implemented\");\n            }\n\n            // XMLHttpRequest#send() implementation for the http: and https: protocols.\n\n            // @private\n            // This method sets the instance variables and calls _sendHxxpRequest(), which\n            // is responsible for building a node.js request and firing it off. The code\n            // in _sendHxxpRequest() is separated off so it can be reused when handling\n            // redirects.\n\n            // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method\n            _sendHttp(data) {\n                if (this._sync) {\n                    throw new Error(\"Synchronous XHR processing not implemented\");\n                }\n                if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {\n                    console.warn(`Discarding entity body for ${this._method} requests`);\n                    data = null;\n                } else {\n                    // Send Content-Length: 0\n                    data || (data = '');\n                }\n                // NOTE: this is called before finalizeHeaders so that the uploader can\n                //       figure out Content-Length and Content-Type.\n                this.upload._setData(data);\n                this._finalizeHeaders();\n                this._sendHxxpRequest();\n                return void 0;\n            }\n\n            // Sets up and fires off a HTTP/HTTPS request using the node.js API.\n\n            // @private\n            // This method contains the bulk of the XMLHttpRequest#send() implementation,\n            // and is also used to issue new HTTP requests when handling HTTP redirects.\n\n            // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method\n            _sendHxxpRequest() {\n                var agent, hxxp, request;\n                if (this._url.protocol === 'http:') {\n                    hxxp = http;\n                    agent = this.nodejsHttpAgent;\n                } else {\n                    hxxp = https;\n                    agent = this.nodejsHttpsAgent;\n                }\n                request = hxxp.request({\n                    hostname: this._url.hostname,\n                    port: this._url.port,\n                    path: this._url.path,\n                    auth: this._url.auth,\n                    method: this._method,\n                    headers: this._headers,\n                    agent: agent\n                });\n                this._request = request;\n                if (this.timeout) {\n                    request.setTimeout(this.timeout, () => {\n                        return this._onHttpTimeout(request);\n                    });\n                }\n                request.on('response', (response) => {\n                    return this._onHttpResponse(request, response);\n                });\n                request.on('error', (error) => {\n                    return this._onHttpRequestError(request, error);\n                });\n                this.upload._startUpload(request);\n                if (this._request === request) { // An http error might have already fired.\n                    this._dispatchProgress('loadstart');\n                }\n                return void 0;\n            }\n\n            // Fills in the restricted HTTP headers with default values.\n\n            // This is called right before the HTTP request is sent off.\n\n            // @private\n            // @return {undefined} undefined\n            _finalizeHeaders() {\n                var base;\n                this._headers['Connection'] = 'keep-alive';\n                this._headers['Host'] = this._url.host;\n                if (this._anonymous) {\n                    this._headers['Referer'] = 'about:blank';\n                }\n                (base = this._headers)['User-Agent'] || (base['User-Agent'] = this._userAgent);\n                this.upload._finalizeHeaders(this._headers, this._loweredHeaders);\n                return void 0;\n            }\n\n            // Called when the headers of an HTTP response have been received.\n\n            // @private\n            // @param {http.ClientRequest} request the node.js ClientRequest instance that\n            //   produced this response\n            // @param {http.ClientResponse} response the node.js ClientResponse instance\n            //   passed to\n            _onHttpResponse(request, response) {\n                var lengthString;\n                if (this._request !== request) {\n                    return;\n                }\n                // Transparent redirection handling.\n                switch (response.statusCode) {\n                    case 301:\n                    case 302:\n                    case 303:\n                    case 307:\n                    case 308:\n                        this._url = this._parseUrl(response.headers['location']);\n                        this._method = 'GET';\n                        if ('content-type' in this._loweredHeaders) {\n                            delete this._headers[this._loweredHeaders['content-type']];\n                            delete this._loweredHeaders['content-type'];\n                        }\n                        // XMLHttpRequestUpload#_finalizeHeaders() sets Content-Type directly.\n                        if ('Content-Type' in this._headers) {\n                            delete this._headers['Content-Type'];\n                        }\n                        // Restricted headers can't be set by the user, no need to check\n                        // loweredHeaders.\n                        delete this._headers['Content-Length'];\n                        this.upload._reset();\n                        this._finalizeHeaders();\n                        this._sendHxxpRequest();\n                        return;\n                }\n                this._response = response;\n                this._response.on('data', (data) => {\n                    return this._onHttpResponseData(response, data);\n                });\n                this._response.on('end', () => {\n                    return this._onHttpResponseEnd(response);\n                });\n                this._response.on('close', () => {\n                    return this._onHttpResponseClose(response);\n                });\n                this.responseURL = this._url.href.split('#')[0];\n                this.status = this._response.statusCode;\n                this.statusText = http.STATUS_CODES[this.status];\n                this._parseResponseHeaders(response);\n                if (lengthString = this._responseHeaders['content-length']) {\n                    this._totalBytes = parseInt(lengthString);\n                    this._lengthComputable = true;\n                } else {\n                    this._lengthComputable = false;\n                }\n                return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);\n            }\n\n            // Called when some data has been received on a HTTP connection.\n\n            // @private\n            // @param {http.ClientResponse} response the node.js ClientResponse instance\n            //   that fired this event\n            // @param {String, Buffer} data the data that has been received\n            _onHttpResponseData(response, data) {\n                if (this._response !== response) {\n                    return;\n                }\n                this._responseParts.push(data);\n                this._loadedBytes += data.length;\n                if (this.readyState !== XMLHttpRequest.LOADING) {\n                    this._setReadyState(XMLHttpRequest.LOADING);\n                }\n                return this._dispatchProgress('progress');\n            }\n\n            // Called when the HTTP request finished processing.\n\n            // @private\n            // @param {http.ClientResponse} response the node.js ClientResponse instance\n            //   that fired this event\n            _onHttpResponseEnd(response) {\n                if (this._response !== response) {\n                    return;\n                }\n                this._parseResponse();\n                this._request = null;\n                this._response = null;\n                this._setReadyState(XMLHttpRequest.DONE);\n                this._dispatchProgress('load');\n                return this._dispatchProgress('loadend');\n            }\n\n            // Called when the underlying HTTP connection was closed prematurely.\n\n            // If this method is called, it will be called after or instead of\n            // onHttpResponseEnd.\n\n            // @private\n            // @param {http.ClientResponse} response the node.js ClientResponse instance\n            //   that fired this event\n            _onHttpResponseClose(response) {\n                var request;\n                if (this._response !== response) {\n                    return;\n                }\n                request = this._request;\n                this._setError();\n                request.abort();\n                this._setReadyState(XMLHttpRequest.DONE);\n                this._dispatchProgress('error');\n                return this._dispatchProgress('loadend');\n            }\n\n            // Called when the timeout set on the HTTP socket expires.\n\n            // @private\n            // @param {http.ClientRequest} request the node.js ClientRequest instance that\n            //   fired this event\n            _onHttpTimeout(request) {\n                if (this._request !== request) {\n                    return;\n                }\n                this._setError();\n                request.abort();\n                this._setReadyState(XMLHttpRequest.DONE);\n                this._dispatchProgress('timeout');\n                return this._dispatchProgress('loadend');\n            }\n\n            // Called when something wrong happens on the HTTP socket\n\n            // @private\n            // @param {http.ClientRequest} request the node.js ClientRequest instance that\n            //   fired this event\n            // @param {Error} error emitted exception\n            _onHttpRequestError(request, error) {\n                if (this._request !== request) {\n                    return;\n                }\n                this._setError();\n                request.abort();\n                this._setReadyState(XMLHttpRequest.DONE);\n                this._dispatchProgress('error');\n                return this._dispatchProgress('loadend');\n            }\n\n            // Fires an XHR progress event.\n\n            // @private\n            // @param {String} eventType one of the XHR progress event types, such as\n            //   'load' and 'progress'\n            _dispatchProgress(eventType) {\n                var event;\n                event = new ProgressEvent(eventType);\n                event.lengthComputable = this._lengthComputable;\n                event.loaded = this._loadedBytes;\n                event.total = this._totalBytes;\n                this.dispatchEvent(event);\n                return void 0;\n            }\n\n            // Sets up the XHR to reflect the fact that an error has occurred.\n\n            // The possible errors are a network error, a timeout, or an abort.\n\n            // @private\n            _setError() {\n                this._request = null;\n                this._response = null;\n                this._responseHeaders = null;\n                this._responseParts = null;\n                return void 0;\n            }\n\n            // Parses a request URL string.\n\n            // @private\n            // This method is a thin wrapper around url.parse() that normalizes HTTP\n            // user/password credentials. It is used to parse the URL string passed to\n            // XMLHttpRequest#open() and the URLs in the Location headers of HTTP redirect\n            // responses.\n\n            // @param {String} urlString the URL to be parsed\n            // @return {Object} parsed URL\n            _parseUrl(urlString) {\n                var absoluteUrlString, index, password, user, xhrUrl;\n                if (this.nodejsBaseUrl === null) {\n                    absoluteUrlString = urlString;\n                } else {\n                    absoluteUrlString = url.resolve(this.nodejsBaseUrl, urlString);\n                }\n                xhrUrl = url.parse(absoluteUrlString, false, true);\n                xhrUrl.hash = null;\n                if (xhrUrl.auth && ((typeof user !== \"undefined\" && user !== null) || (typeof password !== \"undefined\" && password !== null))) {\n                    index = xhrUrl.auth.indexOf(':');\n                    if (index === -1) {\n                        if (!user) {\n                            user = xhrUrl.auth;\n                        }\n                    } else {\n                        if (!user) {\n                            user = xhrUrl.substring(0, index);\n                        }\n                        if (!password) {\n                            password = xhrUrl.substring(index + 1);\n                        }\n                    }\n                }\n                if (user || password) {\n                    xhrUrl.auth = `${user}:${password}`;\n                }\n                return xhrUrl;\n            }\n\n            // Reads the headers from a node.js ClientResponse instance.\n\n            // @private\n            // @param {http.ClientResponse} response the response whose headers will be\n            //   imported into this XMLHttpRequest's state\n            // @return {undefined} undefined\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n            // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method\n            _parseResponseHeaders(response) {\n                var loweredName, name, ref, value;\n                this._responseHeaders = {};\n                ref = response.headers;\n                for (name in ref) {\n                    value = ref[name];\n                    loweredName = name.toLowerCase();\n                    if (this._privateHeaders[loweredName]) {\n                        continue;\n                    }\n                    if (this._mimeOverride !== null && loweredName === 'content-type') {\n                        value = this._mimeOverride;\n                    }\n                    this._responseHeaders[loweredName] = value;\n                }\n                if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {\n                    this._responseHeaders['content-type'] = this._mimeOverride;\n                }\n                return void 0;\n            }\n\n            // Sets the response and responseText properties when an XHR completes.\n\n            // @private\n            // @return {undefined} undefined\n            _parseResponse() {\n                var arrayBuffer, buffer, i, j, jsonError, ref, view;\n                if (Buffer.concat) {\n                    buffer = Buffer.concat(this._responseParts);\n                } else {\n                    // node 0.6\n                    buffer = this._concatBuffers(this._responseParts);\n                }\n                this._responseParts = null;\n                switch (this.responseType) {\n                    case 'text':\n                        this._parseTextResponse(buffer);\n                        break;\n                    case 'json':\n                        this.responseText = null;\n                        try {\n                            this.response = JSON.parse(buffer.toString('utf-8'));\n                        } catch (error1) {\n                            jsonError = error1;\n                            this.response = null;\n                        }\n                        break;\n                    case 'buffer':\n                        this.responseText = null;\n                        this.response = buffer;\n                        break;\n                    case 'arraybuffer':\n                        this.responseText = null;\n                        arrayBuffer = new ArrayBuffer(buffer.length);\n                        view = new Uint8Array(arrayBuffer);\n                        for (i = j = 0, ref = buffer.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {\n                            view[i] = buffer[i];\n                        }\n                        this.response = arrayBuffer;\n                        break;\n                    default:\n                        // TODO(pwnall): content-base detection\n                        this._parseTextResponse(buffer);\n                }\n                return void 0;\n            }\n\n            // Sets response and responseText for a 'text' response type.\n\n            // @private\n            // @param {Buffer} buffer the node.js Buffer containing the binary response\n            // @return {undefined} undefined\n            _parseTextResponse(buffer) {\n                var e;\n                try {\n                    this.responseText = buffer.toString(this._parseResponseEncoding());\n                } catch (error1) {\n                    e = error1;\n                    // Unknown encoding.\n                    this.responseText = buffer.toString('binary');\n                }\n                this.response = this.responseText;\n                return void 0;\n            }\n\n            // Figures out the string encoding of the XHR's response.\n\n            // This is called to determine the encoding when responseText is set.\n\n            // @private\n            // @return {String} a string encoding, e.g. 'utf-8'\n            _parseResponseEncoding() {\n                var contentType, encoding, match;\n                encoding = null;\n                if (contentType = this._responseHeaders['content-type']) {\n                    if (match = /\\;\\s*charset\\=(.*)$/.exec(contentType)) {\n                        return match[1];\n                    }\n                }\n                return 'utf-8';\n            }\n\n            // Buffer.concat implementation for node 0.6.\n\n            // @private\n            // @param {Array<Buffer>} buffers the buffers whose contents will be merged\n            // @return {Buffer} same as Buffer.concat(buffers) in node 0.8 and above\n            _concatBuffers(buffers) {\n                var buffer, j, k, len, len1, length, target;\n                if (buffers.length === 0) {\n                    return Buffer.alloc(0);\n                }\n                if (buffers.length === 1) {\n                    return buffers[0];\n                }\n                length = 0;\n                for (j = 0, len = buffers.length; j < len; j++) {\n                    buffer = buffers[j];\n                    length += buffer.length;\n                }\n                target = Buffer.alloc(length);\n                length = 0;\n                for (k = 0, len1 = buffers.length; k < len1; k++) {\n                    buffer = buffers[k];\n                    buffer.copy(target, length);\n                    length += buffer.length;\n                }\n                return target;\n            }\n\n        };\n\n        // @property {function(ProgressEvent)} DOM level 0-style handler for the\n        //   'readystatechange' event\n        XMLHttpRequest.prototype.onreadystatechange = null;\n\n        // @property {Number} the current state of the XHR object\n        // @see http://www.w3.org/TR/XMLHttpRequest/#states\n        XMLHttpRequest.prototype.readyState = null;\n\n        // @property {String, ArrayBuffer, Buffer, Object} processed XHR response\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute\n        XMLHttpRequest.prototype.response = null;\n\n        // @property {String} response string, if responseType is '' or 'text'\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute\n        XMLHttpRequest.prototype.responseText = null;\n\n        // @property {String} sets the parsing method for the XHR response\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute\n        XMLHttpRequest.prototype.responseType = null;\n\n        // @property {Number} the HTTP\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-status-attribute\n        XMLHttpRequest.prototype.status = null;\n\n        // @property {Number} milliseconds to wait for the request to complete\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n        XMLHttpRequest.prototype.timeout = null;\n\n        // @property {XMLHttpRequestUpload} the associated upload information\n        // @see http://www.w3.org/TR/XMLHttpRequest/#the-upload-attribute\n        XMLHttpRequest.prototype.upload = null;\n\n        // readyState value before XMLHttpRequest#open() is called\n        XMLHttpRequest.prototype.UNSENT = 0;\n\n        // readyState value before XMLHttpRequest#open() is called\n        XMLHttpRequest.UNSENT = 0;\n\n        // readyState value after XMLHttpRequest#open() is called, and before\n        //   XMLHttpRequest#send() is called; XMLHttpRequest#setRequestHeader() can be\n        //   called in this state\n        XMLHttpRequest.prototype.OPENED = 1;\n\n        // readyState value after XMLHttpRequest#open() is called, and before\n        //   XMLHttpRequest#send() is called; XMLHttpRequest#setRequestHeader() can be\n        //   called in this state\n        XMLHttpRequest.OPENED = 1;\n\n        // readyState value after redirects have been followed and the HTTP headers of\n        //   the final response have been received\n        XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;\n\n        // readyState value after redirects have been followed and the HTTP headers of\n        //   the final response have been received\n        XMLHttpRequest.HEADERS_RECEIVED = 2;\n\n        // readyState value when the response entity body is being received\n        XMLHttpRequest.prototype.LOADING = 3;\n\n        // readyState value when the response entity body is being received\n        XMLHttpRequest.LOADING = 3;\n\n        // readyState value after the request has been completely processed\n        XMLHttpRequest.prototype.DONE = 4;\n\n        // readyState value after the request has been completely processed\n        XMLHttpRequest.DONE = 4;\n\n        // @property {http.Agent} the agent option passed to HTTP requests\n\n        // NOTE: this is not in the XMLHttpRequest API, and will not work in browsers.\n        // It is a stable node-xhr2 API that is useful for testing & going through\n        // web-proxies.\n        XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;\n\n        // @property {https.Agent} the agent option passed to HTTPS requests\n\n        // NOTE: this is not in the XMLHttpRequest API, and will not work in browsers.\n        // It is a stable node-xhr2 API that is useful for testing & going through\n        // web-proxies.\n        XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;\n\n        // @property {String} the base URL that relative URLs get resolved to\n\n        // NOTE: this is not in the XMLHttpRequest API, and will not work in browsers.\n        // Its browser equivalent is the base URL of the document associated with the\n        // Window object. It is a stable node-xhr2 API provided for libraries such as\n        // Angular Universal.\n        XMLHttpRequest.prototype.nodejsBaseUrl = null;\n\n        // HTTP methods that are disallowed in the XHR spec.\n\n        // @private\n        // @see Step 6 in http://www.w3.org/TR/XMLHttpRequest/#the-open()-method\n        XMLHttpRequest.prototype._restrictedMethods = {\n            CONNECT: true,\n            TRACE: true,\n            TRACK: true\n        };\n\n        // HTTP request headers that are disallowed in the XHR spec.\n\n        // @private\n        // @see Step 5 in\n        //   http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method\n        XMLHttpRequest.prototype._restrictedHeaders = {\n            'accept-charset': true,\n            'accept-encoding': true,\n            'access-control-request-headers': true,\n            'access-control-request-method': true,\n            connection: true,\n            'content-length': true,\n            cookie: true,\n            cookie2: true,\n            date: true,\n            dnt: true,\n            expect: true,\n            host: true,\n            'keep-alive': true,\n            origin: true,\n            referer: true,\n            te: true,\n            trailer: true,\n            'transfer-encoding': true,\n            upgrade: true,\n            via: true\n        };\n\n        // HTTP response headers that should not be exposed according to the XHR spec.\n\n        // @private\n        // @see Step 3 in\n        //     http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n        XMLHttpRequest.prototype._privateHeaders = {\n            'set-cookie': true,\n            'set-cookie2': true\n        };\n\n        // The default value of the User-Agent header.\n        XMLHttpRequest.prototype._userAgent = `Mozilla/5.0 (${os.type()} ${os.arch()}) ` + `node.js/${process.versions.node} v8/${process.versions.v8}`;\n\n        return XMLHttpRequest;\n\n    }).call(this);\n\n    // XMLHttpRequest is the result of require('node-xhr2').\n    module.exports = XMLHttpRequest;\n\n    // Make node-xhr2 work as a drop-in replacement for libraries that promote the\n    // following usage pattern:\n    //     var XMLHttpRequest = require('xhr-library-name').XMLHttpRequest\n    XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n\n    // This file defines the custom errors used in the XMLHttpRequest specification.\n\n    // Thrown if the XHR security policy is violated.\n    SecurityError = class SecurityError extends Error {\n        // @private\n        constructor() {\n            super();\n        }\n\n    };\n\n    // Thrown if the XHR security policy is violated.\n    XMLHttpRequest.SecurityError = SecurityError;\n\n    // Usually thrown if the XHR is in the wrong readyState for an operation.\n    InvalidStateError = class InvalidStateError extends Error {\n        // @private\n        constructor() {\n            super();\n        }\n\n    };\n\n    // Usually thrown if the XHR is in the wrong readyState for an operation.\n    InvalidStateError = class InvalidStateError extends Error { };\n\n    XMLHttpRequest.InvalidStateError = InvalidStateError;\n\n    // Thrown if there is a problem with the URL passed to the XHR.\n    NetworkError = class NetworkError extends Error {\n        // @private\n        constructor() {\n            super();\n        }\n\n    };\n\n    // Thrown if parsing URLs errors out.\n    XMLHttpRequest.SyntaxError = SyntaxError;\n\n    SyntaxError = class SyntaxError extends Error {\n        // @private:\n        constructor() {\n            super();\n        }\n\n    };\n\n    ProgressEvent = (function () {\n        // http://xhr.spec.whatwg.org/#interface-progressevent\n        class ProgressEvent {\n            // Creates a new event.\n\n            // @param {String} type the event type, e.g. 'readystatechange'; must be\n            //   lowercased\n            constructor(type) {\n                this.type = type;\n                this.target = null;\n                this.currentTarget = null;\n                this.lengthComputable = false;\n                this.loaded = 0;\n                this.total = 0;\n            }\n\n        };\n\n        // Getting the time from the OS is expensive, skip on that for now.\n        // @timeStamp = Date.now()\n\n        // @property {Boolean} for compatibility with DOM events\n        ProgressEvent.prototype.bubbles = false;\n\n        // @property {Boolean} for fompatibility with DOM events\n        ProgressEvent.prototype.cancelable = false;\n\n        // @property {XMLHttpRequest} the request that caused this event\n        ProgressEvent.prototype.target = null;\n\n        // @property {Number} number of bytes that have already been downloaded or\n        //   uploaded\n        ProgressEvent.prototype.loaded = null;\n\n        // @property {Boolean} true if the Content-Length response header is available\n        //   and the value of the event's total property is meaningful\n        ProgressEvent.prototype.lengthComputable = null;\n\n        // @property {Number} number of bytes that will be downloaded or uploaded by\n        //   the request that fired the event\n        ProgressEvent.prototype.total = null;\n\n        return ProgressEvent;\n\n    }).call(this);\n\n    // The XHR spec exports the ProgressEvent constructor.\n    XMLHttpRequest.ProgressEvent = ProgressEvent;\n\n    // @see http://xhr.spec.whatwg.org/#interface-xmlhttprequest\n    XMLHttpRequestUpload = class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n        // @private\n        // @param {XMLHttpRequest} the XMLHttpRequest that this upload object is\n        //   associated with\n        constructor(request) {\n            super();\n            this._request = request;\n            this._reset();\n        }\n\n        // Sets up this Upload to handle a new request.\n\n        // @private\n        // @return {undefined} undefined\n        _reset() {\n            this._contentType = null;\n            this._body = null;\n            return void 0;\n        }\n\n        // Implements the upload-related part of the send() XHR specification.\n\n        // @private\n        // @param {?String, ?Buffer, ?ArrayBufferView} data the argument passed to\n        //   XMLHttpRequest#send()\n        // @return {undefined} undefined\n        // @see step 4 of http://www.w3.org/TR/XMLHttpRequest/#the-send()-method\n        _setData(data) {\n            var body, i, j, k, offset, ref, ref1, view;\n            if (typeof data === 'undefined' || data === null) {\n                return;\n            }\n            if (typeof data === 'string') {\n                // DOMString\n                if (data.length !== 0) {\n                    this._contentType = 'text/plain;charset=UTF-8';\n                }\n                this._body = Buffer.from(data, 'utf8');\n            } else if (Buffer.isBuffer(data)) {\n                // node.js Buffer\n                this._body = data;\n            } else if (data instanceof ArrayBuffer) {\n                // ArrayBuffer arguments were supported in an old revision of the spec.\n                body = Buffer.alloc(data.byteLength);\n                view = new Uint8Array(data);\n                for (i = j = 0, ref = data.byteLength; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {\n                    body[i] = view[i];\n                }\n                this._body = body;\n            } else if (data.buffer && data.buffer instanceof ArrayBuffer) {\n                // ArrayBufferView\n                body = Buffer.alloc(data.byteLength);\n                offset = data.byteOffset;\n                view = new Uint8Array(data.buffer);\n                for (i = k = 0, ref1 = data.byteLength; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {\n                    body[i] = view[i + offset];\n                }\n                this._body = body;\n            } else {\n                // NOTE: diverging from the XHR specification of coercing everything else\n                //       to Strings via toString() because that behavior masks bugs and is\n                //       rarely useful\n                throw new Error(`Unsupported send() data ${data}`);\n            }\n            return void 0;\n        }\n\n        // Updates the HTTP headers right before the request is sent.\n\n        // This is used to set data-dependent headers such as Content-Length and\n        // Content-Type.\n\n        // @private\n        // @param {Object<String, String>} headers the HTTP headers to be sent\n        // @param {Object<String, String>} loweredHeaders maps lowercased HTTP header\n        //   names (e.g., 'content-type') to the actual names used in the headers\n        //   parameter (e.g., 'Content-Type')\n        // @return {undefined} undefined\n        _finalizeHeaders(headers, loweredHeaders) {\n            if (this._contentType) {\n                if (!('content-type' in loweredHeaders)) {\n                    headers['Content-Type'] = this._contentType;\n                }\n            }\n            if (this._body) {\n                // Restricted headers can't be set by the user, no need to check\n                // loweredHeaders.\n                headers['Content-Length'] = this._body.length.toString();\n            }\n            return void 0;\n        }\n\n        // Starts sending the HTTP request data.\n\n        // @private\n        // @param {http.ClientRequest} request the HTTP request\n        // @return {undefined} undefined\n        _startUpload(request) {\n            if (this._body) {\n                request.write(this._body);\n            }\n            request.end();\n            return void 0;\n        }\n\n    };\n\n    // Export the XMLHttpRequestUpload constructor.\n    XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;\n\n    if(typeof global !== \"undefined\") {\n        global.XMLHttpRequest = XMLHttpRequest;\n    }\n\n}).call(this);\n\n\n//Included:lib/001.02.axios-v0.27.2.part.js\n/*lib:axios v0.27.2 + modifications*/\n/*(c) 2022 by Matt Zabriskie*/\n(function webpackUniversalModuleDefinition(factory) {\n    const axios_module = factory();\n    if (typeof exports === 'object' && typeof module === 'object') {\n        module.exports = axios_module;\n    } else if (typeof exports === 'object') {\n        exports[\"axios\"] = axios_module;\n    }\n    if(typeof window !== \"undefined\") {\n        window.axios = axios_module;\n    }\n    if(typeof global !== \"undefined\") {\n        global.axios = axios_module;\n    }\n})(function () {\n    return /******/ (function (modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif (installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n                /******/\n}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n                /******/\n};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n            /******/\n}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function (exports, name, getter) {\n/******/ \t\tif (!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n                /******/\n}\n            /******/\n};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function (exports) {\n/******/ \t\tif (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n                /******/\n}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n            /******/\n};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function (value, mode) {\n/******/ \t\tif (mode & 1) value = __webpack_require__(value);\n/******/ \t\tif (mode & 8) return value;\n/******/ \t\tif ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n            /******/\n};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function (module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n            /******/\n};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n        /******/\n})\n/************************************************************************/\n/******/({\n\n/***/ \"./index.js\":\n/*!******************!*\\\n  !*** ./index.js ***!\n  \\******************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                module.exports = __webpack_require__(/*! ./lib/axios */ \"./lib/axios.js\");\n\n                /***/\n}),\n\n/***/ \"./lib/adapters/xhr.js\":\n/*!*****************************!*\\\n  !*** ./lib/adapters/xhr.js ***!\n  \\*****************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n                var settle = __webpack_require__(/*! ./../core/settle */ \"./lib/core/settle.js\");\n                var cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./lib/helpers/cookies.js\");\n                var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./lib/helpers/buildURL.js\");\n                var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./lib/core/buildFullPath.js\");\n                var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./lib/helpers/parseHeaders.js\");\n                var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./lib/helpers/isURLSameOrigin.js\");\n                var transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ \"./lib/defaults/transitional.js\");\n                var AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./lib/core/AxiosError.js\");\n                var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./lib/cancel/CanceledError.js\");\n                var parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ \"./lib/helpers/parseProtocol.js\");\n\n                module.exports = function xhrAdapter(config) {\n                    return new Promise(function dispatchXhrRequest(resolve, reject) {\n                        var requestData = config.data;\n                        var requestHeaders = config.headers;\n                        var responseType = config.responseType;\n                        var onCanceled;\n                        function done() {\n                            if (config.cancelToken) {\n                                config.cancelToken.unsubscribe(onCanceled);\n                            }\n\n                            if (config.signal) {\n                                config.signal.removeEventListener('abort', onCanceled);\n                            }\n                        }\n\n                        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n                            delete requestHeaders['Content-Type']; // Let the browser set it\n                        }\n\n                        var request = new XMLHttpRequest();\n\n                        // HTTP basic authentication\n                        if (config.auth) {\n                            var username = config.auth.username || '';\n                            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n                            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n                        }\n\n                        var fullPath = buildFullPath(config.baseURL, config.url);\n\n                        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n                        // Set the request timeout in MS\n                        request.timeout = config.timeout;\n\n                        function onloadend() {\n                            if (!request) {\n                                return;\n                            }\n                            // Prepare the response\n                            var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n                            var responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n                                request.responseText : request.response;\n                            var response = {\n                                data: responseData,\n                                status: request.status,\n                                statusText: request.statusText,\n                                headers: responseHeaders,\n                                config: config,\n                                request: request\n                            };\n\n                            settle(function _resolve(value) {\n                                resolve(value);\n                                done();\n                            }, function _reject(err) {\n                                reject(err);\n                                done();\n                            }, response);\n\n                            // Clean up request\n                            request = null;\n                        }\n\n                        if ('onloadend' in request) {\n                            // Use onloadend if available\n                            request.onloadend = onloadend;\n                        } else {\n                            // Listen for ready state to emulate onloadend\n                            request.onreadystatechange = function handleLoad() {\n                                if (!request || request.readyState !== 4) {\n                                    return;\n                                }\n\n                                // The request errored out and we didn't get a response, this will be\n                                // handled by onerror instead\n                                // With one exception: request that using file: protocol, most browsers\n                                // will return status as 0 even though it's a successful request\n                                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n                                    return;\n                                }\n                                // readystate handler is calling before onerror or ontimeout handlers,\n                                // so we should call onloadend on the next 'tick'\n                                setTimeout(onloadend);\n                            };\n                        }\n\n                        // Handle browser request cancellation (as opposed to a manual cancellation)\n                        request.onabort = function handleAbort() {\n                            if (!request) {\n                                return;\n                            }\n\n                            reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n                            // Clean up request\n                            request = null;\n                        };\n\n                        // Handle low level network errors\n                        request.onerror = function handleError() {\n                            // Real errors are hidden from us by the browser\n                            // onerror should only fire if it's a network error\n                            reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));\n\n                            // Clean up request\n                            request = null;\n                        };\n\n                        // Handle timeout\n                        request.ontimeout = function handleTimeout() {\n                            var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n                            var transitional = config.transitional || transitionalDefaults;\n                            if (config.timeoutErrorMessage) {\n                                timeoutErrorMessage = config.timeoutErrorMessage;\n                            }\n                            reject(new AxiosError(\n                                timeoutErrorMessage,\n                                transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n                                config,\n                                request));\n\n                            // Clean up request\n                            request = null;\n                        };\n\n                        // Add xsrf header\n                        // This is only done if running in a standard browser environment.\n                        // Specifically not if we're in a web worker, or react-native.\n                        if (utils.isStandardBrowserEnv()) {\n                            // Add xsrf header\n                            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n                                cookies.read(config.xsrfCookieName) :\n                                undefined;\n\n                            if (xsrfValue) {\n                                requestHeaders[config.xsrfHeaderName] = xsrfValue;\n                            }\n                        }\n\n                        // Add headers to the request\n                        if ('setRequestHeader' in request) {\n                            utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n                                if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n                                    // Remove Content-Type if data is undefined\n                                    delete requestHeaders[key];\n                                } else {\n                                    // Otherwise add header to the request\n                                    request.setRequestHeader(key, val);\n                                }\n                            });\n                        }\n\n                        // Add withCredentials to request if needed\n                        if (!utils.isUndefined(config.withCredentials)) {\n                            request.withCredentials = !!config.withCredentials;\n                        }\n\n                        // Add responseType to request if needed\n                        if (responseType && responseType !== 'json') {\n                            request.responseType = config.responseType;\n                        }\n\n                        // Handle progress if needed\n                        if (typeof config.onDownloadProgress === 'function') {\n                            request.addEventListener('progress', config.onDownloadProgress);\n                        }\n\n                        // Not all browsers support upload events\n                        if (typeof config.onUploadProgress === 'function' && request.upload) {\n                            request.upload.addEventListener('progress', config.onUploadProgress);\n                        }\n\n                        if (config.cancelToken || config.signal) {\n                            // Handle cancellation\n                            // eslint-disable-next-line func-names\n                            onCanceled = function (cancel) {\n                                if (!request) {\n                                    return;\n                                }\n                                reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);\n                                request.abort();\n                                request = null;\n                            };\n\n                            config.cancelToken && config.cancelToken.subscribe(onCanceled);\n                            if (config.signal) {\n                                config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n                            }\n                        }\n\n                        if (!requestData) {\n                            requestData = null;\n                        }\n\n                        var protocol = parseProtocol(fullPath);\n\n                        if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {\n                            reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n                            return;\n                        }\n\n\n                        // Send the request\n                        request.send(requestData);\n                    });\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/axios.js\":\n/*!**********************!*\\\n  !*** ./lib/axios.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\n                var bind = __webpack_require__(/*! ./helpers/bind */ \"./lib/helpers/bind.js\");\n                var Axios = __webpack_require__(/*! ./core/Axios */ \"./lib/core/Axios.js\");\n                var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./lib/core/mergeConfig.js\");\n                var defaults = __webpack_require__(/*! ./defaults */ \"./lib/defaults/index.js\");\n\n                /**\n                 * Create an instance of Axios\n                 *\n                 * @param {Object} defaultConfig The default config for the instance\n                 * @return {Axios} A new instance of Axios\n                 */\n                function createInstance(defaultConfig) {\n                    var context = new Axios(defaultConfig);\n                    var instance = bind(Axios.prototype.request, context);\n\n                    // Copy axios.prototype to instance\n                    utils.extend(instance, Axios.prototype, context);\n\n                    // Copy context to instance\n                    utils.extend(instance, context);\n\n                    // Factory for creating new instances\n                    instance.create = function create(instanceConfig) {\n                        return createInstance(mergeConfig(defaultConfig, instanceConfig));\n                    };\n\n                    return instance;\n                }\n\n                // Create the default instance to be exported\n                var axios = createInstance(defaults);\n\n                // Expose Axios class to allow class inheritance\n                axios.Axios = Axios;\n\n                // Expose Cancel & CancelToken\n                axios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ \"./lib/cancel/CanceledError.js\");\n                axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./lib/cancel/CancelToken.js\");\n                axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./lib/cancel/isCancel.js\");\n                axios.VERSION = __webpack_require__(/*! ./env/data */ \"./lib/env/data.js\").version;\n                axios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ \"./lib/helpers/toFormData.js\");\n\n                // Expose AxiosError class\n                axios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ \"./lib/core/AxiosError.js\");\n\n                // alias for CanceledError for backward compatibility\n                axios.Cancel = axios.CanceledError;\n\n                // Expose all/spread\n                axios.all = function all(promises) {\n                    return Promise.all(promises);\n                };\n                axios.spread = __webpack_require__(/*! ./helpers/spread */ \"./lib/helpers/spread.js\");\n\n                // Expose isAxiosError\n                axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./lib/helpers/isAxiosError.js\");\n\n                module.exports = axios;\n\n                // Allow use of default import syntax in TypeScript\n                module.exports.default = axios;\n\n\n                /***/\n}),\n\n/***/ \"./lib/cancel/CancelToken.js\":\n/*!***********************************!*\\\n  !*** ./lib/cancel/CancelToken.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var CanceledError = __webpack_require__(/*! ./CanceledError */ \"./lib/cancel/CanceledError.js\");\n\n                /**\n                 * A `CancelToken` is an object that can be used to request cancellation of an operation.\n                 *\n                 * @class\n                 * @param {Function} executor The executor function.\n                 */\n                function CancelToken(executor) {\n                    if (typeof executor !== 'function') {\n                        throw new TypeError('executor must be a function.');\n                    }\n\n                    var resolvePromise;\n\n                    this.promise = new Promise(function promiseExecutor(resolve) {\n                        resolvePromise = resolve;\n                    });\n\n                    var token = this;\n\n                    // eslint-disable-next-line func-names\n                    this.promise.then(function (cancel) {\n                        if (!token._listeners) return;\n\n                        var i;\n                        var l = token._listeners.length;\n\n                        for (i = 0; i < l; i++) {\n                            token._listeners[i](cancel);\n                        }\n                        token._listeners = null;\n                    });\n\n                    // eslint-disable-next-line func-names\n                    this.promise.then = function (onfulfilled) {\n                        var _resolve;\n                        // eslint-disable-next-line func-names\n                        var promise = new Promise(function (resolve) {\n                            token.subscribe(resolve);\n                            _resolve = resolve;\n                        }).then(onfulfilled);\n\n                        promise.cancel = function reject() {\n                            token.unsubscribe(_resolve);\n                        };\n\n                        return promise;\n                    };\n\n                    executor(function cancel(message) {\n                        if (token.reason) {\n                            // Cancellation has already been requested\n                            return;\n                        }\n\n                        token.reason = new CanceledError(message);\n                        resolvePromise(token.reason);\n                    });\n                }\n\n                /**\n                 * Throws a `CanceledError` if cancellation has been requested.\n                 */\n                CancelToken.prototype.throwIfRequested = function throwIfRequested() {\n                    if (this.reason) {\n                        throw this.reason;\n                    }\n                };\n\n                /**\n                 * Subscribe to the cancel signal\n                 */\n\n                CancelToken.prototype.subscribe = function subscribe(listener) {\n                    if (this.reason) {\n                        listener(this.reason);\n                        return;\n                    }\n\n                    if (this._listeners) {\n                        this._listeners.push(listener);\n                    } else {\n                        this._listeners = [listener];\n                    }\n                };\n\n                /**\n                 * Unsubscribe from the cancel signal\n                 */\n\n                CancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n                    if (!this._listeners) {\n                        return;\n                    }\n                    var index = this._listeners.indexOf(listener);\n                    if (index !== -1) {\n                        this._listeners.splice(index, 1);\n                    }\n                };\n\n                /**\n                 * Returns an object that contains a new `CancelToken` and a function that, when called,\n                 * cancels the `CancelToken`.\n                 */\n                CancelToken.source = function source() {\n                    var cancel;\n                    var token = new CancelToken(function executor(c) {\n                        cancel = c;\n                    });\n                    return {\n                        token: token,\n                        cancel: cancel\n                    };\n                };\n\n                module.exports = CancelToken;\n\n\n                /***/\n}),\n\n/***/ \"./lib/cancel/CanceledError.js\":\n/*!*************************************!*\\\n  !*** ./lib/cancel/CanceledError.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./lib/core/AxiosError.js\");\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n\n                /**\n                 * A `CanceledError` is an object that is thrown when an operation is canceled.\n                 *\n                 * @class\n                 * @param {string=} message The message.\n                 */\n                function CanceledError(message) {\n                    // eslint-disable-next-line no-eq-null,eqeqeq\n                    AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);\n                    this.name = 'CanceledError';\n                }\n\n                utils.inherits(CanceledError, AxiosError, {\n                    __CANCEL__: true\n                });\n\n                module.exports = CanceledError;\n\n\n                /***/\n}),\n\n/***/ \"./lib/cancel/isCancel.js\":\n/*!********************************!*\\\n  !*** ./lib/cancel/isCancel.js ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                module.exports = function isCancel(value) {\n                    return !!(value && value.__CANCEL__);\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/Axios.js\":\n/*!***************************!*\\\n  !*** ./lib/core/Axios.js ***!\n  \\***************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n                var buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./lib/helpers/buildURL.js\");\n                var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./lib/core/InterceptorManager.js\");\n                var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./lib/core/dispatchRequest.js\");\n                var mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./lib/core/mergeConfig.js\");\n                var buildFullPath = __webpack_require__(/*! ./buildFullPath */ \"./lib/core/buildFullPath.js\");\n                var validator = __webpack_require__(/*! ../helpers/validator */ \"./lib/helpers/validator.js\");\n\n                var validators = validator.validators;\n                /**\n                 * Create a new instance of Axios\n                 *\n                 * @param {Object} instanceConfig The default config for the instance\n                 */\n                function Axios(instanceConfig) {\n                    this.defaults = instanceConfig;\n                    this.interceptors = {\n                        request: new InterceptorManager(),\n                        response: new InterceptorManager()\n                    };\n                }\n\n                /**\n                 * Dispatch a request\n                 *\n                 * @param {Object} config The config specific for this request (merged with this.defaults)\n                 */\n                Axios.prototype.request = function request(configOrUrl, config) {\n                    /*eslint no-param-reassign:0*/\n                    // Allow for axios('example/url'[, config]) a la fetch API\n                    if (typeof configOrUrl === 'string') {\n                        config = config || {};\n                        config.url = configOrUrl;\n                    } else {\n                        config = configOrUrl || {};\n                    }\n\n                    config = mergeConfig(this.defaults, config);\n\n                    // Set config.method\n                    if (config.method) {\n                        config.method = config.method.toLowerCase();\n                    } else if (this.defaults.method) {\n                        config.method = this.defaults.method.toLowerCase();\n                    } else {\n                        config.method = 'get';\n                    }\n\n                    var transitional = config.transitional;\n\n                    if (transitional !== undefined) {\n                        validator.assertOptions(transitional, {\n                            silentJSONParsing: validators.transitional(validators.boolean),\n                            forcedJSONParsing: validators.transitional(validators.boolean),\n                            clarifyTimeoutError: validators.transitional(validators.boolean)\n                        }, false);\n                    }\n\n                    // filter out skipped interceptors\n                    var requestInterceptorChain = [];\n                    var synchronousRequestInterceptors = true;\n                    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n                        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n                            return;\n                        }\n\n                        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n                        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n                    });\n\n                    var responseInterceptorChain = [];\n                    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n                        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n                    });\n\n                    var promise;\n\n                    if (!synchronousRequestInterceptors) {\n                        var chain = [dispatchRequest, undefined];\n\n                        Array.prototype.unshift.apply(chain, requestInterceptorChain);\n                        chain = chain.concat(responseInterceptorChain);\n\n                        promise = Promise.resolve(config);\n                        while (chain.length) {\n                            promise = promise.then(chain.shift(), chain.shift());\n                        }\n\n                        return promise;\n                    }\n\n\n                    var newConfig = config;\n                    while (requestInterceptorChain.length) {\n                        var onFulfilled = requestInterceptorChain.shift();\n                        var onRejected = requestInterceptorChain.shift();\n                        try {\n                            newConfig = onFulfilled(newConfig);\n                        } catch (error) {\n                            onRejected(error);\n                            break;\n                        }\n                    }\n\n                    try {\n                        promise = dispatchRequest(newConfig);\n                    } catch (error) {\n                        return Promise.reject(error);\n                    }\n\n                    while (responseInterceptorChain.length) {\n                        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n                    }\n\n                    return promise;\n                };\n\n                Axios.prototype.getUri = function getUri(config) {\n                    config = mergeConfig(this.defaults, config);\n                    var fullPath = buildFullPath(config.baseURL, config.url);\n                    return buildURL(fullPath, config.params, config.paramsSerializer);\n                };\n\n                // Provide aliases for supported request methods\n                utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n                    /*eslint func-names:0*/\n                    Axios.prototype[method] = function (url, config) {\n                        return this.request(mergeConfig(config || {}, {\n                            method: method,\n                            url: url,\n                            data: (config || {}).data\n                        }));\n                    };\n                });\n\n                utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n                    /*eslint func-names:0*/\n\n                    function generateHTTPMethod(isForm) {\n                        return function httpMethod(url, data, config) {\n                            return this.request(mergeConfig(config || {}, {\n                                method: method,\n                                headers: isForm ? {\n                                    'Content-Type': 'multipart/form-data'\n                                } : {},\n                                url: url,\n                                data: data\n                            }));\n                        };\n                    }\n\n                    Axios.prototype[method] = generateHTTPMethod();\n\n                    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n                });\n\n                module.exports = Axios;\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/AxiosError.js\":\n/*!********************************!*\\\n  !*** ./lib/core/AxiosError.js ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n\n                /**\n                 * Create an Error with the specified message, config, error code, request and response.\n                 *\n                 * @param {string} message The error message.\n                 * @param {string} [code] The error code (for example, 'ECONNABORTED').\n                 * @param {Object} [config] The config.\n                 * @param {Object} [request] The request.\n                 * @param {Object} [response] The response.\n                 * @returns {Error} The created error.\n                 */\n                function AxiosError(message, code, config, request, response) {\n                    Error.call(this);\n                    this.message = message;\n                    this.name = 'AxiosError';\n                    code && (this.code = code);\n                    config && (this.config = config);\n                    request && (this.request = request);\n                    response && (this.response = response);\n                }\n\n                utils.inherits(AxiosError, Error, {\n                    toJSON: function toJSON() {\n                        return {\n                            // Standard\n                            message: this.message,\n                            name: this.name,\n                            // Microsoft\n                            description: this.description,\n                            number: this.number,\n                            // Mozilla\n                            fileName: this.fileName,\n                            lineNumber: this.lineNumber,\n                            columnNumber: this.columnNumber,\n                            stack: this.stack,\n                            // Axios\n                            config: this.config,\n                            code: this.code,\n                            status: this.response && this.response.status ? this.response.status : null\n                        };\n                    }\n                });\n\n                var prototype = AxiosError.prototype;\n                var descriptors = {};\n\n                [\n                    'ERR_BAD_OPTION_VALUE',\n                    'ERR_BAD_OPTION',\n                    'ECONNABORTED',\n                    'ETIMEDOUT',\n                    'ERR_NETWORK',\n                    'ERR_FR_TOO_MANY_REDIRECTS',\n                    'ERR_DEPRECATED',\n                    'ERR_BAD_RESPONSE',\n                    'ERR_BAD_REQUEST',\n                    'ERR_CANCELED'\n                    // eslint-disable-next-line func-names\n                ].forEach(function (code) {\n                    descriptors[code] = { value: code };\n                });\n\n                Object.defineProperties(AxiosError, descriptors);\n                Object.defineProperty(prototype, 'isAxiosError', { value: true });\n\n                // eslint-disable-next-line func-names\n                AxiosError.from = function (error, code, config, request, response, customProps) {\n                    var axiosError = Object.create(prototype);\n\n                    utils.toFlatObject(error, axiosError, function filter(obj) {\n                        return obj !== Error.prototype;\n                    });\n\n                    AxiosError.call(axiosError, error.message, code, config, request, response);\n\n                    axiosError.name = error.name;\n\n                    customProps && Object.assign(axiosError, customProps);\n\n                    return axiosError;\n                };\n\n                module.exports = AxiosError;\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/InterceptorManager.js\":\n/*!****************************************!*\\\n  !*** ./lib/core/InterceptorManager.js ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                function InterceptorManager() {\n                    this.handlers = [];\n                }\n\n                /**\n                 * Add a new interceptor to the stack\n                 *\n                 * @param {Function} fulfilled The function to handle `then` for a `Promise`\n                 * @param {Function} rejected The function to handle `reject` for a `Promise`\n                 *\n                 * @return {Number} An ID used to remove interceptor later\n                 */\n                InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n                    this.handlers.push({\n                        fulfilled: fulfilled,\n                        rejected: rejected,\n                        synchronous: options ? options.synchronous : false,\n                        runWhen: options ? options.runWhen : null\n                    });\n                    return this.handlers.length - 1;\n                };\n\n                /**\n                 * Remove an interceptor from the stack\n                 *\n                 * @param {Number} id The ID that was returned by `use`\n                 */\n                InterceptorManager.prototype.eject = function eject(id) {\n                    if (this.handlers[id]) {\n                        this.handlers[id] = null;\n                    }\n                };\n\n                /**\n                 * Iterate over all the registered interceptors\n                 *\n                 * This method is particularly useful for skipping over any\n                 * interceptors that may have become `null` calling `eject`.\n                 *\n                 * @param {Function} fn The function to call for each interceptor\n                 */\n                InterceptorManager.prototype.forEach = function forEach(fn) {\n                    utils.forEach(this.handlers, function forEachHandler(h) {\n                        if (h !== null) {\n                            fn(h);\n                        }\n                    });\n                };\n\n                module.exports = InterceptorManager;\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/buildFullPath.js\":\n/*!***********************************!*\\\n  !*** ./lib/core/buildFullPath.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./lib/helpers/isAbsoluteURL.js\");\n                var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./lib/helpers/combineURLs.js\");\n\n                /**\n                 * Creates a new URL by combining the baseURL with the requestedURL,\n                 * only when the requestedURL is not already an absolute URL.\n                 * If the requestURL is absolute, this function returns the requestedURL untouched.\n                 *\n                 * @param {string} baseURL The base URL\n                 * @param {string} requestedURL Absolute or relative URL to combine\n                 * @returns {string} The combined full path\n                 */\n                module.exports = function buildFullPath(baseURL, requestedURL) {\n                    if (baseURL && !isAbsoluteURL(requestedURL)) {\n                        return combineURLs(baseURL, requestedURL);\n                    }\n                    return requestedURL;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/dispatchRequest.js\":\n/*!*************************************!*\\\n  !*** ./lib/core/dispatchRequest.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n                var transformData = __webpack_require__(/*! ./transformData */ \"./lib/core/transformData.js\");\n                var isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./lib/cancel/isCancel.js\");\n                var defaults = __webpack_require__(/*! ../defaults */ \"./lib/defaults/index.js\");\n                var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./lib/cancel/CanceledError.js\");\n\n                /**\n                 * Throws a `CanceledError` if cancellation has been requested.\n                 */\n                function throwIfCancellationRequested(config) {\n                    if (config.cancelToken) {\n                        config.cancelToken.throwIfRequested();\n                    }\n\n                    if (config.signal && config.signal.aborted) {\n                        throw new CanceledError();\n                    }\n                }\n\n                /**\n                 * Dispatch a request to the server using the configured adapter.\n                 *\n                 * @param {object} config The config that is to be used for the request\n                 * @returns {Promise} The Promise to be fulfilled\n                 */\n                module.exports = function dispatchRequest(config) {\n                    throwIfCancellationRequested(config);\n\n                    // Ensure headers exist\n                    config.headers = config.headers || {};\n\n                    // Transform request data\n                    config.data = transformData.call(\n                        config,\n                        config.data,\n                        config.headers,\n                        config.transformRequest\n                    );\n\n                    // Flatten headers\n                    config.headers = utils.merge(\n                        config.headers.common || {},\n                        config.headers[config.method] || {},\n                        config.headers\n                    );\n\n                    utils.forEach(\n                        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n                        function cleanHeaderConfig(method) {\n                            delete config.headers[method];\n                        }\n                    );\n\n                    var adapter = config.adapter || defaults.adapter;\n\n                    return adapter(config).then(function onAdapterResolution(response) {\n                        throwIfCancellationRequested(config);\n\n                        // Transform response data\n                        response.data = transformData.call(\n                            config,\n                            response.data,\n                            response.headers,\n                            config.transformResponse\n                        );\n\n                        return response;\n                    }, function onAdapterRejection(reason) {\n                        if (!isCancel(reason)) {\n                            throwIfCancellationRequested(config);\n\n                            // Transform response data\n                            if (reason && reason.response) {\n                                reason.response.data = transformData.call(\n                                    config,\n                                    reason.response.data,\n                                    reason.response.headers,\n                                    config.transformResponse\n                                );\n                            }\n                        }\n\n                        return Promise.reject(reason);\n                    });\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/mergeConfig.js\":\n/*!*********************************!*\\\n  !*** ./lib/core/mergeConfig.js ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n\n                /**\n                 * Config-specific merge-function which creates a new config-object\n                 * by merging two configuration objects together.\n                 *\n                 * @param {Object} config1\n                 * @param {Object} config2\n                 * @returns {Object} New object resulting from merging config2 to config1\n                 */\n                module.exports = function mergeConfig(config1, config2) {\n                    // eslint-disable-next-line no-param-reassign\n                    config2 = config2 || {};\n                    var config = {};\n\n                    function getMergedValue(target, source) {\n                        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n                            return utils.merge(target, source);\n                        } else if (utils.isPlainObject(source)) {\n                            return utils.merge({}, source);\n                        } else if (utils.isArray(source)) {\n                            return source.slice();\n                        }\n                        return source;\n                    }\n\n                    // eslint-disable-next-line consistent-return\n                    function mergeDeepProperties(prop) {\n                        if (!utils.isUndefined(config2[prop])) {\n                            return getMergedValue(config1[prop], config2[prop]);\n                        } else if (!utils.isUndefined(config1[prop])) {\n                            return getMergedValue(undefined, config1[prop]);\n                        }\n                    }\n\n                    // eslint-disable-next-line consistent-return\n                    function valueFromConfig2(prop) {\n                        if (!utils.isUndefined(config2[prop])) {\n                            return getMergedValue(undefined, config2[prop]);\n                        }\n                    }\n\n                    // eslint-disable-next-line consistent-return\n                    function defaultToConfig2(prop) {\n                        if (!utils.isUndefined(config2[prop])) {\n                            return getMergedValue(undefined, config2[prop]);\n                        } else if (!utils.isUndefined(config1[prop])) {\n                            return getMergedValue(undefined, config1[prop]);\n                        }\n                    }\n\n                    // eslint-disable-next-line consistent-return\n                    function mergeDirectKeys(prop) {\n                        if (prop in config2) {\n                            return getMergedValue(config1[prop], config2[prop]);\n                        } else if (prop in config1) {\n                            return getMergedValue(undefined, config1[prop]);\n                        }\n                    }\n\n                    var mergeMap = {\n                        'url': valueFromConfig2,\n                        'method': valueFromConfig2,\n                        'data': valueFromConfig2,\n                        'baseURL': defaultToConfig2,\n                        'transformRequest': defaultToConfig2,\n                        'transformResponse': defaultToConfig2,\n                        'paramsSerializer': defaultToConfig2,\n                        'timeout': defaultToConfig2,\n                        'timeoutMessage': defaultToConfig2,\n                        'withCredentials': defaultToConfig2,\n                        'adapter': defaultToConfig2,\n                        'responseType': defaultToConfig2,\n                        'xsrfCookieName': defaultToConfig2,\n                        'xsrfHeaderName': defaultToConfig2,\n                        'onUploadProgress': defaultToConfig2,\n                        'onDownloadProgress': defaultToConfig2,\n                        'decompress': defaultToConfig2,\n                        'maxContentLength': defaultToConfig2,\n                        'maxBodyLength': defaultToConfig2,\n                        'beforeRedirect': defaultToConfig2,\n                        'transport': defaultToConfig2,\n                        'httpAgent': defaultToConfig2,\n                        'httpsAgent': defaultToConfig2,\n                        'cancelToken': defaultToConfig2,\n                        'socketPath': defaultToConfig2,\n                        'responseEncoding': defaultToConfig2,\n                        'validateStatus': mergeDirectKeys\n                    };\n\n                    utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n                        var merge = mergeMap[prop] || mergeDeepProperties;\n                        var configValue = merge(prop);\n                        (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n                    });\n\n                    return config;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/settle.js\":\n/*!****************************!*\\\n  !*** ./lib/core/settle.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var AxiosError = __webpack_require__(/*! ./AxiosError */ \"./lib/core/AxiosError.js\");\n\n                /**\n                 * Resolve or reject a Promise based on response status.\n                 *\n                 * @param {Function} resolve A function that resolves the promise.\n                 * @param {Function} reject A function that rejects the promise.\n                 * @param {object} response The response.\n                 */\n                module.exports = function settle(resolve, reject, response) {\n                    var validateStatus = response.config.validateStatus;\n                    if (!response.status || !validateStatus || validateStatus(response.status)) {\n                        resolve(response);\n                    } else {\n                        reject(new AxiosError(\n                            'Request failed with status code ' + response.status,\n                            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n                            response.config,\n                            response.request,\n                            response\n                        ));\n                    }\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/core/transformData.js\":\n/*!***********************************!*\\\n  !*** ./lib/core/transformData.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n                var defaults = __webpack_require__(/*! ../defaults */ \"./lib/defaults/index.js\");\n\n                /**\n                 * Transform the data for a request or a response\n                 *\n                 * @param {Object|String} data The data to be transformed\n                 * @param {Array} headers The headers for the request or response\n                 * @param {Array|Function} fns A single function or Array of functions\n                 * @returns {*} The resulting transformed data\n                 */\n                module.exports = function transformData(data, headers, fns) {\n                    var context = this || defaults;\n                    /*eslint no-param-reassign:0*/\n                    utils.forEach(fns, function transform(fn) {\n                        data = fn.call(context, data, headers);\n                    });\n\n                    return data;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/defaults/index.js\":\n/*!*******************************!*\\\n  !*** ./lib/defaults/index.js ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n                var normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ \"./lib/helpers/normalizeHeaderName.js\");\n                var AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./lib/core/AxiosError.js\");\n                var transitionalDefaults = __webpack_require__(/*! ./transitional */ \"./lib/defaults/transitional.js\");\n                var toFormData = __webpack_require__(/*! ../helpers/toFormData */ \"./lib/helpers/toFormData.js\");\n\n                var DEFAULT_CONTENT_TYPE = {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                };\n\n                function setContentTypeIfUnset(headers, value) {\n                    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n                        headers['Content-Type'] = value;\n                    }\n                }\n\n                function getDefaultAdapter() {\n                    var adapter;\n                    if (typeof XMLHttpRequest !== 'undefined') {\n                        // For browsers use XHR adapter\n                        adapter = __webpack_require__(/*! ../adapters/xhr */ \"./lib/adapters/xhr.js\");\n                    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n                        // For node use HTTP adapter\n                        adapter = __webpack_require__(/*! ../adapters/http */ \"./lib/adapters/xhr.js\");\n                    }\n                    return adapter;\n                }\n\n                function stringifySafely(rawValue, parser, encoder) {\n                    if (utils.isString(rawValue)) {\n                        try {\n                            (parser || JSON.parse)(rawValue);\n                            return utils.trim(rawValue);\n                        } catch (e) {\n                            if (e.name !== 'SyntaxError') {\n                                throw e;\n                            }\n                        }\n                    }\n\n                    return (encoder || JSON.stringify)(rawValue);\n                }\n\n                var defaults = {\n\n                    transitional: transitionalDefaults,\n\n                    adapter: getDefaultAdapter(),\n\n                    transformRequest: [function transformRequest(data, headers) {\n                        normalizeHeaderName(headers, 'Accept');\n                        normalizeHeaderName(headers, 'Content-Type');\n\n                        if (utils.isFormData(data) ||\n                            utils.isArrayBuffer(data) ||\n                            utils.isBuffer(data) ||\n                            utils.isStream(data) ||\n                            utils.isFile(data) ||\n                            utils.isBlob(data)\n                        ) {\n                            return data;\n                        }\n                        if (utils.isArrayBufferView(data)) {\n                            return data.buffer;\n                        }\n                        if (utils.isURLSearchParams(data)) {\n                            setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n                            return data.toString();\n                        }\n\n                        var isObjectPayload = utils.isObject(data);\n                        var contentType = headers && headers['Content-Type'];\n\n                        var isFileList;\n\n                        if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {\n                            var _FormData = this.env && this.env.FormData;\n                            return toFormData(isFileList ? { 'files[]': data } : data, _FormData && new _FormData());\n                        } else if (isObjectPayload || contentType === 'application/json') {\n                            setContentTypeIfUnset(headers, 'application/json');\n                            return stringifySafely(data);\n                        }\n\n                        return data;\n                    }],\n\n                    transformResponse: [function transformResponse(data) {\n                        var transitional = this.transitional || defaults.transitional;\n                        var silentJSONParsing = transitional && transitional.silentJSONParsing;\n                        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n                        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n                        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n                            try {\n                                return JSON.parse(data);\n                            } catch (e) {\n                                if (strictJSONParsing) {\n                                    if (e.name === 'SyntaxError') {\n                                        throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n                                    }\n                                    throw e;\n                                }\n                            }\n                        }\n\n                        return data;\n                    }],\n\n                    /**\n                     * A timeout in milliseconds to abort a request. If set to 0 (default) a\n                     * timeout is not created.\n                     */\n                    timeout: 0,\n\n                    xsrfCookieName: 'XSRF-TOKEN',\n                    xsrfHeaderName: 'X-XSRF-TOKEN',\n\n                    maxContentLength: -1,\n                    maxBodyLength: -1,\n\n                    env: {\n                        FormData: __webpack_require__(/*! ./env/FormData */ \"./lib/helpers/null.js\")\n                    },\n\n                    validateStatus: function validateStatus(status) {\n                        return status >= 200 && status < 300;\n                    },\n\n                    headers: {\n                        common: {\n                            'Accept': 'application/json, text/plain, */*'\n                        }\n                    }\n                };\n\n                utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n                    defaults.headers[method] = {};\n                });\n\n                utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n                    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n                });\n\n                module.exports = defaults;\n\n\n                /***/\n}),\n\n/***/ \"./lib/defaults/transitional.js\":\n/*!**************************************!*\\\n  !*** ./lib/defaults/transitional.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                module.exports = {\n                    silentJSONParsing: true,\n                    forcedJSONParsing: true,\n                    clarifyTimeoutError: false\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/env/data.js\":\n/*!*************************!*\\\n  !*** ./lib/env/data.js ***!\n  \\*************************/\n/*! no static exports found */\n/***/ (function (module, exports) {\n\n                module.exports = {\n                    \"version\": \"0.27.2\"\n                };\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/bind.js\":\n/*!*****************************!*\\\n  !*** ./lib/helpers/bind.js ***!\n  \\*****************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                module.exports = function bind(fn, thisArg) {\n                    return function wrap() {\n                        var args = new Array(arguments.length);\n                        for (var i = 0; i < args.length; i++) {\n                            args[i] = arguments[i];\n                        }\n                        return fn.apply(thisArg, args);\n                    };\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/buildURL.js\":\n/*!*********************************!*\\\n  !*** ./lib/helpers/buildURL.js ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                function encode(val) {\n                    return encodeURIComponent(val).\n                        replace(/%3A/gi, ':').\n                        replace(/%24/g, '$').\n                        replace(/%2C/gi, ',').\n                        replace(/%20/g, '+').\n                        replace(/%5B/gi, '[').\n                        replace(/%5D/gi, ']');\n                }\n\n                /**\n                 * Build a URL by appending params to the end\n                 *\n                 * @param {string} url The base of the url (e.g., http://www.google.com)\n                 * @param {object} [params] The params to be appended\n                 * @returns {string} The formatted url\n                 */\n                module.exports = function buildURL(url, params, paramsSerializer) {\n                    /*eslint no-param-reassign:0*/\n                    if (!params) {\n                        return url;\n                    }\n\n                    var serializedParams;\n                    if (paramsSerializer) {\n                        serializedParams = paramsSerializer(params);\n                    } else if (utils.isURLSearchParams(params)) {\n                        serializedParams = params.toString();\n                    } else {\n                        var parts = [];\n\n                        utils.forEach(params, function serialize(val, key) {\n                            if (val === null || typeof val === 'undefined') {\n                                return;\n                            }\n\n                            if (utils.isArray(val)) {\n                                key = key + '[]';\n                            } else {\n                                val = [val];\n                            }\n\n                            utils.forEach(val, function parseValue(v) {\n                                if (utils.isDate(v)) {\n                                    v = v.toISOString();\n                                } else if (utils.isObject(v)) {\n                                    v = JSON.stringify(v);\n                                }\n                                parts.push(encode(key) + '=' + encode(v));\n                            });\n                        });\n\n                        serializedParams = parts.join('&');\n                    }\n\n                    if (serializedParams) {\n                        var hashmarkIndex = url.indexOf('#');\n                        if (hashmarkIndex !== -1) {\n                            url = url.slice(0, hashmarkIndex);\n                        }\n\n                        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n                    }\n\n                    return url;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/combineURLs.js\":\n/*!************************************!*\\\n  !*** ./lib/helpers/combineURLs.js ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                /**\n                 * Creates a new URL by combining the specified URLs\n                 *\n                 * @param {string} baseURL The base URL\n                 * @param {string} relativeURL The relative URL\n                 * @returns {string} The combined URL\n                 */\n                module.exports = function combineURLs(baseURL, relativeURL) {\n                    return relativeURL\n                        ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n                        : baseURL;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/cookies.js\":\n/*!********************************!*\\\n  !*** ./lib/helpers/cookies.js ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                module.exports = (\n                    utils.isStandardBrowserEnv() ?\n\n                        // Standard browser envs support document.cookie\n                        (function standardBrowserEnv() {\n                            return {\n                                write: function write(name, value, expires, path, domain, secure) {\n                                    var cookie = [];\n                                    cookie.push(name + '=' + encodeURIComponent(value));\n\n                                    if (utils.isNumber(expires)) {\n                                        cookie.push('expires=' + new Date(expires).toGMTString());\n                                    }\n\n                                    if (utils.isString(path)) {\n                                        cookie.push('path=' + path);\n                                    }\n\n                                    if (utils.isString(domain)) {\n                                        cookie.push('domain=' + domain);\n                                    }\n\n                                    if (secure === true) {\n                                        cookie.push('secure');\n                                    }\n\n                                    document.cookie = cookie.join('; ');\n                                },\n\n                                read: function read(name) {\n                                    var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n                                    return (match ? decodeURIComponent(match[3]) : null);\n                                },\n\n                                remove: function remove(name) {\n                                    this.write(name, '', Date.now() - 86400000);\n                                }\n                            };\n                        })() :\n\n                        // Non standard browser env (web workers, react-native) lack needed support.\n                        (function nonStandardBrowserEnv() {\n                            return {\n                                write: function write() { },\n                                read: function read() { return null; },\n                                remove: function remove() { }\n                            };\n                        })()\n                );\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/isAbsoluteURL.js\":\n/*!**************************************!*\\\n  !*** ./lib/helpers/isAbsoluteURL.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                /**\n                 * Determines whether the specified URL is absolute\n                 *\n                 * @param {string} url The URL to test\n                 * @returns {boolean} True if the specified URL is absolute, otherwise false\n                 */\n                module.exports = function isAbsoluteURL(url) {\n                    // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n                    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n                    // by any combination of letters, digits, plus, period, or hyphen.\n                    return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/isAxiosError.js\":\n/*!*************************************!*\\\n  !*** ./lib/helpers/isAxiosError.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                /**\n                 * Determines whether the payload is an error thrown by Axios\n                 *\n                 * @param {*} payload The value to test\n                 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n                 */\n                module.exports = function isAxiosError(payload) {\n                    return utils.isObject(payload) && (payload.isAxiosError === true);\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/isURLSameOrigin.js\":\n/*!****************************************!*\\\n  !*** ./lib/helpers/isURLSameOrigin.js ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                module.exports = (\n                    utils.isStandardBrowserEnv() ?\n\n                        // Standard browser envs have full support of the APIs needed to test\n                        // whether the request URL is of the same origin as current location.\n                        (function standardBrowserEnv() {\n                            var msie = /(msie|trident)/i.test(navigator.userAgent);\n                            var urlParsingNode = document.createElement('a');\n                            var originURL;\n\n                            /**\n                          * Parse a URL to discover it's components\n                          *\n                          * @param {String} url The URL to be parsed\n                          * @returns {Object}\n                          */\n                            function resolveURL(url) {\n                                var href = url;\n\n                                if (msie) {\n                                    // IE needs attribute set twice to normalize properties\n                                    urlParsingNode.setAttribute('href', href);\n                                    href = urlParsingNode.href;\n                                }\n\n                                urlParsingNode.setAttribute('href', href);\n\n                                // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n                                return {\n                                    href: urlParsingNode.href,\n                                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n                                    host: urlParsingNode.host,\n                                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n                                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n                                    hostname: urlParsingNode.hostname,\n                                    port: urlParsingNode.port,\n                                    pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                                        urlParsingNode.pathname :\n                                        '/' + urlParsingNode.pathname\n                                };\n                            }\n\n                            originURL = resolveURL(window.location.href);\n\n                            /**\n                          * Determine if a URL shares the same origin as the current location\n                          *\n                          * @param {String} requestURL The URL to test\n                          * @returns {boolean} True if URL shares the same origin, otherwise false\n                          */\n                            return function isURLSameOrigin(requestURL) {\n                                var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n                                return (parsed.protocol === originURL.protocol &&\n                                    parsed.host === originURL.host);\n                            };\n                        })() :\n\n                        // Non standard browser envs (web workers, react-native) lack needed support.\n                        (function nonStandardBrowserEnv() {\n                            return function isURLSameOrigin() {\n                                return true;\n                            };\n                        })()\n                );\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/normalizeHeaderName.js\":\n/*!********************************************!*\\\n  !*** ./lib/helpers/normalizeHeaderName.js ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n\n                module.exports = function normalizeHeaderName(headers, normalizedName) {\n                    utils.forEach(headers, function processHeader(value, name) {\n                        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n                            headers[normalizedName] = value;\n                            delete headers[name];\n                        }\n                    });\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/null.js\":\n/*!*****************************!*\\\n  !*** ./lib/helpers/null.js ***!\n  \\*****************************/\n/*! no static exports found */\n/***/ (function (module, exports) {\n\n                // eslint-disable-next-line strict\n                module.exports = null;\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/parseHeaders.js\":\n/*!*************************************!*\\\n  !*** ./lib/helpers/parseHeaders.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ./../utils */ \"./lib/utils.js\");\n\n                // Headers whose duplicates are ignored by node\n                // c.f. https://nodejs.org/api/http.html#http_message_headers\n                var ignoreDuplicateOf = [\n                    'age', 'authorization', 'content-length', 'content-type', 'etag',\n                    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n                    'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n                    'referer', 'retry-after', 'user-agent'\n                ];\n\n                /**\n                 * Parse headers into an object\n                 *\n                 * ```\n                 * Date: Wed, 27 Aug 2014 08:58:49 GMT\n                 * Content-Type: application/json\n                 * Connection: keep-alive\n                 * Transfer-Encoding: chunked\n                 * ```\n                 *\n                 * @param {String} headers Headers needing to be parsed\n                 * @returns {Object} Headers parsed into an object\n                 */\n                module.exports = function parseHeaders(headers) {\n                    var parsed = {};\n                    var key;\n                    var val;\n                    var i;\n\n                    if (!headers) { return parsed; }\n\n                    utils.forEach(headers.split('\\n'), function parser(line) {\n                        i = line.indexOf(':');\n                        key = utils.trim(line.substr(0, i)).toLowerCase();\n                        val = utils.trim(line.substr(i + 1));\n\n                        if (key) {\n                            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n                                return;\n                            }\n                            if (key === 'set-cookie') {\n                                parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n                            } else {\n                                parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n                            }\n                        }\n                    });\n\n                    return parsed;\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/parseProtocol.js\":\n/*!**************************************!*\\\n  !*** ./lib/helpers/parseProtocol.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                module.exports = function parseProtocol(url) {\n                    var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n                    return match && match[1] || '';\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/spread.js\":\n/*!*******************************!*\\\n  !*** ./lib/helpers/spread.js ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                /**\n                 * Syntactic sugar for invoking a function and expanding an array for arguments.\n                 *\n                 * Common use case would be to use `Function.prototype.apply`.\n                 *\n                 *  ```js\n                 *  function f(x, y, z) {}\n                 *  var args = [1, 2, 3];\n                 *  f.apply(null, args);\n                 *  ```\n                 *\n                 * With `spread` this example can be re-written.\n                 *\n                 *  ```js\n                 *  spread(function(x, y, z) {})([1, 2, 3]);\n                 *  ```\n                 *\n                 * @param {Function} callback\n                 * @returns {Function}\n                 */\n                module.exports = function spread(callback) {\n                    return function wrap(arr) {\n                        return callback.apply(null, arr);\n                    };\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/toFormData.js\":\n/*!***********************************!*\\\n  !*** ./lib/helpers/toFormData.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var utils = __webpack_require__(/*! ../utils */ \"./lib/utils.js\");\n\n                /**\n                 * Convert a data object to FormData\n                 * @param {Object} obj\n                 * @param {?Object} [formData]\n                 * @returns {Object}\n                 **/\n\n                function toFormData(obj, formData) {\n                    // eslint-disable-next-line no-param-reassign\n                    formData = formData || new FormData();\n\n                    var stack = [];\n\n                    function convertValue(value) {\n                        if (value === null) return '';\n\n                        if (utils.isDate(value)) {\n                            return value.toISOString();\n                        }\n\n                        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n                            return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n                        }\n\n                        return value;\n                    }\n\n                    function build(data, parentKey) {\n                        if (utils.isPlainObject(data) || utils.isArray(data)) {\n                            if (stack.indexOf(data) !== -1) {\n                                throw Error('Circular reference detected in ' + parentKey);\n                            }\n\n                            stack.push(data);\n\n                            utils.forEach(data, function each(value, key) {\n                                if (utils.isUndefined(value)) return;\n                                var fullKey = parentKey ? parentKey + '.' + key : key;\n                                var arr;\n\n                                if (value && !parentKey && typeof value === 'object') {\n                                    if (utils.endsWith(key, '{}')) {\n                                        // eslint-disable-next-line no-param-reassign\n                                        value = JSON.stringify(value);\n                                    } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {\n                                        // eslint-disable-next-line func-names\n                                        arr.forEach(function (el) {\n                                            !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));\n                                        });\n                                        return;\n                                    }\n                                }\n\n                                build(value, fullKey);\n                            });\n\n                            stack.pop();\n                        } else {\n                            formData.append(parentKey, convertValue(data));\n                        }\n                    }\n\n                    build(obj);\n\n                    return formData;\n                }\n\n                module.exports = toFormData;\n\n\n                /***/\n}),\n\n/***/ \"./lib/helpers/validator.js\":\n/*!**********************************!*\\\n  !*** ./lib/helpers/validator.js ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var VERSION = __webpack_require__(/*! ../env/data */ \"./lib/env/data.js\").version;\n                var AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./lib/core/AxiosError.js\");\n\n                var validators = {};\n\n                // eslint-disable-next-line func-names\n                ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {\n                    validators[type] = function validator(thing) {\n                        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n                    };\n                });\n\n                var deprecatedWarnings = {};\n\n                /**\n                 * Transitional option validator\n                 * @param {function|boolean?} validator - set to false if the transitional option has been removed\n                 * @param {string?} version - deprecated version / removed since version\n                 * @param {string?} message - some message with additional info\n                 * @returns {function}\n                 */\n                validators.transitional = function transitional(validator, version, message) {\n                    function formatMessage(opt, desc) {\n                        return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n                    }\n\n                    // eslint-disable-next-line func-names\n                    return function (value, opt, opts) {\n                        if (validator === false) {\n                            throw new AxiosError(\n                                formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n                                AxiosError.ERR_DEPRECATED\n                            );\n                        }\n\n                        if (version && !deprecatedWarnings[opt]) {\n                            deprecatedWarnings[opt] = true;\n                            // eslint-disable-next-line no-console\n                            console.warn(\n                                formatMessage(\n                                    opt,\n                                    ' has been deprecated since v' + version + ' and will be removed in the near future'\n                                )\n                            );\n                        }\n\n                        return validator ? validator(value, opt, opts) : true;\n                    };\n                };\n\n                /**\n                 * Assert object's properties type\n                 * @param {object} options\n                 * @param {object} schema\n                 * @param {boolean?} allowUnknown\n                 */\n\n                function assertOptions(options, schema, allowUnknown) {\n                    if (typeof options !== 'object') {\n                        throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n                    }\n                    var keys = Object.keys(options);\n                    var i = keys.length;\n                    while (i-- > 0) {\n                        var opt = keys[i];\n                        var validator = schema[opt];\n                        if (validator) {\n                            var value = options[opt];\n                            var result = value === undefined || validator(value, opt, options);\n                            if (result !== true) {\n                                throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n                            }\n                            continue;\n                        }\n                        if (allowUnknown !== true) {\n                            throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n                        }\n                    }\n                }\n\n                module.exports = {\n                    assertOptions: assertOptions,\n                    validators: validators\n                };\n\n\n                /***/\n}),\n\n/***/ \"./lib/utils.js\":\n/*!**********************!*\\\n  !*** ./lib/utils.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function (module, exports, __webpack_require__) {\n\n                \"use strict\";\n\n\n                var bind = __webpack_require__(/*! ./helpers/bind */ \"./lib/helpers/bind.js\");\n\n                // utils is a library of generic helper functions non-specific to axios\n\n                var toString = Object.prototype.toString;\n\n                // eslint-disable-next-line func-names\n                var kindOf = (function (cache) {\n                    // eslint-disable-next-line func-names\n                    return function (thing) {\n                        var str = toString.call(thing);\n                        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n                    };\n                })(Object.create(null));\n\n                function kindOfTest(type) {\n                    type = type.toLowerCase();\n                    return function isKindOf(thing) {\n                        return kindOf(thing) === type;\n                    };\n                }\n\n                /**\n                 * Determine if a value is an Array\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is an Array, otherwise false\n                 */\n                function isArray(val) {\n                    return Array.isArray(val);\n                }\n\n                /**\n                 * Determine if a value is undefined\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if the value is undefined, otherwise false\n                 */\n                function isUndefined(val) {\n                    return typeof val === 'undefined';\n                }\n\n                /**\n                 * Determine if a value is a Buffer\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Buffer, otherwise false\n                 */\n                function isBuffer(val) {\n                    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n                        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n                }\n\n                /**\n                 * Determine if a value is an ArrayBuffer\n                 *\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n                 */\n                var isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n                /**\n                 * Determine if a value is a view on an ArrayBuffer\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n                 */\n                function isArrayBufferView(val) {\n                    var result;\n                    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n                        result = ArrayBuffer.isView(val);\n                    } else {\n                        result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n                    }\n                    return result;\n                }\n\n                /**\n                 * Determine if a value is a String\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a String, otherwise false\n                 */\n                function isString(val) {\n                    return typeof val === 'string';\n                }\n\n                /**\n                 * Determine if a value is a Number\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Number, otherwise false\n                 */\n                function isNumber(val) {\n                    return typeof val === 'number';\n                }\n\n                /**\n                 * Determine if a value is an Object\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is an Object, otherwise false\n                 */\n                function isObject(val) {\n                    return val !== null && typeof val === 'object';\n                }\n\n                /**\n                 * Determine if a value is a plain Object\n                 *\n                 * @param {Object} val The value to test\n                 * @return {boolean} True if value is a plain Object, otherwise false\n                 */\n                function isPlainObject(val) {\n                    if (kindOf(val) !== 'object') {\n                        return false;\n                    }\n\n                    var prototype = Object.getPrototypeOf(val);\n                    return prototype === null || prototype === Object.prototype;\n                }\n\n                /**\n                 * Determine if a value is a Date\n                 *\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Date, otherwise false\n                 */\n                var isDate = kindOfTest('Date');\n\n                /**\n                 * Determine if a value is a File\n                 *\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a File, otherwise false\n                 */\n                var isFile = kindOfTest('File');\n\n                /**\n                 * Determine if a value is a Blob\n                 *\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Blob, otherwise false\n                 */\n                var isBlob = kindOfTest('Blob');\n\n                /**\n                 * Determine if a value is a FileList\n                 *\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a File, otherwise false\n                 */\n                var isFileList = kindOfTest('FileList');\n\n                /**\n                 * Determine if a value is a Function\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Function, otherwise false\n                 */\n                function isFunction(val) {\n                    return toString.call(val) === '[object Function]';\n                }\n\n                /**\n                 * Determine if a value is a Stream\n                 *\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a Stream, otherwise false\n                 */\n                function isStream(val) {\n                    return isObject(val) && isFunction(val.pipe);\n                }\n\n                /**\n                 * Determine if a value is a FormData\n                 *\n                 * @param {Object} thing The value to test\n                 * @returns {boolean} True if value is an FormData, otherwise false\n                 */\n                function isFormData(thing) {\n                    var pattern = '[object FormData]';\n                    return thing && (\n                        (typeof FormData === 'function' && thing instanceof FormData) ||\n                        toString.call(thing) === pattern ||\n                        (isFunction(thing.toString) && thing.toString() === pattern)\n                    );\n                }\n\n                /**\n                 * Determine if a value is a URLSearchParams object\n                 * @function\n                 * @param {Object} val The value to test\n                 * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n                 */\n                var isURLSearchParams = kindOfTest('URLSearchParams');\n\n                /**\n                 * Trim excess whitespace off the beginning and end of a string\n                 *\n                 * @param {String} str The String to trim\n                 * @returns {String} The String freed of excess whitespace\n                 */\n                function trim(str) {\n                    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n                }\n\n                /**\n                 * Determine if we're running in a standard browser environment\n                 *\n                 * This allows axios to run in a web worker, and react-native.\n                 * Both environments support XMLHttpRequest, but not fully standard globals.\n                 *\n                 * web workers:\n                 *  typeof window -> undefined\n                 *  typeof document -> undefined\n                 *\n                 * react-native:\n                 *  navigator.product -> 'ReactNative'\n                 * nativescript\n                 *  navigator.product -> 'NativeScript' or 'NS'\n                 */\n                function isStandardBrowserEnv() {\n                    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                        navigator.product === 'NativeScript' ||\n                        navigator.product === 'NS')) {\n                        return false;\n                    }\n                    return (\n                        typeof window !== 'undefined' &&\n                        typeof document !== 'undefined'\n                    );\n                }\n\n                /**\n                 * Iterate over an Array or an Object invoking a function for each item.\n                 *\n                 * If `obj` is an Array callback will be called passing\n                 * the value, index, and complete array for each item.\n                 *\n                 * If 'obj' is an Object callback will be called passing\n                 * the value, key, and complete object for each property.\n                 *\n                 * @param {Object|Array} obj The object to iterate\n                 * @param {Function} fn The callback to invoke for each item\n                 */\n                function forEach(obj, fn) {\n                    // Don't bother if no value provided\n                    if (obj === null || typeof obj === 'undefined') {\n                        return;\n                    }\n\n                    // Force an array if not already something iterable\n                    if (typeof obj !== 'object') {\n                        /*eslint no-param-reassign:0*/\n                        obj = [obj];\n                    }\n\n                    if (isArray(obj)) {\n                        // Iterate over array values\n                        for (var i = 0, l = obj.length; i < l; i++) {\n                            fn.call(null, obj[i], i, obj);\n                        }\n                    } else {\n                        // Iterate over object keys\n                        for (var key in obj) {\n                            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                                fn.call(null, obj[key], key, obj);\n                            }\n                        }\n                    }\n                }\n\n                /**\n                 * Accepts varargs expecting each argument to be an object, then\n                 * immutably merges the properties of each object and returns result.\n                 *\n                 * When multiple objects contain the same key the later object in\n                 * the arguments list will take precedence.\n                 *\n                 * Example:\n                 *\n                 * ```js\n                 * var result = merge({foo: 123}, {foo: 456});\n                 * console.log(result.foo); // outputs 456\n                 * ```\n                 *\n                 * @param {Object} obj1 Object to merge\n                 * @returns {Object} Result of all merge properties\n                 */\n                function merge(/* obj1, obj2, obj3, ... */) {\n                    var result = {};\n                    function assignValue(val, key) {\n                        if (isPlainObject(result[key]) && isPlainObject(val)) {\n                            result[key] = merge(result[key], val);\n                        } else if (isPlainObject(val)) {\n                            result[key] = merge({}, val);\n                        } else if (isArray(val)) {\n                            result[key] = val.slice();\n                        } else {\n                            result[key] = val;\n                        }\n                    }\n\n                    for (var i = 0, l = arguments.length; i < l; i++) {\n                        forEach(arguments[i], assignValue);\n                    }\n                    return result;\n                }\n\n                /**\n                 * Extends object a by mutably adding to it the properties of object b.\n                 *\n                 * @param {Object} a The object to be extended\n                 * @param {Object} b The object to copy properties from\n                 * @param {Object} thisArg The object to bind function to\n                 * @return {Object} The resulting value of object a\n                 */\n                function extend(a, b, thisArg) {\n                    forEach(b, function assignValue(val, key) {\n                        if (thisArg && typeof val === 'function') {\n                            a[key] = bind(val, thisArg);\n                        } else {\n                            a[key] = val;\n                        }\n                    });\n                    return a;\n                }\n\n                /**\n                 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n                 *\n                 * @param {string} content with BOM\n                 * @return {string} content value without BOM\n                 */\n                function stripBOM(content) {\n                    if (content.charCodeAt(0) === 0xFEFF) {\n                        content = content.slice(1);\n                    }\n                    return content;\n                }\n\n                /**\n                 * Inherit the prototype methods from one constructor into another\n                 * @param {function} constructor\n                 * @param {function} superConstructor\n                 * @param {object} [props]\n                 * @param {object} [descriptors]\n                 */\n\n                function inherits(constructor, superConstructor, props, descriptors) {\n                    constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n                    constructor.prototype.constructor = constructor;\n                    props && Object.assign(constructor.prototype, props);\n                }\n\n                /**\n                 * Resolve object with deep prototype chain to a flat object\n                 * @param {Object} sourceObj source object\n                 * @param {Object} [destObj]\n                 * @param {Function} [filter]\n                 * @returns {Object}\n                 */\n\n                function toFlatObject(sourceObj, destObj, filter) {\n                    var props;\n                    var i;\n                    var prop;\n                    var merged = {};\n\n                    destObj = destObj || {};\n\n                    do {\n                        props = Object.getOwnPropertyNames(sourceObj);\n                        i = props.length;\n                        while (i-- > 0) {\n                            prop = props[i];\n                            if (!merged[prop]) {\n                                destObj[prop] = sourceObj[prop];\n                                merged[prop] = true;\n                            }\n                        }\n                        sourceObj = Object.getPrototypeOf(sourceObj);\n                    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n                    return destObj;\n                }\n\n                /*\n                 * determines whether a string ends with the characters of a specified string\n                 * @param {String} str\n                 * @param {String} searchString\n                 * @param {Number} [position= 0]\n                 * @returns {boolean}\n                 */\n                function endsWith(str, searchString, position) {\n                    str = String(str);\n                    if (position === undefined || position > str.length) {\n                        position = str.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = str.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                }\n\n\n                /**\n                 * Returns new array from array like object\n                 * @param {*} [thing]\n                 * @returns {Array}\n                 */\n                function toArray(thing) {\n                    if (!thing) return null;\n                    var i = thing.length;\n                    if (isUndefined(i)) return null;\n                    var arr = new Array(i);\n                    while (i-- > 0) {\n                        arr[i] = thing[i];\n                    }\n                    return arr;\n                }\n\n                // eslint-disable-next-line func-names\n                var isTypedArray = (function (TypedArray) {\n                    // eslint-disable-next-line func-names\n                    return function (thing) {\n                        return TypedArray && thing instanceof TypedArray;\n                    };\n                })(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));\n\n                module.exports = {\n                    isArray: isArray,\n                    isArrayBuffer: isArrayBuffer,\n                    isBuffer: isBuffer,\n                    isFormData: isFormData,\n                    isArrayBufferView: isArrayBufferView,\n                    isString: isString,\n                    isNumber: isNumber,\n                    isObject: isObject,\n                    isPlainObject: isPlainObject,\n                    isUndefined: isUndefined,\n                    isDate: isDate,\n                    isFile: isFile,\n                    isBlob: isBlob,\n                    isFunction: isFunction,\n                    isStream: isStream,\n                    isURLSearchParams: isURLSearchParams,\n                    isStandardBrowserEnv: isStandardBrowserEnv,\n                    forEach: forEach,\n                    merge: merge,\n                    extend: extend,\n                    trim: trim,\n                    stripBOM: stripBOM,\n                    inherits: inherits,\n                    toFlatObject: toFlatObject,\n                    kindOf: kindOf,\n                    kindOfTest: kindOfTest,\n                    endsWith: endsWith,\n                    toArray: toArray,\n                    isTypedArray: isTypedArray,\n                    isFileList: isFileList\n                };\n\n\n                /***/\n})\n\n        /******/\n});\n});\n\n//Included:lib/002.vue-v2.6.14.part.js\n/*lib:vue@2.6.14 + modifications*/\n/*!\n * Vue.js v2.6.14\n * (c) 2014-2021 Evan You\n * Released under the MIT License.\n */\n(function (root, factory) {\n  const scope = (typeof window === 'object') ? window : undefined;\n  if(typeof scope === \"undefined\") return;\n  if(\"vue\" in scope) return scope.vue;\n  const output = factory();\n\tif(typeof module === 'object' && typeof module.exports === 'object')\n\t\tmodule.exports = output;\n\tif(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\tif(typeof exports === 'object')\n\t\texports[\"vue\"] = output;\n  scope[\"vue\"] = output;\n  scope[\"Vue\"] = output;\n})(this, function() {\n  \n    var emptyObject = Object.freeze({});\n  \n    // These helpers produce better VM code in JS engines due to their\n    // explicitness and function inlining.\n    function isUndef (v) {\n      return v === undefined || v === null\n    }\n  \n    function isDef (v) {\n      return v !== undefined && v !== null\n    }\n  \n    function isTrue (v) {\n      return v === true\n    }\n  \n    function isFalse (v) {\n      return v === false\n    }\n  \n    /**\n     * Check if value is primitive.\n     */\n    function isPrimitive (value) {\n      return (\n        typeof value === 'string' ||\n        typeof value === 'number' ||\n        // $flow-disable-line\n        typeof value === 'symbol' ||\n        typeof value === 'boolean'\n      )\n    }\n  \n    /**\n     * Quick object check - this is primarily used to tell\n     * Objects from primitive values when we know the value\n     * is a JSON-compliant type.\n     */\n    function isObject (obj) {\n      return obj !== null && typeof obj === 'object'\n    }\n  \n    /**\n     * Get the raw type string of a value, e.g., [object Object].\n     */\n    var _toString = Object.prototype.toString;\n  \n    function toRawType (value) {\n      return _toString.call(value).slice(8, -1)\n    }\n  \n    /**\n     * Strict object type check. Only returns true\n     * for plain JavaScript objects.\n     */\n    function isPlainObject (obj) {\n      return _toString.call(obj) === '[object Object]'\n    }\n  \n    function isRegExp (v) {\n      return _toString.call(v) === '[object RegExp]'\n    }\n  \n    /**\n     * Check if val is a valid array index.\n     */\n    function isValidArrayIndex (val) {\n      var n = parseFloat(String(val));\n      return n >= 0 && Math.floor(n) === n && isFinite(val)\n    }\n  \n    function isPromise (val) {\n      return (\n        isDef(val) &&\n        typeof val.then === 'function' &&\n        typeof val.catch === 'function'\n      )\n    }\n  \n    /**\n     * Convert a value to a string that is actually rendered.\n     */\n    function toString (val) {\n      return val == null\n        ? ''\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n          ? JSON.stringify(val, null, 2)\n          : String(val)\n    }\n  \n    /**\n     * Convert an input value to a number for persistence.\n     * If the conversion fails, return original string.\n     */\n    function toNumber (val) {\n      var n = parseFloat(val);\n      return isNaN(n) ? val : n\n    }\n  \n    /**\n     * Make a map and return a function for checking if a key\n     * is in that map.\n     */\n    function makeMap (\n      str,\n      expectsLowerCase\n    ) {\n      var map = Object.create(null);\n      var list = str.split(',');\n      for (var i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n      }\n      return expectsLowerCase\n        ? function (val) { return map[val.toLowerCase()]; }\n        : function (val) { return map[val]; }\n    }\n  \n    /**\n     * Check if a tag is a built-in tag.\n     */\n    var isBuiltInTag = makeMap('slot,component', true);\n  \n    /**\n     * Check if an attribute is a reserved attribute.\n     */\n    var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  \n    /**\n     * Remove an item from an array.\n     */\n    function remove (arr, item) {\n      if (arr.length) {\n        var index = arr.indexOf(item);\n        if (index > -1) {\n          return arr.splice(index, 1)\n        }\n      }\n    }\n  \n    /**\n     * Check whether an object has the property.\n     */\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    function hasOwn (obj, key) {\n      return hasOwnProperty.call(obj, key)\n    }\n  \n    /**\n     * Create a cached version of a pure function.\n     */\n    function cached (fn) {\n      var cache = Object.create(null);\n      return (function cachedFn (str) {\n        var hit = cache[str];\n        return hit || (cache[str] = fn(str))\n      })\n    }\n  \n    /**\n     * Camelize a hyphen-delimited string.\n     */\n    var camelizeRE = /-(\\w)/g;\n    var camelize = cached(function (str) {\n      return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n    });\n  \n    /**\n     * Capitalize a string.\n     */\n    var capitalize = cached(function (str) {\n      return str.charAt(0).toUpperCase() + str.slice(1)\n    });\n  \n    /**\n     * Hyphenate a camelCase string.\n     */\n    var hyphenateRE = /\\B([A-Z])/g;\n    var hyphenate = cached(function (str) {\n      return str.replace(hyphenateRE, '-$1').toLowerCase()\n    });\n  \n    /**\n     * Simple bind polyfill for environments that do not support it,\n     * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n     * since native bind is now performant enough in most browsers.\n     * But removing it would mean breaking code that was able to run in\n     * PhantomJS 1.x, so this must be kept for backward compatibility.\n     */\n  \n    /* istanbul ignore next */\n    function polyfillBind (fn, ctx) {\n      function boundFn (a) {\n        var l = arguments.length;\n        return l\n          ? l > 1\n            ? fn.apply(ctx, arguments)\n            : fn.call(ctx, a)\n          : fn.call(ctx)\n      }\n  \n      boundFn._length = fn.length;\n      return boundFn\n    }\n  \n    function nativeBind (fn, ctx) {\n      return fn.bind(ctx)\n    }\n  \n    var bind = Function.prototype.bind\n      ? nativeBind\n      : polyfillBind;\n  \n    /**\n     * Convert an Array-like object to a real Array.\n     */\n    function toArray (list, start) {\n      start = start || 0;\n      var i = list.length - start;\n      var ret = new Array(i);\n      while (i--) {\n        ret[i] = list[i + start];\n      }\n      return ret\n    }\n  \n    /**\n     * Mix properties into target object.\n     */\n    function extend (to, _from) {\n      for (var key in _from) {\n        to[key] = _from[key];\n      }\n      return to\n    }\n  \n    /**\n     * Merge an Array of Objects into a single Object.\n     */\n    function toObject (arr) {\n      var res = {};\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i]) {\n          extend(res, arr[i]);\n        }\n      }\n      return res\n    }\n  \n    /* eslint-disable no-unused-vars */\n  \n    /**\n     * Perform no operation.\n     * Stubbing args to make Flow happy without leaving useless transpiled code\n     * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n     */\n    function noop (a, b, c) {}\n  \n    /**\n     * Always return false.\n     */\n    var no = function (a, b, c) { return false; };\n  \n    /* eslint-enable no-unused-vars */\n  \n    /**\n     * Return the same value.\n     */\n    var identity = function (_) { return _; };\n  \n    /**\n     * Generate a string containing static keys from compiler modules.\n     */\n    function genStaticKeys (modules) {\n      return modules.reduce(function (keys, m) {\n        return keys.concat(m.staticKeys || [])\n      }, []).join(',')\n    }\n  \n    /**\n     * Check if two values are loosely equal - that is,\n     * if they are plain objects, do they have the same shape?\n     */\n    function looseEqual (a, b) {\n      if (a === b) { return true }\n      var isObjectA = isObject(a);\n      var isObjectB = isObject(b);\n      if (isObjectA && isObjectB) {\n        try {\n          var isArrayA = Array.isArray(a);\n          var isArrayB = Array.isArray(b);\n          if (isArrayA && isArrayB) {\n            return a.length === b.length && a.every(function (e, i) {\n              return looseEqual(e, b[i])\n            })\n          } else if (a instanceof Date && b instanceof Date) {\n            return a.getTime() === b.getTime()\n          } else if (!isArrayA && !isArrayB) {\n            var keysA = Object.keys(a);\n            var keysB = Object.keys(b);\n            return keysA.length === keysB.length && keysA.every(function (key) {\n              return looseEqual(a[key], b[key])\n            })\n          } else {\n            /* istanbul ignore next */\n            return false\n          }\n        } catch (e) {\n          /* istanbul ignore next */\n          return false\n        }\n      } else if (!isObjectA && !isObjectB) {\n        return String(a) === String(b)\n      } else {\n        return false\n      }\n    }\n  \n    /**\n     * Return the first index at which a loosely equal value can be\n     * found in the array (if value is a plain object, the array must\n     * contain an object of the same shape), or -1 if it is not present.\n     */\n    function looseIndexOf (arr, val) {\n      for (var i = 0; i < arr.length; i++) {\n        if (looseEqual(arr[i], val)) { return i }\n      }\n      return -1\n    }\n  \n    /**\n     * Ensure a function is called only once.\n     */\n    function once (fn) {\n      var called = false;\n      return function () {\n        if (!called) {\n          called = true;\n          fn.apply(this, arguments);\n        }\n      }\n    }\n  \n    var SSR_ATTR = 'data-server-rendered';\n  \n    var ASSET_TYPES = [\n      'component',\n      'directive',\n      'filter'\n    ];\n  \n    var LIFECYCLE_HOOKS = [\n      'beforeCreate',\n      'created',\n      'beforeMount',\n      'mounted',\n      'beforeUpdate',\n      'updated',\n      'beforeDestroy',\n      'destroyed',\n      'activated',\n      'deactivated',\n      'errorCaptured',\n      'serverPrefetch'\n    ];\n  \n    /*  */\n  \n  \n  \n    var config = ({\n      /**\n       * Option merge strategies (used in core/util/options)\n       */\n      // $flow-disable-line\n      optionMergeStrategies: Object.create(null),\n  \n      /**\n       * Whether to suppress warnings.\n       */\n      silent: false,\n  \n      /**\n       * Show production mode tip message on boot?\n       */\n      productionTip: \"development\" !== 'production',\n  \n      /**\n       * Whether to enable devtools\n       */\n      devtools: \"development\" !== 'production',\n  \n      /**\n       * Whether to record perf\n       */\n      performance: false,\n  \n      /**\n       * Error handler for watcher errors\n       */\n      errorHandler: null,\n  \n      /**\n       * Warn handler for watcher warns\n       */\n      warnHandler: null,\n  \n      /**\n       * Ignore certain custom elements\n       */\n      ignoredElements: [],\n  \n      /**\n       * Custom user key aliases for v-on\n       */\n      // $flow-disable-line\n      keyCodes: Object.create(null),\n  \n      /**\n       * Check if a tag is reserved so that it cannot be registered as a\n       * component. This is platform-dependent and may be overwritten.\n       */\n      isReservedTag: no,\n  \n      /**\n       * Check if an attribute is reserved so that it cannot be used as a component\n       * prop. This is platform-dependent and may be overwritten.\n       */\n      isReservedAttr: no,\n  \n      /**\n       * Check if a tag is an unknown element.\n       * Platform-dependent.\n       */\n      isUnknownElement: no,\n  \n      /**\n       * Get the namespace of an element\n       */\n      getTagNamespace: noop,\n  \n      /**\n       * Parse the real tag name for the specific platform.\n       */\n      parsePlatformTagName: identity,\n  \n      /**\n       * Check if an attribute must be bound using property, e.g. value\n       * Platform-dependent.\n       */\n      mustUseProp: no,\n  \n      /**\n       * Perform updates asynchronously. Intended to be used by Vue Test Utils\n       * This will significantly reduce performance if set to false.\n       */\n      async: true,\n  \n      /**\n       * Exposed for legacy reasons\n       */\n      _lifecycleHooks: LIFECYCLE_HOOKS\n    });\n  \n    /*  */\n  \n    /**\n     * unicode letters used for parsing html tags, component names and property paths.\n     * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n     * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n     */\n    var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  \n    /**\n     * Check if a string starts with $ or _\n     */\n    function isReserved (str) {\n      var c = (str + '').charCodeAt(0);\n      return c === 0x24 || c === 0x5F\n    }\n  \n    /**\n     * Define a property.\n     */\n    function def (obj, key, val, enumerable) {\n      Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n      });\n    }\n  \n    /**\n     * Parse simple path.\n     */\n    var bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\n    function parsePath (path) {\n      if (bailRE.test(path)) {\n        return\n      }\n      var segments = path.split('.');\n      return function (obj) {\n        for (var i = 0; i < segments.length; i++) {\n          if (!obj) { return }\n          obj = obj[segments[i]];\n        }\n        return obj\n      }\n    }\n  \n    /*  */\n  \n    // can we use __proto__?\n    var hasProto = '__proto__' in {};\n  \n    // Browser environment sniffing\n    var inBrowser = typeof window !== 'undefined';\n    var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n    var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n    var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n    var isIE = UA && /msie|trident/.test(UA);\n    var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n    var isEdge = UA && UA.indexOf('edge/') > 0;\n    var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n    var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n    var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n    var isPhantomJS = UA && /phantomjs/.test(UA);\n    var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n  \n    // Firefox has a \"watch\" function on Object.prototype...\n    var nativeWatch = ({}).watch;\n  \n    var supportsPassive = false;\n    if (inBrowser) {\n      try {\n        var opts = {};\n        Object.defineProperty(opts, 'passive', ({\n          get: function get () {\n            /* istanbul ignore next */\n            supportsPassive = true;\n          }\n        })); // https://github.com/facebook/flow/issues/285\n        window.addEventListener('test-passive', null, opts);\n      } catch (e) {}\n    }\n  \n    // this needs to be lazy-evaled because vue may be required before\n    // vue-server-renderer can set VUE_ENV\n    var _isServer;\n    var isServerRendering = function () {\n      if (_isServer === undefined) {\n        /* istanbul ignore if */\n        if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n          // detect presence of vue-server-renderer and avoid\n          // Webpack shimming the process\n          _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n        } else {\n          _isServer = false;\n        }\n      }\n      return _isServer\n    };\n  \n    // detect devtools\n    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  \n    /* istanbul ignore next */\n    function isNative (Ctor) {\n      return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n    }\n  \n    var hasSymbol =\n      typeof Symbol !== 'undefined' && isNative(Symbol) &&\n      typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n  \n    var _Set;\n    /* istanbul ignore if */ // $flow-disable-line\n    if (typeof Set !== 'undefined' && isNative(Set)) {\n      // use native Set when available.\n      _Set = Set;\n    } else {\n      // a non-standard Set polyfill that only works with primitive keys.\n      _Set = /*@__PURE__*/(function () {\n        function Set () {\n          this.set = Object.create(null);\n        }\n        Set.prototype.has = function has (key) {\n          return this.set[key] === true\n        };\n        Set.prototype.add = function add (key) {\n          this.set[key] = true;\n        };\n        Set.prototype.clear = function clear () {\n          this.set = Object.create(null);\n        };\n  \n        return Set;\n      }());\n    }\n  \n    /*  */\n  \n    var warn = noop;\n    var tip = noop;\n    var generateComponentTrace = (noop); // work around flow check\n    var formatComponentName = (noop);\n  \n    {\n      var hasConsole = typeof console !== 'undefined';\n      var classifyRE = /(?:^|[-_])(\\w)/g;\n      var classify = function (str) { return str\n        .replace(classifyRE, function (c) { return c.toUpperCase(); })\n        .replace(/[-_]/g, ''); };\n  \n      warn = function (msg, vm) {\n        var trace = vm ? generateComponentTrace(vm) : '';\n  \n        if (config.warnHandler) {\n          config.warnHandler.call(null, msg, vm, trace);\n        } else if (hasConsole && (!config.silent)) {\n          console.error((\"[Vue warn]: \" + msg + trace));\n        }\n      };\n  \n      tip = function (msg, vm) {\n        if (hasConsole && (!config.silent)) {\n          console.warn(\"[Vue tip]: \" + msg + (\n            vm ? generateComponentTrace(vm) : ''\n          ));\n        }\n      };\n  \n      formatComponentName = function (vm, includeFile) {\n        if (vm.$root === vm) {\n          return '<Root>'\n        }\n        var options = typeof vm === 'function' && vm.cid != null\n          ? vm.options\n          : vm._isVue\n            ? vm.$options || vm.constructor.options\n            : vm;\n        var name = options.name || options._componentTag;\n        var file = options.__file;\n        if (!name && file) {\n          var match = file.match(/([^/\\\\]+)\\.vue$/);\n          name = match && match[1];\n        }\n  \n        return (\n          (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n          (file && includeFile !== false ? (\" at \" + file) : '')\n        )\n      };\n  \n      var repeat = function (str, n) {\n        var res = '';\n        while (n) {\n          if (n % 2 === 1) { res += str; }\n          if (n > 1) { str += str; }\n          n >>= 1;\n        }\n        return res\n      };\n  \n      generateComponentTrace = function (vm) {\n        if (vm._isVue && vm.$parent) {\n          var tree = [];\n          var currentRecursiveSequence = 0;\n          while (vm) {\n            if (tree.length > 0) {\n              var last = tree[tree.length - 1];\n              if (last.constructor === vm.constructor) {\n                currentRecursiveSequence++;\n                vm = vm.$parent;\n                continue\n              } else if (currentRecursiveSequence > 0) {\n                tree[tree.length - 1] = [last, currentRecursiveSequence];\n                currentRecursiveSequence = 0;\n              }\n            }\n            tree.push(vm);\n            vm = vm.$parent;\n          }\n          return '\\n\\nfound in\\n\\n' + tree\n            .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n                ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n                : formatComponentName(vm))); })\n            .join('\\n')\n        } else {\n          return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n        }\n      };\n    }\n  \n    /*  */\n  \n    var uid = 0;\n  \n    /**\n     * A dep is an observable that can have multiple\n     * directives subscribing to it.\n     */\n    var Dep = function Dep () {\n      this.id = uid++;\n      this.subs = [];\n    };\n  \n    Dep.prototype.addSub = function addSub (sub) {\n      this.subs.push(sub);\n    };\n  \n    Dep.prototype.removeSub = function removeSub (sub) {\n      remove(this.subs, sub);\n    };\n  \n    Dep.prototype.depend = function depend () {\n      if (Dep.target) {\n        Dep.target.addDep(this);\n      }\n    };\n  \n    Dep.prototype.notify = function notify () {\n      // stabilize the subscriber list first\n      var subs = this.subs.slice();\n      if (!config.async) {\n        // subs aren't sorted in scheduler if not running async\n        // we need to sort them now to make sure they fire in correct\n        // order\n        subs.sort(function (a, b) { return a.id - b.id; });\n      }\n      for (var i = 0, l = subs.length; i < l; i++) {\n        subs[i].update();\n      }\n    };\n  \n    // The current target watcher being evaluated.\n    // This is globally unique because only one watcher\n    // can be evaluated at a time.\n    Dep.target = null;\n    var targetStack = [];\n  \n    function pushTarget (target) {\n      targetStack.push(target);\n      Dep.target = target;\n    }\n  \n    function popTarget () {\n      targetStack.pop();\n      Dep.target = targetStack[targetStack.length - 1];\n    }\n  \n    /*  */\n  \n    var VNode = function VNode (\n      tag,\n      data,\n      children,\n      text,\n      elm,\n      context,\n      componentOptions,\n      asyncFactory\n    ) {\n      this.tag = tag;\n      this.data = data;\n      this.children = children;\n      this.text = text;\n      this.elm = elm;\n      this.ns = undefined;\n      this.context = context;\n      this.fnContext = undefined;\n      this.fnOptions = undefined;\n      this.fnScopeId = undefined;\n      this.key = data && data.key;\n      this.componentOptions = componentOptions;\n      this.componentInstance = undefined;\n      this.parent = undefined;\n      this.raw = false;\n      this.isStatic = false;\n      this.isRootInsert = true;\n      this.isComment = false;\n      this.isCloned = false;\n      this.isOnce = false;\n      this.asyncFactory = asyncFactory;\n      this.asyncMeta = undefined;\n      this.isAsyncPlaceholder = false;\n    };\n  \n    var prototypeAccessors = { child: { configurable: true } };\n  \n    // DEPRECATED: alias for componentInstance for backwards compat.\n    /* istanbul ignore next */\n    prototypeAccessors.child.get = function () {\n      return this.componentInstance\n    };\n  \n    Object.defineProperties( VNode.prototype, prototypeAccessors );\n  \n    var createEmptyVNode = function (text) {\n      if ( text === void 0 ) text = '';\n  \n      var node = new VNode();\n      node.text = text;\n      node.isComment = true;\n      return node\n    };\n  \n    function createTextVNode (val) {\n      return new VNode(undefined, undefined, undefined, String(val))\n    }\n  \n    // optimized shallow clone\n    // used for static nodes and slot nodes because they may be reused across\n    // multiple renders, cloning them avoids errors when DOM manipulations rely\n    // on their elm reference.\n    function cloneVNode (vnode) {\n      var cloned = new VNode(\n        vnode.tag,\n        vnode.data,\n        // #7975\n        // clone children array to avoid mutating original in case of cloning\n        // a child.\n        vnode.children && vnode.children.slice(),\n        vnode.text,\n        vnode.elm,\n        vnode.context,\n        vnode.componentOptions,\n        vnode.asyncFactory\n      );\n      cloned.ns = vnode.ns;\n      cloned.isStatic = vnode.isStatic;\n      cloned.key = vnode.key;\n      cloned.isComment = vnode.isComment;\n      cloned.fnContext = vnode.fnContext;\n      cloned.fnOptions = vnode.fnOptions;\n      cloned.fnScopeId = vnode.fnScopeId;\n      cloned.asyncMeta = vnode.asyncMeta;\n      cloned.isCloned = true;\n      return cloned\n    }\n  \n    /*\n     * not type checking this file because flow doesn't play well with\n     * dynamically accessing methods on Array prototype\n     */\n  \n    var arrayProto = Array.prototype;\n    var arrayMethods = Object.create(arrayProto);\n  \n    var methodsToPatch = [\n      'push',\n      'pop',\n      'shift',\n      'unshift',\n      'splice',\n      'sort',\n      'reverse'\n    ];\n  \n    /**\n     * Intercept mutating methods and emit events\n     */\n    methodsToPatch.forEach(function (method) {\n      // cache original method\n      var original = arrayProto[method];\n      def(arrayMethods, method, function mutator () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n  \n        var result = original.apply(this, args);\n        var ob = this.__ob__;\n        var inserted;\n        switch (method) {\n          case 'push':\n          case 'unshift':\n            inserted = args;\n            break\n          case 'splice':\n            inserted = args.slice(2);\n            break\n        }\n        if (inserted) { ob.observeArray(inserted); }\n        // notify change\n        ob.dep.notify();\n        return result\n      });\n    });\n  \n    /*  */\n  \n    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  \n    /**\n     * In some cases we may want to disable observation inside a component's\n     * update computation.\n     */\n    var shouldObserve = true;\n  \n    function toggleObserving (value) {\n      shouldObserve = value;\n    }\n  \n    /**\n     * Observer class that is attached to each observed\n     * object. Once attached, the observer converts the target\n     * object's property keys into getter/setters that\n     * collect dependencies and dispatch updates.\n     */\n    var Observer = function Observer (value) {\n      this.value = value;\n      this.dep = new Dep();\n      this.vmCount = 0;\n      def(value, '__ob__', this);\n      if (Array.isArray(value)) {\n        if (hasProto) {\n          protoAugment(value, arrayMethods);\n        } else {\n          copyAugment(value, arrayMethods, arrayKeys);\n        }\n        this.observeArray(value);\n      } else {\n        this.walk(value);\n      }\n    };\n  \n    /**\n     * Walk through all properties and convert them into\n     * getter/setters. This method should only be called when\n     * value type is Object.\n     */\n    Observer.prototype.walk = function walk (obj) {\n      var keys = Object.keys(obj);\n      for (var i = 0; i < keys.length; i++) {\n        defineReactive$$1(obj, keys[i]);\n      }\n    };\n  \n    /**\n     * Observe a list of Array items.\n     */\n    Observer.prototype.observeArray = function observeArray (items) {\n      for (var i = 0, l = items.length; i < l; i++) {\n        observe(items[i]);\n      }\n    };\n  \n    // helpers\n  \n    /**\n     * Augment a target Object or Array by intercepting\n     * the prototype chain using __proto__\n     */\n    function protoAugment (target, src) {\n      /* eslint-disable no-proto */\n      target.__proto__ = src;\n      /* eslint-enable no-proto */\n    }\n  \n    /**\n     * Augment a target Object or Array by defining\n     * hidden properties.\n     */\n    /* istanbul ignore next */\n    function copyAugment (target, src, keys) {\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var key = keys[i];\n        def(target, key, src[key]);\n      }\n    }\n  \n    /**\n     * Attempt to create an observer instance for a value,\n     * returns the new observer if successfully observed,\n     * or the existing observer if the value already has one.\n     */\n    function observe (value, asRootData) {\n      if (!isObject(value) || value instanceof VNode) {\n        return\n      }\n      var ob;\n      if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n        ob = value.__ob__;\n      } else if (\n        shouldObserve &&\n        !isServerRendering() &&\n        (Array.isArray(value) || isPlainObject(value)) &&\n        Object.isExtensible(value) &&\n        !value._isVue\n      ) {\n        ob = new Observer(value);\n      }\n      if (asRootData && ob) {\n        ob.vmCount++;\n      }\n      return ob\n    }\n  \n    /**\n     * Define a reactive property on an Object.\n     */\n    function defineReactive$$1 (\n      obj,\n      key,\n      val,\n      customSetter,\n      shallow\n    ) {\n      var dep = new Dep();\n  \n      var property = Object.getOwnPropertyDescriptor(obj, key);\n      if (property && property.configurable === false) {\n        return\n      }\n  \n      // cater for pre-defined getter/setters\n      var getter = property && property.get;\n      var setter = property && property.set;\n      if ((!getter || setter) && arguments.length === 2) {\n        val = obj[key];\n      }\n  \n      var childOb = !shallow && observe(val);\n      Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter () {\n          var value = getter ? getter.call(obj) : val;\n          if (Dep.target) {\n            dep.depend();\n            if (childOb) {\n              childOb.dep.depend();\n              if (Array.isArray(value)) {\n                dependArray(value);\n              }\n            }\n          }\n          return value\n        },\n        set: function reactiveSetter (newVal) {\n          var value = getter ? getter.call(obj) : val;\n          /* eslint-disable no-self-compare */\n          if (newVal === value || (newVal !== newVal && value !== value)) {\n            return\n          }\n          /* eslint-enable no-self-compare */\n          if (customSetter) {\n            customSetter();\n          }\n          // #7981: for accessor properties without setter\n          if (getter && !setter) { return }\n          if (setter) {\n            setter.call(obj, newVal);\n          } else {\n            val = newVal;\n          }\n          childOb = !shallow && observe(newVal);\n          dep.notify();\n        }\n      });\n    }\n  \n    /**\n     * Set a property on an object. Adds the new property and\n     * triggers change notification if the property doesn't\n     * already exist.\n     */\n    function set (target, key, val) {\n      if (isUndef(target) || isPrimitive(target)\n      ) {\n        warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n      }\n      if (Array.isArray(target) && isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key);\n        target.splice(key, 1, val);\n        return val\n      }\n      if (key in target && !(key in Object.prototype)) {\n        target[key] = val;\n        return val\n      }\n      var ob = (target).__ob__;\n      if (target._isVue || (ob && ob.vmCount)) {\n        warn(\n          'Avoid adding reactive properties to a Vue instance or its root $data ' +\n          'at runtime - declare it upfront in the data option.'\n        );\n        return val\n      }\n      if (!ob) {\n        target[key] = val;\n        return val\n      }\n      defineReactive$$1(ob.value, key, val);\n      ob.dep.notify();\n      return val\n    }\n  \n    /**\n     * Delete a property and trigger change if necessary.\n     */\n    function del (target, key) {\n      if (isUndef(target) || isPrimitive(target)\n      ) {\n        warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n      }\n      if (Array.isArray(target) && isValidArrayIndex(key)) {\n        target.splice(key, 1);\n        return\n      }\n      var ob = (target).__ob__;\n      if (target._isVue || (ob && ob.vmCount)) {\n        warn(\n          'Avoid deleting properties on a Vue instance or its root $data ' +\n          '- just set it to null.'\n        );\n        return\n      }\n      if (!hasOwn(target, key)) {\n        return\n      }\n      delete target[key];\n      if (!ob) {\n        return\n      }\n      ob.dep.notify();\n    }\n  \n    /**\n     * Collect dependencies on array elements when the array is touched, since\n     * we cannot intercept array element access like property getters.\n     */\n    function dependArray (value) {\n      for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n        e = value[i];\n        e && e.__ob__ && e.__ob__.dep.depend();\n        if (Array.isArray(e)) {\n          dependArray(e);\n        }\n      }\n    }\n  \n    /*  */\n  \n    /**\n     * Option overwriting strategies are functions that handle\n     * how to merge a parent option value and a child option\n     * value into the final value.\n     */\n    var strats = config.optionMergeStrategies;\n  \n    /**\n     * Options with restrictions\n     */\n    {\n      strats.el = strats.propsData = function (parent, child, vm, key) {\n        if (!vm) {\n          warn(\n            \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n            'creation with the `new` keyword.'\n          );\n        }\n        return defaultStrat(parent, child)\n      };\n    }\n  \n    /**\n     * Helper that recursively merges two data objects together.\n     */\n    function mergeData (to, from) {\n      if (!from) { return to }\n      var key, toVal, fromVal;\n  \n      var keys = hasSymbol\n        ? Reflect.ownKeys(from)\n        : Object.keys(from);\n  \n      for (var i = 0; i < keys.length; i++) {\n        key = keys[i];\n        // in case the object is already observed...\n        if (key === '__ob__') { continue }\n        toVal = to[key];\n        fromVal = from[key];\n        if (!hasOwn(to, key)) {\n          set(to, key, fromVal);\n        } else if (\n          toVal !== fromVal &&\n          isPlainObject(toVal) &&\n          isPlainObject(fromVal)\n        ) {\n          mergeData(toVal, fromVal);\n        }\n      }\n      return to\n    }\n  \n    /**\n     * Data\n     */\n    function mergeDataOrFn (\n      parentVal,\n      childVal,\n      vm\n    ) {\n      if (!vm) {\n        // in a Vue.extend merge, both should be functions\n        if (!childVal) {\n          return parentVal\n        }\n        if (!parentVal) {\n          return childVal\n        }\n        // when parentVal & childVal are both present,\n        // we need to return a function that returns the\n        // merged result of both functions... no need to\n        // check if parentVal is a function here because\n        // it has to be a function to pass previous merges.\n        return function mergedDataFn () {\n          return mergeData(\n            typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n            typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n          )\n        }\n      } else {\n        return function mergedInstanceDataFn () {\n          // instance merge\n          var instanceData = typeof childVal === 'function'\n            ? childVal.call(vm, vm)\n            : childVal;\n          var defaultData = typeof parentVal === 'function'\n            ? parentVal.call(vm, vm)\n            : parentVal;\n          if (instanceData) {\n            return mergeData(instanceData, defaultData)\n          } else {\n            return defaultData\n          }\n        }\n      }\n    }\n  \n    strats.data = function (\n      parentVal,\n      childVal,\n      vm\n    ) {\n      if (!vm) {\n        if (childVal && typeof childVal !== 'function') {\n          warn(\n            'The \"data\" option should be a function ' +\n            'that returns a per-instance value in component ' +\n            'definitions.',\n            vm\n          );\n  \n          return parentVal\n        }\n        return mergeDataOrFn(parentVal, childVal)\n      }\n  \n      return mergeDataOrFn(parentVal, childVal, vm)\n    };\n  \n    /**\n     * Hooks and props are merged as arrays.\n     */\n    function mergeHook (\n      parentVal,\n      childVal\n    ) {\n      var res = childVal\n        ? parentVal\n          ? parentVal.concat(childVal)\n          : Array.isArray(childVal)\n            ? childVal\n            : [childVal]\n        : parentVal;\n      return res\n        ? dedupeHooks(res)\n        : res\n    }\n  \n    function dedupeHooks (hooks) {\n      var res = [];\n      for (var i = 0; i < hooks.length; i++) {\n        if (res.indexOf(hooks[i]) === -1) {\n          res.push(hooks[i]);\n        }\n      }\n      return res\n    }\n  \n    LIFECYCLE_HOOKS.forEach(function (hook) {\n      strats[hook] = mergeHook;\n    });\n  \n    /**\n     * Assets\n     *\n     * When a vm is present (instance creation), we need to do\n     * a three-way merge between constructor options, instance\n     * options and parent options.\n     */\n    function mergeAssets (\n      parentVal,\n      childVal,\n      vm,\n      key\n    ) {\n      var res = Object.create(parentVal || null);\n      if (childVal) {\n        assertObjectType(key, childVal, vm);\n        return extend(res, childVal)\n      } else {\n        return res\n      }\n    }\n  \n    ASSET_TYPES.forEach(function (type) {\n      strats[type + 's'] = mergeAssets;\n    });\n  \n    /**\n     * Watchers.\n     *\n     * Watchers hashes should not overwrite one\n     * another, so we merge them as arrays.\n     */\n    strats.watch = function (\n      parentVal,\n      childVal,\n      vm,\n      key\n    ) {\n      // work around Firefox's Object.prototype.watch...\n      if (parentVal === nativeWatch) { parentVal = undefined; }\n      if (childVal === nativeWatch) { childVal = undefined; }\n      /* istanbul ignore if */\n      if (!childVal) { return Object.create(parentVal || null) }\n      {\n        assertObjectType(key, childVal, vm);\n      }\n      if (!parentVal) { return childVal }\n      var ret = {};\n      extend(ret, parentVal);\n      for (var key$1 in childVal) {\n        var parent = ret[key$1];\n        var child = childVal[key$1];\n        if (parent && !Array.isArray(parent)) {\n          parent = [parent];\n        }\n        ret[key$1] = parent\n          ? parent.concat(child)\n          : Array.isArray(child) ? child : [child];\n      }\n      return ret\n    };\n  \n    /**\n     * Other object hashes.\n     */\n    strats.props =\n    strats.methods =\n    strats.inject =\n    strats.computed = function (\n      parentVal,\n      childVal,\n      vm,\n      key\n    ) {\n      if (childVal && \"development\" !== 'production') {\n        assertObjectType(key, childVal, vm);\n      }\n      if (!parentVal) { return childVal }\n      var ret = Object.create(null);\n      extend(ret, parentVal);\n      if (childVal) { extend(ret, childVal); }\n      return ret\n    };\n    strats.provide = mergeDataOrFn;\n  \n    /**\n     * Default strategy.\n     */\n    var defaultStrat = function (parentVal, childVal) {\n      return childVal === undefined\n        ? parentVal\n        : childVal\n    };\n  \n    /**\n     * Validate component names\n     */\n    function checkComponents (options) {\n      for (var key in options.components) {\n        validateComponentName(key);\n      }\n    }\n  \n    function validateComponentName (name) {\n      if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'should conform to valid custom element name in html5 specification.'\n        );\n      }\n      if (isBuiltInTag(name) || config.isReservedTag(name)) {\n        warn(\n          'Do not use built-in or reserved HTML elements as component ' +\n          'id: ' + name\n        );\n      }\n    }\n  \n    /**\n     * Ensure all props option syntax are normalized into the\n     * Object-based format.\n     */\n    function normalizeProps (options, vm) {\n      var props = options.props;\n      if (!props) { return }\n      var res = {};\n      var i, val, name;\n      if (Array.isArray(props)) {\n        i = props.length;\n        while (i--) {\n          val = props[i];\n          if (typeof val === 'string') {\n            name = camelize(val);\n            res[name] = { type: null };\n          } else {\n            warn('props must be strings when using array syntax.');\n          }\n        }\n      } else if (isPlainObject(props)) {\n        for (var key in props) {\n          val = props[key];\n          name = camelize(key);\n          res[name] = isPlainObject(val)\n            ? val\n            : { type: val };\n        }\n      } else {\n        warn(\n          \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n          \"but got \" + (toRawType(props)) + \".\",\n          vm\n        );\n      }\n      options.props = res;\n    }\n  \n    /**\n     * Normalize all injections into Object-based format\n     */\n    function normalizeInject (options, vm) {\n      var inject = options.inject;\n      if (!inject) { return }\n      var normalized = options.inject = {};\n      if (Array.isArray(inject)) {\n        for (var i = 0; i < inject.length; i++) {\n          normalized[inject[i]] = { from: inject[i] };\n        }\n      } else if (isPlainObject(inject)) {\n        for (var key in inject) {\n          var val = inject[key];\n          normalized[key] = isPlainObject(val)\n            ? extend({ from: key }, val)\n            : { from: val };\n        }\n      } else {\n        warn(\n          \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n          \"but got \" + (toRawType(inject)) + \".\",\n          vm\n        );\n      }\n    }\n  \n    /**\n     * Normalize raw function directives into object format.\n     */\n    function normalizeDirectives (options) {\n      var dirs = options.directives;\n      if (dirs) {\n        for (var key in dirs) {\n          var def$$1 = dirs[key];\n          if (typeof def$$1 === 'function') {\n            dirs[key] = { bind: def$$1, update: def$$1 };\n          }\n        }\n      }\n    }\n  \n    function assertObjectType (name, value, vm) {\n      if (!isPlainObject(value)) {\n        warn(\n          \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n          \"but got \" + (toRawType(value)) + \".\",\n          vm\n        );\n      }\n    }\n  \n    /**\n     * Merge two option objects into a new one.\n     * Core utility used in both instantiation and inheritance.\n     */\n    function mergeOptions (\n      parent,\n      child,\n      vm\n    ) {\n      {\n        checkComponents(child);\n      }\n  \n      if (typeof child === 'function') {\n        child = child.options;\n      }\n  \n      normalizeProps(child, vm);\n      normalizeInject(child, vm);\n      normalizeDirectives(child);\n  \n      // Apply extends and mixins on the child options,\n      // but only if it is a raw options object that isn't\n      // the result of another mergeOptions call.\n      // Only merged options has the _base property.\n      if (!child._base) {\n        if (child.extends) {\n          parent = mergeOptions(parent, child.extends, vm);\n        }\n        if (child.mixins) {\n          for (var i = 0, l = child.mixins.length; i < l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm);\n          }\n        }\n      }\n  \n      var options = {};\n      var key;\n      for (key in parent) {\n        mergeField(key);\n      }\n      for (key in child) {\n        if (!hasOwn(parent, key)) {\n          mergeField(key);\n        }\n      }\n      function mergeField (key) {\n        var strat = strats[key] || defaultStrat;\n        options[key] = strat(parent[key], child[key], vm, key);\n      }\n      return options\n    }\n  \n    /**\n     * Resolve an asset.\n     * This function is used because child instances need access\n     * to assets defined in its ancestor chain.\n     */\n    function resolveAsset (\n      options,\n      type,\n      id,\n      warnMissing\n    ) {\n      /* istanbul ignore if */\n      if (typeof id !== 'string') {\n        return\n      }\n      var assets = options[type];\n      // check local registration variations first\n      if (hasOwn(assets, id)) { return assets[id] }\n      var camelizedId = camelize(id);\n      if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n      var PascalCaseId = capitalize(camelizedId);\n      if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n      // fallback to prototype chain\n      var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n      if (warnMissing && !res) {\n        warn(\n          'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n          options\n        );\n      }\n      return res\n    }\n  \n    /*  */\n  \n  \n  \n    function validateProp (\n      key,\n      propOptions,\n      propsData,\n      vm\n    ) {\n      var prop = propOptions[key];\n      var absent = !hasOwn(propsData, key);\n      var value = propsData[key];\n      // boolean casting\n      var booleanIndex = getTypeIndex(Boolean, prop.type);\n      if (booleanIndex > -1) {\n        if (absent && !hasOwn(prop, 'default')) {\n          value = false;\n        } else if (value === '' || value === hyphenate(key)) {\n          // only cast empty string / same name to boolean if\n          // boolean has higher priority\n          var stringIndex = getTypeIndex(String, prop.type);\n          if (stringIndex < 0 || booleanIndex < stringIndex) {\n            value = true;\n          }\n        }\n      }\n      // check default value\n      if (value === undefined) {\n        value = getPropDefaultValue(vm, prop, key);\n        // since the default value is a fresh copy,\n        // make sure to observe it.\n        var prevShouldObserve = shouldObserve;\n        toggleObserving(true);\n        observe(value);\n        toggleObserving(prevShouldObserve);\n      }\n      {\n        assertProp(prop, key, value, vm, absent);\n      }\n      return value\n    }\n  \n    /**\n     * Get the default value of a prop.\n     */\n    function getPropDefaultValue (vm, prop, key) {\n      // no default, return undefined\n      if (!hasOwn(prop, 'default')) {\n        return undefined\n      }\n      var def = prop.default;\n      // warn against non-factory defaults for Object & Array\n      if (isObject(def)) {\n        warn(\n          'Invalid default value for prop \"' + key + '\": ' +\n          'Props with type Object/Array must use a factory function ' +\n          'to return the default value.',\n          vm\n        );\n      }\n      // the raw prop value was also undefined from previous render,\n      // return previous default value to avoid unnecessary watcher trigger\n      if (vm && vm.$options.propsData &&\n        vm.$options.propsData[key] === undefined &&\n        vm._props[key] !== undefined\n      ) {\n        return vm._props[key]\n      }\n      // call factory function for non-Function types\n      // a value is Function if its prototype is function even across different execution context\n      return typeof def === 'function' && getType(prop.type) !== 'Function'\n        ? def.call(vm)\n        : def\n    }\n  \n    /**\n     * Assert whether a prop is valid.\n     */\n    function assertProp (\n      prop,\n      name,\n      value,\n      vm,\n      absent\n    ) {\n      if (prop.required && absent) {\n        warn(\n          'Missing required prop: \"' + name + '\"',\n          vm\n        );\n        return\n      }\n      if (value == null && !prop.required) {\n        return\n      }\n      var type = prop.type;\n      var valid = !type || type === true;\n      var expectedTypes = [];\n      if (type) {\n        if (!Array.isArray(type)) {\n          type = [type];\n        }\n        for (var i = 0; i < type.length && !valid; i++) {\n          var assertedType = assertType(value, type[i], vm);\n          expectedTypes.push(assertedType.expectedType || '');\n          valid = assertedType.valid;\n        }\n      }\n  \n      var haveExpectedTypes = expectedTypes.some(function (t) { return t; });\n      if (!valid && haveExpectedTypes) {\n        warn(\n          getInvalidTypeMessage(name, value, expectedTypes),\n          vm\n        );\n        return\n      }\n      var validator = prop.validator;\n      if (validator) {\n        if (!validator(value)) {\n          warn(\n            'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n            vm\n          );\n        }\n      }\n    }\n  \n    var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\n  \n    function assertType (value, type, vm) {\n      var valid;\n      var expectedType = getType(type);\n      if (simpleCheckRE.test(expectedType)) {\n        var t = typeof value;\n        valid = t === expectedType.toLowerCase();\n        // for primitive wrapper objects\n        if (!valid && t === 'object') {\n          valid = value instanceof type;\n        }\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value);\n      } else if (expectedType === 'Array') {\n        valid = Array.isArray(value);\n      } else {\n        try {\n          valid = value instanceof type;\n        } catch (e) {\n          warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n          valid = false;\n        }\n      }\n      return {\n        valid: valid,\n        expectedType: expectedType\n      }\n    }\n  \n    var functionTypeCheckRE = /^\\s*function (\\w+)/;\n  \n    /**\n     * Use function string name to check built-in types,\n     * because a simple equality check will fail when running\n     * across different vms / iframes.\n     */\n    function getType (fn) {\n      var match = fn && fn.toString().match(functionTypeCheckRE);\n      return match ? match[1] : ''\n    }\n  \n    function isSameType (a, b) {\n      return getType(a) === getType(b)\n    }\n  \n    function getTypeIndex (type, expectedTypes) {\n      if (!Array.isArray(expectedTypes)) {\n        return isSameType(expectedTypes, type) ? 0 : -1\n      }\n      for (var i = 0, len = expectedTypes.length; i < len; i++) {\n        if (isSameType(expectedTypes[i], type)) {\n          return i\n        }\n      }\n      return -1\n    }\n  \n    function getInvalidTypeMessage (name, value, expectedTypes) {\n      var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n        \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n      var expectedType = expectedTypes[0];\n      var receivedType = toRawType(value);\n      // check if we need to specify expected value\n      if (\n        expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        isExplicable(typeof value) &&\n        !isBoolean(expectedType, receivedType)\n      ) {\n        message += \" with value \" + (styleValue(value, expectedType));\n      }\n      message += \", got \" + receivedType + \" \";\n      // check if we need to specify received value\n      if (isExplicable(receivedType)) {\n        message += \"with value \" + (styleValue(value, receivedType)) + \".\";\n      }\n      return message\n    }\n  \n    function styleValue (value, type) {\n      if (type === 'String') {\n        return (\"\\\"\" + value + \"\\\"\")\n      } else if (type === 'Number') {\n        return (\"\" + (Number(value)))\n      } else {\n        return (\"\" + value)\n      }\n    }\n  \n    var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\n    function isExplicable (value) {\n      return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })\n    }\n  \n    function isBoolean () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n  \n      return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n    }\n  \n    /*  */\n  \n    function handleError (err, vm, info) {\n      // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n      // See: https://github.com/vuejs/vuex/issues/1505\n      pushTarget();\n      try {\n        if (vm) {\n          var cur = vm;\n          while ((cur = cur.$parent)) {\n            var hooks = cur.$options.errorCaptured;\n            if (hooks) {\n              for (var i = 0; i < hooks.length; i++) {\n                try {\n                  var capture = hooks[i].call(cur, err, vm, info) === false;\n                  if (capture) { return }\n                } catch (e) {\n                  globalHandleError(e, cur, 'errorCaptured hook');\n                }\n              }\n            }\n          }\n        }\n        globalHandleError(err, vm, info);\n      } finally {\n        popTarget();\n      }\n    }\n  \n    function invokeWithErrorHandling (\n      handler,\n      context,\n      args,\n      vm,\n      info\n    ) {\n      var res;\n      try {\n        res = args ? handler.apply(context, args) : handler.call(context);\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\n          res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n          // issue #9511\n          // avoid catch triggering multiple times when nested calls\n          res._handled = true;\n        }\n      } catch (e) {\n        handleError(e, vm, info);\n      }\n      return res\n    }\n  \n    function globalHandleError (err, vm, info) {\n      if (config.errorHandler) {\n        try {\n          return config.errorHandler.call(null, err, vm, info)\n        } catch (e) {\n          // if the user intentionally throws the original error in the handler,\n          // do not log it twice\n          if (e !== err) {\n            logError(e, null, 'config.errorHandler');\n          }\n        }\n      }\n      logError(err, vm, info);\n    }\n  \n    function logError (err, vm, info) {\n      {\n        warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n      }\n      /* istanbul ignore else */\n      if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n        console.error(err);\n      } else {\n        throw err\n      }\n    }\n  \n    /*  */\n  \n    var isUsingMicroTask = false;\n  \n    var callbacks = [];\n    var pending = false;\n  \n    function flushCallbacks () {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks.length = 0;\n      for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n      }\n    }\n  \n    // Here we have async deferring wrappers using microtasks.\n    // In 2.5 we used (macro) tasks (in combination with microtasks).\n    // However, it has subtle problems when state is changed right before repaint\n    // (e.g. #6813, out-in transitions).\n    // Also, using (macro) tasks in event handler would cause some weird behaviors\n    // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n    // So we now use microtasks everywhere, again.\n    // A major drawback of this tradeoff is that there are some scenarios\n    // where microtasks have too high a priority and fire in between supposedly\n    // sequential events (e.g. #4521, #6690, which have workarounds)\n    // or even between bubbling of the same event (#6566).\n    var timerFunc;\n  \n    // The nextTick behavior leverages the microtask queue, which can be accessed\n    // via either native Promise.then or MutationObserver.\n    // MutationObserver has wider support, however it is seriously bugged in\n    // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n    // completely stops working after triggering a few times... so, if native\n    // Promise is available, we will use it:\n    /* istanbul ignore next, $flow-disable-line */\n    if (typeof Promise !== 'undefined' && isNative(Promise)) {\n      var p = Promise.resolve();\n      timerFunc = function () {\n        p.then(flushCallbacks);\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\n        // it can get stuck in a weird state where callbacks are pushed into the\n        // microtask queue but the queue isn't being flushed, until the browser\n        // needs to do some other work, e.g. handle a timer. Therefore we can\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\n        if (isIOS) { setTimeout(noop); }\n      };\n      isUsingMicroTask = true;\n    } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n      isNative(MutationObserver) ||\n      // PhantomJS and iOS 7.x\n      MutationObserver.toString() === '[object MutationObserverConstructor]'\n    )) {\n      // Use MutationObserver where native Promise is not available,\n      // e.g. PhantomJS, iOS7, Android 4.4\n      // (#6466 MutationObserver is unreliable in IE11)\n      var counter = 1;\n      var observer = new MutationObserver(flushCallbacks);\n      var textNode = document.createTextNode(String(counter));\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function () {\n        counter = (counter + 1) % 2;\n        textNode.data = String(counter);\n      };\n      isUsingMicroTask = true;\n    } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n      // Fallback to setImmediate.\n      // Technically it leverages the (macro) task queue,\n      // but it is still a better choice than setTimeout.\n      timerFunc = function () {\n        setImmediate(flushCallbacks);\n      };\n    } else {\n      // Fallback to setTimeout.\n      timerFunc = function () {\n        setTimeout(flushCallbacks, 0);\n      };\n    }\n  \n    function nextTick (cb, ctx) {\n      var _resolve;\n      callbacks.push(function () {\n        if (cb) {\n          try {\n            cb.call(ctx);\n          } catch (e) {\n            handleError(e, ctx, 'nextTick');\n          }\n        } else if (_resolve) {\n          _resolve(ctx);\n        }\n      });\n      if (!pending) {\n        pending = true;\n        timerFunc();\n      }\n      // $flow-disable-line\n      if (!cb && typeof Promise !== 'undefined') {\n        return new Promise(function (resolve) {\n          _resolve = resolve;\n        })\n      }\n    }\n  \n    /*  */\n  \n    var mark;\n    var measure;\n  \n    {\n      var perf = inBrowser && window.performance;\n      /* istanbul ignore if */\n      if (\n        perf &&\n        perf.mark &&\n        perf.measure &&\n        perf.clearMarks &&\n        perf.clearMeasures\n      ) {\n        mark = function (tag) { return perf.mark(tag); };\n        measure = function (name, startTag, endTag) {\n          perf.measure(name, startTag, endTag);\n          perf.clearMarks(startTag);\n          perf.clearMarks(endTag);\n          // perf.clearMeasures(name)\n        };\n      }\n    }\n  \n    /* not type checking this file because flow doesn't play well with Proxy */\n  \n    var initProxy;\n  \n    {\n      var allowedGlobals = makeMap(\n        'Infinity,undefined,NaN,isFinite,isNaN,' +\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\n        'require' // for Webpack/Browserify\n      );\n  \n      var warnNonPresent = function (target, key) {\n        warn(\n          \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n          'referenced during render. Make sure that this property is reactive, ' +\n          'either in the data option, or for class-based components, by ' +\n          'initializing the property. ' +\n          'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n          target\n        );\n      };\n  \n      var warnReservedPrefix = function (target, key) {\n        warn(\n          \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n          'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n          'prevent conflicts with Vue internals. ' +\n          'See: https://vuejs.org/v2/api/#data',\n          target\n        );\n      };\n  \n      var hasProxy =\n        typeof Proxy !== 'undefined' && isNative(Proxy);\n  \n      if (hasProxy) {\n        var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n        config.keyCodes = new Proxy(config.keyCodes, {\n          set: function set (target, key, value) {\n            if (isBuiltInModifier(key)) {\n              warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n              return false\n            } else {\n              target[key] = value;\n              return true\n            }\n          }\n        });\n      }\n  \n      var hasHandler = {\n        has: function has (target, key) {\n          var has = key in target;\n          var isAllowed = allowedGlobals(key) ||\n            (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n          if (!has && !isAllowed) {\n            if (key in target.$data) { warnReservedPrefix(target, key); }\n            else { warnNonPresent(target, key); }\n          }\n          return has || !isAllowed\n        }\n      };\n  \n      var getHandler = {\n        get: function get (target, key) {\n          if (typeof key === 'string' && !(key in target)) {\n            if (key in target.$data) { warnReservedPrefix(target, key); }\n            else { warnNonPresent(target, key); }\n          }\n          return target[key]\n        }\n      };\n  \n      initProxy = function initProxy (vm) {\n        if (hasProxy) {\n          // determine which proxy handler to use\n          var options = vm.$options;\n          var handlers = options.render && options.render._withStripped\n            ? getHandler\n            : hasHandler;\n          vm._renderProxy = new Proxy(vm, handlers);\n        } else {\n          vm._renderProxy = vm;\n        }\n      };\n    }\n  \n    /*  */\n  \n    var seenObjects = new _Set();\n  \n    /**\n     * Recursively traverse an object to evoke all converted\n     * getters, so that every nested property inside the object\n     * is collected as a \"deep\" dependency.\n     */\n    function traverse (val) {\n      _traverse(val, seenObjects);\n      seenObjects.clear();\n    }\n  \n    function _traverse (val, seen) {\n      var i, keys;\n      var isA = Array.isArray(val);\n      if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n        return\n      }\n      if (val.__ob__) {\n        var depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n          return\n        }\n        seen.add(depId);\n      }\n      if (isA) {\n        i = val.length;\n        while (i--) { _traverse(val[i], seen); }\n      } else {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--) { _traverse(val[keys[i]], seen); }\n      }\n    }\n  \n    /*  */\n  \n    var normalizeEvent = cached(function (name) {\n      var passive = name.charAt(0) === '&';\n      name = passive ? name.slice(1) : name;\n      var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n      name = once$$1 ? name.slice(1) : name;\n      var capture = name.charAt(0) === '!';\n      name = capture ? name.slice(1) : name;\n      return {\n        name: name,\n        once: once$$1,\n        capture: capture,\n        passive: passive\n      }\n    });\n  \n    function createFnInvoker (fns, vm) {\n      function invoker () {\n        var arguments$1 = arguments;\n  \n        var fns = invoker.fns;\n        if (Array.isArray(fns)) {\n          var cloned = fns.slice();\n          for (var i = 0; i < cloned.length; i++) {\n            invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n          }\n        } else {\n          // return handler return value for single handlers\n          return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n        }\n      }\n      invoker.fns = fns;\n      return invoker\n    }\n  \n    function updateListeners (\n      on,\n      oldOn,\n      add,\n      remove$$1,\n      createOnceHandler,\n      vm\n    ) {\n      var name, def$$1, cur, old, event;\n      for (name in on) {\n        def$$1 = cur = on[name];\n        old = oldOn[name];\n        event = normalizeEvent(name);\n        if (isUndef(cur)) {\n          warn(\n            \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n            vm\n          );\n        } else if (isUndef(old)) {\n          if (isUndef(cur.fns)) {\n            cur = on[name] = createFnInvoker(cur, vm);\n          }\n          if (isTrue(event.once)) {\n            cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n          }\n          add(event.name, cur, event.capture, event.passive, event.params);\n        } else if (cur !== old) {\n          old.fns = cur;\n          on[name] = old;\n        }\n      }\n      for (name in oldOn) {\n        if (isUndef(on[name])) {\n          event = normalizeEvent(name);\n          remove$$1(event.name, oldOn[name], event.capture);\n        }\n      }\n    }\n  \n    /*  */\n  \n    function mergeVNodeHook (def, hookKey, hook) {\n      if (def instanceof VNode) {\n        def = def.data.hook || (def.data.hook = {});\n      }\n      var invoker;\n      var oldHook = def[hookKey];\n  \n      function wrappedHook () {\n        hook.apply(this, arguments);\n        // important: remove merged hook to ensure it's called only once\n        // and prevent memory leak\n        remove(invoker.fns, wrappedHook);\n      }\n  \n      if (isUndef(oldHook)) {\n        // no existing hook\n        invoker = createFnInvoker([wrappedHook]);\n      } else {\n        /* istanbul ignore if */\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n          // already a merged invoker\n          invoker = oldHook;\n          invoker.fns.push(wrappedHook);\n        } else {\n          // existing plain hook\n          invoker = createFnInvoker([oldHook, wrappedHook]);\n        }\n      }\n  \n      invoker.merged = true;\n      def[hookKey] = invoker;\n    }\n  \n    /*  */\n  \n    function extractPropsFromVNodeData (\n      data,\n      Ctor,\n      tag\n    ) {\n      // we are only extracting raw values here.\n      // validation and default values are handled in the child\n      // component itself.\n      var propOptions = Ctor.options.props;\n      if (isUndef(propOptions)) {\n        return\n      }\n      var res = {};\n      var attrs = data.attrs;\n      var props = data.props;\n      if (isDef(attrs) || isDef(props)) {\n        for (var key in propOptions) {\n          var altKey = hyphenate(key);\n          {\n            var keyInLowerCase = key.toLowerCase();\n            if (\n              key !== keyInLowerCase &&\n              attrs && hasOwn(attrs, keyInLowerCase)\n            ) {\n              tip(\n                \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n                (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n                \" \\\"\" + key + \"\\\". \" +\n                \"Note that HTML attributes are case-insensitive and camelCased \" +\n                \"props need to use their kebab-case equivalents when using in-DOM \" +\n                \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n              );\n            }\n          }\n          checkProp(res, props, key, altKey, true) ||\n          checkProp(res, attrs, key, altKey, false);\n        }\n      }\n      return res\n    }\n  \n    function checkProp (\n      res,\n      hash,\n      key,\n      altKey,\n      preserve\n    ) {\n      if (isDef(hash)) {\n        if (hasOwn(hash, key)) {\n          res[key] = hash[key];\n          if (!preserve) {\n            delete hash[key];\n          }\n          return true\n        } else if (hasOwn(hash, altKey)) {\n          res[key] = hash[altKey];\n          if (!preserve) {\n            delete hash[altKey];\n          }\n          return true\n        }\n      }\n      return false\n    }\n  \n    /*  */\n  \n    // The template compiler attempts to minimize the need for normalization by\n    // statically analyzing the template at compile time.\n    //\n    // For plain HTML markup, normalization can be completely skipped because the\n    // generated render function is guaranteed to return Array<VNode>. There are\n    // two cases where extra normalization is needed:\n  \n    // 1. When the children contains components - because a functional component\n    // may return an Array instead of a single root. In this case, just a simple\n    // normalization is needed - if any child is an Array, we flatten the whole\n    // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n    // because functional components already normalize their own children.\n    function simpleNormalizeChildren (children) {\n      for (var i = 0; i < children.length; i++) {\n        if (Array.isArray(children[i])) {\n          return Array.prototype.concat.apply([], children)\n        }\n      }\n      return children\n    }\n  \n    // 2. When the children contains constructs that always generated nested Arrays,\n    // e.g. <template>, <slot>, v-for, or when the children is provided by user\n    // with hand-written render functions / JSX. In such cases a full normalization\n    // is needed to cater to all possible types of children values.\n    function normalizeChildren (children) {\n      return isPrimitive(children)\n        ? [createTextVNode(children)]\n        : Array.isArray(children)\n          ? normalizeArrayChildren(children)\n          : undefined\n    }\n  \n    function isTextNode (node) {\n      return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n    }\n  \n    function normalizeArrayChildren (children, nestedIndex) {\n      var res = [];\n      var i, c, lastIndex, last;\n      for (i = 0; i < children.length; i++) {\n        c = children[i];\n        if (isUndef(c) || typeof c === 'boolean') { continue }\n        lastIndex = res.length - 1;\n        last = res[lastIndex];\n        //  nested\n        if (Array.isArray(c)) {\n          if (c.length > 0) {\n            c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n            // merge adjacent text nodes\n            if (isTextNode(c[0]) && isTextNode(last)) {\n              res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n              c.shift();\n            }\n            res.push.apply(res, c);\n          }\n        } else if (isPrimitive(c)) {\n          if (isTextNode(last)) {\n            // merge adjacent text nodes\n            // this is necessary for SSR hydration because text nodes are\n            // essentially merged when rendered to HTML strings\n            res[lastIndex] = createTextVNode(last.text + c);\n          } else if (c !== '') {\n            // convert primitive to vnode\n            res.push(createTextVNode(c));\n          }\n        } else {\n          if (isTextNode(c) && isTextNode(last)) {\n            // merge adjacent text nodes\n            res[lastIndex] = createTextVNode(last.text + c.text);\n          } else {\n            // default key for nested array children (likely generated by v-for)\n            if (isTrue(children._isVList) &&\n              isDef(c.tag) &&\n              isUndef(c.key) &&\n              isDef(nestedIndex)) {\n              c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n            }\n            res.push(c);\n          }\n        }\n      }\n      return res\n    }\n  \n    /*  */\n  \n    function initProvide (vm) {\n      var provide = vm.$options.provide;\n      if (provide) {\n        vm._provided = typeof provide === 'function'\n          ? provide.call(vm)\n          : provide;\n      }\n    }\n  \n    function initInjections (vm) {\n      var result = resolveInject(vm.$options.inject, vm);\n      if (result) {\n        toggleObserving(false);\n        Object.keys(result).forEach(function (key) {\n          /* istanbul ignore else */\n          {\n            defineReactive$$1(vm, key, result[key], function () {\n              warn(\n                \"Avoid mutating an injected value directly since the changes will be \" +\n                \"overwritten whenever the provided component re-renders. \" +\n                \"injection being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            });\n          }\n        });\n        toggleObserving(true);\n      }\n    }\n  \n    function resolveInject (inject, vm) {\n      if (inject) {\n        // inject is :any because flow is not smart enough to figure out cached\n        var result = Object.create(null);\n        var keys = hasSymbol\n          ? Reflect.ownKeys(inject)\n          : Object.keys(inject);\n  \n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          // #6574 in case the inject object is observed...\n          if (key === '__ob__') { continue }\n          var provideKey = inject[key].from;\n          var source = vm;\n          while (source) {\n            if (source._provided && hasOwn(source._provided, provideKey)) {\n              result[key] = source._provided[provideKey];\n              break\n            }\n            source = source.$parent;\n          }\n          if (!source) {\n            if ('default' in inject[key]) {\n              var provideDefault = inject[key].default;\n              result[key] = typeof provideDefault === 'function'\n                ? provideDefault.call(vm)\n                : provideDefault;\n            } else {\n              warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n            }\n          }\n        }\n        return result\n      }\n    }\n  \n    /*  */\n  \n  \n  \n    /**\n     * Runtime helper for resolving raw children VNodes into a slot object.\n     */\n    function resolveSlots (\n      children,\n      context\n    ) {\n      if (!children || !children.length) {\n        return {}\n      }\n      var slots = {};\n      for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        var data = child.data;\n        // remove slot attribute if the node is resolved as a Vue slot node\n        if (data && data.attrs && data.attrs.slot) {\n          delete data.attrs.slot;\n        }\n        // named slots should only be respected if the vnode was rendered in the\n        // same context.\n        if ((child.context === context || child.fnContext === context) &&\n          data && data.slot != null\n        ) {\n          var name = data.slot;\n          var slot = (slots[name] || (slots[name] = []));\n          if (child.tag === 'template') {\n            slot.push.apply(slot, child.children || []);\n          } else {\n            slot.push(child);\n          }\n        } else {\n          (slots.default || (slots.default = [])).push(child);\n        }\n      }\n      // ignore slots that contains only whitespace\n      for (var name$1 in slots) {\n        if (slots[name$1].every(isWhitespace)) {\n          delete slots[name$1];\n        }\n      }\n      return slots\n    }\n  \n    function isWhitespace (node) {\n      return (node.isComment && !node.asyncFactory) || node.text === ' '\n    }\n  \n    /*  */\n  \n    function isAsyncPlaceholder (node) {\n      return node.isComment && node.asyncFactory\n    }\n  \n    /*  */\n  \n    function normalizeScopedSlots (\n      slots,\n      normalSlots,\n      prevSlots\n    ) {\n      var res;\n      var hasNormalSlots = Object.keys(normalSlots).length > 0;\n      var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n      var key = slots && slots.$key;\n      if (!slots) {\n        res = {};\n      } else if (slots._normalized) {\n        // fast path 1: child component re-render only, parent did not change\n        return slots._normalized\n      } else if (\n        isStable &&\n        prevSlots &&\n        prevSlots !== emptyObject &&\n        key === prevSlots.$key &&\n        !hasNormalSlots &&\n        !prevSlots.$hasNormal\n      ) {\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\n        // only need to normalize once\n        return prevSlots\n      } else {\n        res = {};\n        for (var key$1 in slots) {\n          if (slots[key$1] && key$1[0] !== '$') {\n            res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n          }\n        }\n      }\n      // expose normal slots on scopedSlots\n      for (var key$2 in normalSlots) {\n        if (!(key$2 in res)) {\n          res[key$2] = proxyNormalSlot(normalSlots, key$2);\n        }\n      }\n      // avoriaz seems to mock a non-extensible $scopedSlots object\n      // and when that is passed down this would cause an error\n      if (slots && Object.isExtensible(slots)) {\n        (slots)._normalized = res;\n      }\n      def(res, '$stable', isStable);\n      def(res, '$key', key);\n      def(res, '$hasNormal', hasNormalSlots);\n      return res\n    }\n  \n    function normalizeScopedSlot(normalSlots, key, fn) {\n      var normalized = function () {\n        var res = arguments.length ? fn.apply(null, arguments) : fn({});\n        res = res && typeof res === 'object' && !Array.isArray(res)\n          ? [res] // single vnode\n          : normalizeChildren(res);\n        var vnode = res && res[0];\n        return res && (\n          !vnode ||\n          (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391\n        ) ? undefined\n          : res\n      };\n      // this is a slot using the new v-slot syntax without scope. although it is\n      // compiled as a scoped slot, render fn users would expect it to be present\n      // on this.$slots because the usage is semantically a normal slot.\n      if (fn.proxy) {\n        Object.defineProperty(normalSlots, key, {\n          get: normalized,\n          enumerable: true,\n          configurable: true\n        });\n      }\n      return normalized\n    }\n  \n    function proxyNormalSlot(slots, key) {\n      return function () { return slots[key]; }\n    }\n  \n    /*  */\n  \n    /**\n     * Runtime helper for rendering v-for lists.\n     */\n    function renderList (\n      val,\n      render\n    ) {\n      var ret, i, l, keys, key;\n      if (Array.isArray(val) || typeof val === 'string') {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n          ret[i] = render(val[i], i);\n        }\n      } else if (typeof val === 'number') {\n        ret = new Array(val);\n        for (i = 0; i < val; i++) {\n          ret[i] = render(i + 1, i);\n        }\n      } else if (isObject(val)) {\n        if (hasSymbol && val[Symbol.iterator]) {\n          ret = [];\n          var iterator = val[Symbol.iterator]();\n          var result = iterator.next();\n          while (!result.done) {\n            ret.push(render(result.value, ret.length));\n            result = iterator.next();\n          }\n        } else {\n          keys = Object.keys(val);\n          ret = new Array(keys.length);\n          for (i = 0, l = keys.length; i < l; i++) {\n            key = keys[i];\n            ret[i] = render(val[key], key, i);\n          }\n        }\n      }\n      if (!isDef(ret)) {\n        ret = [];\n      }\n      (ret)._isVList = true;\n      return ret\n    }\n  \n    /*  */\n  \n    /**\n     * Runtime helper for rendering <slot>\n     */\n    function renderSlot (\n      name,\n      fallbackRender,\n      props,\n      bindObject\n    ) {\n      var scopedSlotFn = this.$scopedSlots[name];\n      var nodes;\n      if (scopedSlotFn) {\n        // scoped slot\n        props = props || {};\n        if (bindObject) {\n          if (!isObject(bindObject)) {\n            warn('slot v-bind without argument expects an Object', this);\n          }\n          props = extend(extend({}, bindObject), props);\n        }\n        nodes =\n          scopedSlotFn(props) ||\n          (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n      } else {\n        nodes =\n          this.$slots[name] ||\n          (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n      }\n  \n      var target = props && props.slot;\n      if (target) {\n        return this.$createElement('template', { slot: target }, nodes)\n      } else {\n        return nodes\n      }\n    }\n  \n    /*  */\n  \n    /**\n     * Runtime helper for resolving filters\n     */\n    function resolveFilter (id) {\n      return resolveAsset(this.$options, 'filters', id, true) || identity\n    }\n  \n    /*  */\n  \n    function isKeyNotMatch (expect, actual) {\n      if (Array.isArray(expect)) {\n        return expect.indexOf(actual) === -1\n      } else {\n        return expect !== actual\n      }\n    }\n  \n    /**\n     * Runtime helper for checking keyCodes from config.\n     * exposed as Vue.prototype._k\n     * passing in eventKeyName as last argument separately for backwards compat\n     */\n    function checkKeyCodes (\n      eventKeyCode,\n      key,\n      builtInKeyCode,\n      eventKeyName,\n      builtInKeyName\n    ) {\n      var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n      if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n        return isKeyNotMatch(builtInKeyName, eventKeyName)\n      } else if (mappedKeyCode) {\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n      } else if (eventKeyName) {\n        return hyphenate(eventKeyName) !== key\n      }\n      return eventKeyCode === undefined\n    }\n  \n    /*  */\n  \n    /**\n     * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n     */\n    function bindObjectProps (\n      data,\n      tag,\n      value,\n      asProp,\n      isSync\n    ) {\n      if (value) {\n        if (!isObject(value)) {\n          warn(\n            'v-bind without argument expects an Object or Array value',\n            this\n          );\n        } else {\n          if (Array.isArray(value)) {\n            value = toObject(value);\n          }\n          var hash;\n          var loop = function ( key ) {\n            if (\n              key === 'class' ||\n              key === 'style' ||\n              isReservedAttribute(key)\n            ) {\n              hash = data;\n            } else {\n              var type = data.attrs && data.attrs.type;\n              hash = asProp || config.mustUseProp(tag, type, key)\n                ? data.domProps || (data.domProps = {})\n                : data.attrs || (data.attrs = {});\n            }\n            var camelizedKey = camelize(key);\n            var hyphenatedKey = hyphenate(key);\n            if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n              hash[key] = value[key];\n  \n              if (isSync) {\n                var on = data.on || (data.on = {});\n                on[(\"update:\" + key)] = function ($event) {\n                  value[key] = $event;\n                };\n              }\n            }\n          };\n  \n          for (var key in value) loop( key );\n        }\n      }\n      return data\n    }\n  \n    /*  */\n  \n    /**\n     * Runtime helper for rendering static trees.\n     */\n    function renderStatic (\n      index,\n      isInFor\n    ) {\n      var cached = this._staticTrees || (this._staticTrees = []);\n      var tree = cached[index];\n      // if has already-rendered static tree and not inside v-for,\n      // we can reuse the same tree.\n      if (tree && !isInFor) {\n        return tree\n      }\n      // otherwise, render a fresh tree.\n      tree = cached[index] = this.$options.staticRenderFns[index].call(\n        this._renderProxy,\n        null,\n        this // for render fns generated for functional component templates\n      );\n      markStatic(tree, (\"__static__\" + index), false);\n      return tree\n    }\n  \n    /**\n     * Runtime helper for v-once.\n     * Effectively it means marking the node as static with a unique key.\n     */\n    function markOnce (\n      tree,\n      index,\n      key\n    ) {\n      markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n      return tree\n    }\n  \n    function markStatic (\n      tree,\n      key,\n      isOnce\n    ) {\n      if (Array.isArray(tree)) {\n        for (var i = 0; i < tree.length; i++) {\n          if (tree[i] && typeof tree[i] !== 'string') {\n            markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n          }\n        }\n      } else {\n        markStaticNode(tree, key, isOnce);\n      }\n    }\n  \n    function markStaticNode (node, key, isOnce) {\n      node.isStatic = true;\n      node.key = key;\n      node.isOnce = isOnce;\n    }\n  \n    /*  */\n  \n    function bindObjectListeners (data, value) {\n      if (value) {\n        if (!isPlainObject(value)) {\n          warn(\n            'v-on without argument expects an Object value',\n            this\n          );\n        } else {\n          var on = data.on = data.on ? extend({}, data.on) : {};\n          for (var key in value) {\n            var existing = on[key];\n            var ours = value[key];\n            on[key] = existing ? [].concat(existing, ours) : ours;\n          }\n        }\n      }\n      return data\n    }\n  \n    /*  */\n  \n    function resolveScopedSlots (\n      fns, // see flow/vnode\n      res,\n      // the following are added in 2.6\n      hasDynamicKeys,\n      contentHashKey\n    ) {\n      res = res || { $stable: !hasDynamicKeys };\n      for (var i = 0; i < fns.length; i++) {\n        var slot = fns[i];\n        if (Array.isArray(slot)) {\n          resolveScopedSlots(slot, res, hasDynamicKeys);\n        } else if (slot) {\n          // marker for reverse proxying v-slot without scope on this.$slots\n          if (slot.proxy) {\n            slot.fn.proxy = true;\n          }\n          res[slot.key] = slot.fn;\n        }\n      }\n      if (contentHashKey) {\n        (res).$key = contentHashKey;\n      }\n      return res\n    }\n  \n    /*  */\n  \n    function bindDynamicKeys (baseObj, values) {\n      for (var i = 0; i < values.length; i += 2) {\n        var key = values[i];\n        if (typeof key === 'string' && key) {\n          baseObj[values[i]] = values[i + 1];\n        } else if (key !== '' && key !== null) {\n          // null is a special value for explicitly removing a binding\n          warn(\n            (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n            this\n          );\n        }\n      }\n      return baseObj\n    }\n  \n    // helper to dynamically append modifier runtime markers to event names.\n    // ensure only append when value is already string, otherwise it will be cast\n    // to string and cause the type check to miss.\n    function prependModifier (value, symbol) {\n      return typeof value === 'string' ? symbol + value : value\n    }\n  \n    /*  */\n  \n    function installRenderHelpers (target) {\n      target._o = markOnce;\n      target._n = toNumber;\n      target._s = toString;\n      target._l = renderList;\n      target._t = renderSlot;\n      target._q = looseEqual;\n      target._i = looseIndexOf;\n      target._m = renderStatic;\n      target._f = resolveFilter;\n      target._k = checkKeyCodes;\n      target._b = bindObjectProps;\n      target._v = createTextVNode;\n      target._e = createEmptyVNode;\n      target._u = resolveScopedSlots;\n      target._g = bindObjectListeners;\n      target._d = bindDynamicKeys;\n      target._p = prependModifier;\n    }\n  \n    /*  */\n  \n    function FunctionalRenderContext (\n      data,\n      props,\n      children,\n      parent,\n      Ctor\n    ) {\n      var this$1 = this;\n  \n      var options = Ctor.options;\n      // ensure the createElement function in functional components\n      // gets a unique context - this is necessary for correct named slot check\n      var contextVm;\n      if (hasOwn(parent, '_uid')) {\n        contextVm = Object.create(parent);\n        // $flow-disable-line\n        contextVm._original = parent;\n      } else {\n        // the context vm passed in is a functional context as well.\n        // in this case we want to make sure we are able to get a hold to the\n        // real context instance.\n        contextVm = parent;\n        // $flow-disable-line\n        parent = parent._original;\n      }\n      var isCompiled = isTrue(options._compiled);\n      var needNormalization = !isCompiled;\n  \n      this.data = data;\n      this.props = props;\n      this.children = children;\n      this.parent = parent;\n      this.listeners = data.on || emptyObject;\n      this.injections = resolveInject(options.inject, parent);\n      this.slots = function () {\n        if (!this$1.$slots) {\n          normalizeScopedSlots(\n            data.scopedSlots,\n            this$1.$slots = resolveSlots(children, parent)\n          );\n        }\n        return this$1.$slots\n      };\n  \n      Object.defineProperty(this, 'scopedSlots', ({\n        enumerable: true,\n        get: function get () {\n          return normalizeScopedSlots(data.scopedSlots, this.slots())\n        }\n      }));\n  \n      // support for compiled functional template\n      if (isCompiled) {\n        // exposing $options for renderStatic()\n        this.$options = options;\n        // pre-resolve slots for renderSlot()\n        this.$slots = this.slots();\n        this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n      }\n  \n      if (options._scopeId) {\n        this._c = function (a, b, c, d) {\n          var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n          if (vnode && !Array.isArray(vnode)) {\n            vnode.fnScopeId = options._scopeId;\n            vnode.fnContext = parent;\n          }\n          return vnode\n        };\n      } else {\n        this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n      }\n    }\n  \n    installRenderHelpers(FunctionalRenderContext.prototype);\n  \n    function createFunctionalComponent (\n      Ctor,\n      propsData,\n      data,\n      contextVm,\n      children\n    ) {\n      var options = Ctor.options;\n      var props = {};\n      var propOptions = options.props;\n      if (isDef(propOptions)) {\n        for (var key in propOptions) {\n          props[key] = validateProp(key, propOptions, propsData || emptyObject);\n        }\n      } else {\n        if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n        if (isDef(data.props)) { mergeProps(props, data.props); }\n      }\n  \n      var renderContext = new FunctionalRenderContext(\n        data,\n        props,\n        children,\n        contextVm,\n        Ctor\n      );\n  \n      var vnode = options.render.call(null, renderContext._c, renderContext);\n  \n      if (vnode instanceof VNode) {\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n      } else if (Array.isArray(vnode)) {\n        var vnodes = normalizeChildren(vnode) || [];\n        var res = new Array(vnodes.length);\n        for (var i = 0; i < vnodes.length; i++) {\n          res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n        }\n        return res\n      }\n    }\n  \n    function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n      // #7817 clone node before setting fnContext, otherwise if the node is reused\n      // (e.g. it was from a cached normal slot) the fnContext causes named slots\n      // that should not be matched to match.\n      var clone = cloneVNode(vnode);\n      clone.fnContext = contextVm;\n      clone.fnOptions = options;\n      {\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n      }\n      if (data.slot) {\n        (clone.data || (clone.data = {})).slot = data.slot;\n      }\n      return clone\n    }\n  \n    function mergeProps (to, from) {\n      for (var key in from) {\n        to[camelize(key)] = from[key];\n      }\n    }\n  \n    /*  */\n  \n    /*  */\n  \n    /*  */\n  \n    /*  */\n  \n    // inline hooks to be invoked on component VNodes during patch\n    var componentVNodeHooks = {\n      init: function init (vnode, hydrating) {\n        if (\n          vnode.componentInstance &&\n          !vnode.componentInstance._isDestroyed &&\n          vnode.data.keepAlive\n        ) {\n          // kept-alive components, treat as a patch\n          var mountedNode = vnode; // work around flow\n          componentVNodeHooks.prepatch(mountedNode, mountedNode);\n        } else {\n          var child = vnode.componentInstance = createComponentInstanceForVnode(\n            vnode,\n            activeInstance\n          );\n          child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n        }\n      },\n  \n      prepatch: function prepatch (oldVnode, vnode) {\n        var options = vnode.componentOptions;\n        var child = vnode.componentInstance = oldVnode.componentInstance;\n        updateChildComponent(\n          child,\n          options.propsData, // updated props\n          options.listeners, // updated listeners\n          vnode, // new parent vnode\n          options.children // new children\n        );\n      },\n  \n      insert: function insert (vnode) {\n        var context = vnode.context;\n        var componentInstance = vnode.componentInstance;\n        if (!componentInstance._isMounted) {\n          componentInstance._isMounted = true;\n          callHook(componentInstance, 'mounted');\n        }\n        if (vnode.data.keepAlive) {\n          if (context._isMounted) {\n            // vue-router#1212\n            // During updates, a kept-alive component's child components may\n            // change, so directly walking the tree here may call activated hooks\n            // on incorrect children. Instead we push them into a queue which will\n            // be processed after the whole patch process ended.\n            queueActivatedComponent(componentInstance);\n          } else {\n            activateChildComponent(componentInstance, true /* direct */);\n          }\n        }\n      },\n  \n      destroy: function destroy (vnode) {\n        var componentInstance = vnode.componentInstance;\n        if (!componentInstance._isDestroyed) {\n          if (!vnode.data.keepAlive) {\n            componentInstance.$destroy();\n          } else {\n            deactivateChildComponent(componentInstance, true /* direct */);\n          }\n        }\n      }\n    };\n  \n    var hooksToMerge = Object.keys(componentVNodeHooks);\n  \n    function createComponent (\n      Ctor,\n      data,\n      context,\n      children,\n      tag\n    ) {\n      if (isUndef(Ctor)) {\n        return\n      }\n  \n      var baseCtor = context.$options._base;\n  \n      // plain options object: turn it into a constructor\n      if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor);\n      }\n  \n      // if at this stage it's not a constructor or an async component factory,\n      // reject.\n      if (typeof Ctor !== 'function') {\n        {\n          warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n        }\n        return\n      }\n  \n      // async component\n      var asyncFactory;\n      if (isUndef(Ctor.cid)) {\n        asyncFactory = Ctor;\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n        if (Ctor === undefined) {\n          // return a placeholder node for async component, which is rendered\n          // as a comment node but preserves all the raw information for the node.\n          // the information will be used for async server-rendering and hydration.\n          return createAsyncPlaceholder(\n            asyncFactory,\n            data,\n            context,\n            children,\n            tag\n          )\n        }\n      }\n  \n      data = data || {};\n  \n      // resolve constructor options in case global mixins are applied after\n      // component constructor creation\n      resolveConstructorOptions(Ctor);\n  \n      // transform component v-model data into props & events\n      if (isDef(data.model)) {\n        transformModel(Ctor.options, data);\n      }\n  \n      // extract props\n      var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n  \n      // functional component\n      if (isTrue(Ctor.options.functional)) {\n        return createFunctionalComponent(Ctor, propsData, data, context, children)\n      }\n  \n      // extract listeners, since these needs to be treated as\n      // child component listeners instead of DOM listeners\n      var listeners = data.on;\n      // replace with listeners with .native modifier\n      // so it gets processed during parent component patch.\n      data.on = data.nativeOn;\n  \n      if (isTrue(Ctor.options.abstract)) {\n        // abstract components do not keep anything\n        // other than props & listeners & slot\n  \n        // work around flow\n        var slot = data.slot;\n        data = {};\n        if (slot) {\n          data.slot = slot;\n        }\n      }\n  \n      // install component management hooks onto the placeholder node\n      installComponentHooks(data);\n  \n      // return a placeholder vnode\n      var name = Ctor.options.name || tag;\n      var vnode = new VNode(\n        (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n        data, undefined, undefined, undefined, context,\n        { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n        asyncFactory\n      );\n  \n      return vnode\n    }\n  \n    function createComponentInstanceForVnode (\n      // we know it's MountedComponentVNode but flow doesn't\n      vnode,\n      // activeInstance in lifecycle state\n      parent\n    ) {\n      var options = {\n        _isComponent: true,\n        _parentVnode: vnode,\n        parent: parent\n      };\n      // check inline-template render functions\n      var inlineTemplate = vnode.data.inlineTemplate;\n      if (isDef(inlineTemplate)) {\n        options.render = inlineTemplate.render;\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\n      }\n      return new vnode.componentOptions.Ctor(options)\n    }\n  \n    function installComponentHooks (data) {\n      var hooks = data.hook || (data.hook = {});\n      for (var i = 0; i < hooksToMerge.length; i++) {\n        var key = hooksToMerge[i];\n        var existing = hooks[key];\n        var toMerge = componentVNodeHooks[key];\n        if (existing !== toMerge && !(existing && existing._merged)) {\n          hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n        }\n      }\n    }\n  \n    function mergeHook$1 (f1, f2) {\n      var merged = function (a, b) {\n        // flow complains about extra args which is why we use any\n        f1(a, b);\n        f2(a, b);\n      };\n      merged._merged = true;\n      return merged\n    }\n  \n    // transform component v-model info (value and callback) into\n    // prop and event handler respectively.\n    function transformModel (options, data) {\n      var prop = (options.model && options.model.prop) || 'value';\n      var event = (options.model && options.model.event) || 'input'\n      ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n      var on = data.on || (data.on = {});\n      var existing = on[event];\n      var callback = data.model.callback;\n      if (isDef(existing)) {\n        if (\n          Array.isArray(existing)\n            ? existing.indexOf(callback) === -1\n            : existing !== callback\n        ) {\n          on[event] = [callback].concat(existing);\n        }\n      } else {\n        on[event] = callback;\n      }\n    }\n  \n    /*  */\n  \n    var SIMPLE_NORMALIZE = 1;\n    var ALWAYS_NORMALIZE = 2;\n  \n    // wrapper function for providing a more flexible interface\n    // without getting yelled at by flow\n    function createElement (\n      context,\n      tag,\n      data,\n      children,\n      normalizationType,\n      alwaysNormalize\n    ) {\n      if (Array.isArray(data) || isPrimitive(data)) {\n        normalizationType = children;\n        children = data;\n        data = undefined;\n      }\n      if (isTrue(alwaysNormalize)) {\n        normalizationType = ALWAYS_NORMALIZE;\n      }\n      return _createElement(context, tag, data, children, normalizationType)\n    }\n  \n    function _createElement (\n      context,\n      tag,\n      data,\n      children,\n      normalizationType\n    ) {\n      if (isDef(data) && isDef((data).__ob__)) {\n        warn(\n          \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n          'Always create fresh vnode data objects in each render!',\n          context\n        );\n        return createEmptyVNode()\n      }\n      // object syntax in v-bind\n      if (isDef(data) && isDef(data.is)) {\n        tag = data.is;\n      }\n      if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode()\n      }\n      // warn against non-primitive key\n      if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n      ) {\n        {\n          warn(\n            'Avoid using non-primitive value as key, ' +\n            'use string/number value instead.',\n            context\n          );\n        }\n      }\n      // support single function children as default scoped slot\n      if (Array.isArray(children) &&\n        typeof children[0] === 'function'\n      ) {\n        data = data || {};\n        data.scopedSlots = { default: children[0] };\n        children.length = 0;\n      }\n      if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children);\n      } else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children);\n      }\n      var vnode, ns;\n      if (typeof tag === 'string') {\n        var Ctor;\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n        if (config.isReservedTag(tag)) {\n          // platform built-in elements\n          if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {\n            warn(\n              (\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\"),\n              context\n            );\n          }\n          vnode = new VNode(\n            config.parsePlatformTagName(tag), data, children,\n            undefined, undefined, context\n          );\n        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n          // component\n          vnode = createComponent(Ctor, data, context, children, tag);\n        } else {\n          // unknown or unlisted namespaced elements\n          // check at runtime because it may get assigned a namespace when its\n          // parent normalizes children\n          vnode = new VNode(\n            tag, data, children,\n            undefined, undefined, context\n          );\n        }\n      } else {\n        // direct component options / constructor\n        vnode = createComponent(tag, data, context, children);\n      }\n      if (Array.isArray(vnode)) {\n        return vnode\n      } else if (isDef(vnode)) {\n        if (isDef(ns)) { applyNS(vnode, ns); }\n        if (isDef(data)) { registerDeepBindings(data); }\n        return vnode\n      } else {\n        return createEmptyVNode()\n      }\n    }\n  \n    function applyNS (vnode, ns, force) {\n      vnode.ns = ns;\n      if (vnode.tag === 'foreignObject') {\n        // use default namespace inside foreignObject\n        ns = undefined;\n        force = true;\n      }\n      if (isDef(vnode.children)) {\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\n          var child = vnode.children[i];\n          if (isDef(child.tag) && (\n            isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n            applyNS(child, ns, force);\n          }\n        }\n      }\n    }\n  \n    // ref #5318\n    // necessary to ensure parent re-render when deep bindings like :style and\n    // :class are used on slot nodes\n    function registerDeepBindings (data) {\n      if (isObject(data.style)) {\n        traverse(data.style);\n      }\n      if (isObject(data.class)) {\n        traverse(data.class);\n      }\n    }\n  \n    /*  */\n  \n    function initRender (vm) {\n      vm._vnode = null; // the root of the child tree\n      vm._staticTrees = null; // v-once cached trees\n      var options = vm.$options;\n      var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n      var renderContext = parentVnode && parentVnode.context;\n      vm.$slots = resolveSlots(options._renderChildren, renderContext);\n      vm.$scopedSlots = emptyObject;\n      // bind the createElement fn to this instance\n      // so that we get proper render context inside it.\n      // args order: tag, data, children, normalizationType, alwaysNormalize\n      // internal version is used by render functions compiled from templates\n      vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n      // normalization is always applied for the public version, used in\n      // user-written render functions.\n      vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n  \n      // $attrs & $listeners are exposed for easier HOC creation.\n      // they need to be reactive so that HOCs using them are always updated\n      var parentData = parentVnode && parentVnode.data;\n  \n      /* istanbul ignore else */\n      {\n        defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n          !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n        }, true);\n        defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n          !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n        }, true);\n      }\n    }\n  \n    var currentRenderingInstance = null;\n  \n    function renderMixin (Vue) {\n      // install runtime convenience helpers\n      installRenderHelpers(Vue.prototype);\n  \n      Vue.prototype.$nextTick = function (fn) {\n        return nextTick(fn, this)\n      };\n  \n      Vue.prototype._render = function () {\n        var vm = this;\n        var ref = vm.$options;\n        var render = ref.render;\n        var _parentVnode = ref._parentVnode;\n  \n        if (_parentVnode) {\n          vm.$scopedSlots = normalizeScopedSlots(\n            _parentVnode.data.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n          );\n        }\n  \n        // set parent vnode. this allows render functions to have access\n        // to the data on the placeholder node.\n        vm.$vnode = _parentVnode;\n        // render self\n        var vnode;\n        try {\n          // There's no need to maintain a stack because all render fns are called\n          // separately from one another. Nested component's render fns are called\n          // when parent component is patched.\n          currentRenderingInstance = vm;\n          vnode = render.call(vm._renderProxy, vm.$createElement);\n        } catch (e) {\n          handleError(e, vm, \"render\");\n          // return error render result,\n          // or previous vnode to prevent render error causing blank component\n          /* istanbul ignore else */\n          if (vm.$options.renderError) {\n            try {\n              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n            } catch (e) {\n              handleError(e, vm, \"renderError\");\n              vnode = vm._vnode;\n            }\n          } else {\n            vnode = vm._vnode;\n          }\n        } finally {\n          currentRenderingInstance = null;\n        }\n        // if the returned array contains only a single node, allow it\n        if (Array.isArray(vnode) && vnode.length === 1) {\n          vnode = vnode[0];\n        }\n        // return empty vnode in case the render function errored out\n        if (!(vnode instanceof VNode)) {\n          if (Array.isArray(vnode)) {\n            warn(\n              'Multiple root nodes returned from render function. Render function ' +\n              'should return a single root node.',\n              vm\n            );\n          }\n          vnode = createEmptyVNode();\n        }\n        // set parent\n        vnode.parent = _parentVnode;\n        return vnode\n      };\n    }\n  \n    /*  */\n  \n    function ensureCtor (comp, base) {\n      if (\n        comp.__esModule ||\n        (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n      ) {\n        comp = comp.default;\n      }\n      return isObject(comp)\n        ? base.extend(comp)\n        : comp\n    }\n  \n    function createAsyncPlaceholder (\n      factory,\n      data,\n      context,\n      children,\n      tag\n    ) {\n      var node = createEmptyVNode();\n      node.asyncFactory = factory;\n      node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n      return node\n    }\n  \n    function resolveAsyncComponent (\n      factory,\n      baseCtor\n    ) {\n      if (isTrue(factory.error) && isDef(factory.errorComp)) {\n        return factory.errorComp\n      }\n  \n      if (isDef(factory.resolved)) {\n        return factory.resolved\n      }\n  \n      var owner = currentRenderingInstance;\n      if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n        // already pending\n        factory.owners.push(owner);\n      }\n  \n      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n        return factory.loadingComp\n      }\n  \n      if (owner && !isDef(factory.owners)) {\n        var owners = factory.owners = [owner];\n        var sync = true;\n        var timerLoading = null;\n        var timerTimeout = null\n  \n        ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n  \n        var forceRender = function (renderCompleted) {\n          for (var i = 0, l = owners.length; i < l; i++) {\n            (owners[i]).$forceUpdate();\n          }\n  \n          if (renderCompleted) {\n            owners.length = 0;\n            if (timerLoading !== null) {\n              clearTimeout(timerLoading);\n              timerLoading = null;\n            }\n            if (timerTimeout !== null) {\n              clearTimeout(timerTimeout);\n              timerTimeout = null;\n            }\n          }\n        };\n  \n        var resolve = once(function (res) {\n          // cache resolved\n          factory.resolved = ensureCtor(res, baseCtor);\n          // invoke callbacks only if this is not a synchronous resolve\n          // (async resolves are shimmed as synchronous during SSR)\n          if (!sync) {\n            forceRender(true);\n          } else {\n            owners.length = 0;\n          }\n        });\n  \n        var reject = once(function (reason) {\n          warn(\n            \"Failed to resolve async component: \" + (String(factory)) +\n            (reason ? (\"\\nReason: \" + reason) : '')\n          );\n          if (isDef(factory.errorComp)) {\n            factory.error = true;\n            forceRender(true);\n          }\n        });\n  \n        var res = factory(resolve, reject);\n  \n        if (isObject(res)) {\n          if (isPromise(res)) {\n            // () => Promise\n            if (isUndef(factory.resolved)) {\n              res.then(resolve, reject);\n            }\n          } else if (isPromise(res.component)) {\n            res.component.then(resolve, reject);\n  \n            if (isDef(res.error)) {\n              factory.errorComp = ensureCtor(res.error, baseCtor);\n            }\n  \n            if (isDef(res.loading)) {\n              factory.loadingComp = ensureCtor(res.loading, baseCtor);\n              if (res.delay === 0) {\n                factory.loading = true;\n              } else {\n                timerLoading = setTimeout(function () {\n                  timerLoading = null;\n                  if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                    factory.loading = true;\n                    forceRender(false);\n                  }\n                }, res.delay || 200);\n              }\n            }\n  \n            if (isDef(res.timeout)) {\n              timerTimeout = setTimeout(function () {\n                timerTimeout = null;\n                if (isUndef(factory.resolved)) {\n                  reject(\n                    \"timeout (\" + (res.timeout) + \"ms)\"\n                  );\n                }\n              }, res.timeout);\n            }\n          }\n        }\n  \n        sync = false;\n        // return in case resolved synchronously\n        return factory.loading\n          ? factory.loadingComp\n          : factory.resolved\n      }\n    }\n  \n    /*  */\n  \n    function getFirstComponentChild (children) {\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          var c = children[i];\n          if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n            return c\n          }\n        }\n      }\n    }\n  \n    /*  */\n  \n    /*  */\n  \n    function initEvents (vm) {\n      vm._events = Object.create(null);\n      vm._hasHookEvent = false;\n      // init parent attached events\n      var listeners = vm.$options._parentListeners;\n      if (listeners) {\n        updateComponentListeners(vm, listeners);\n      }\n    }\n  \n    var target;\n  \n    function add (event, fn) {\n      target.$on(event, fn);\n    }\n  \n    function remove$1 (event, fn) {\n      target.$off(event, fn);\n    }\n  \n    function createOnceHandler (event, fn) {\n      var _target = target;\n      return function onceHandler () {\n        var res = fn.apply(null, arguments);\n        if (res !== null) {\n          _target.$off(event, onceHandler);\n        }\n      }\n    }\n  \n    function updateComponentListeners (\n      vm,\n      listeners,\n      oldListeners\n    ) {\n      target = vm;\n      updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n      target = undefined;\n    }\n  \n    function eventsMixin (Vue) {\n      var hookRE = /^hook:/;\n      Vue.prototype.$on = function (event, fn) {\n        var vm = this;\n        if (Array.isArray(event)) {\n          for (var i = 0, l = event.length; i < l; i++) {\n            vm.$on(event[i], fn);\n          }\n        } else {\n          (vm._events[event] || (vm._events[event] = [])).push(fn);\n          // optimize hook:event cost by using a boolean flag marked at registration\n          // instead of a hash lookup\n          if (hookRE.test(event)) {\n            vm._hasHookEvent = true;\n          }\n        }\n        return vm\n      };\n  \n      Vue.prototype.$once = function (event, fn) {\n        var vm = this;\n        function on () {\n          vm.$off(event, on);\n          fn.apply(vm, arguments);\n        }\n        on.fn = fn;\n        vm.$on(event, on);\n        return vm\n      };\n  \n      Vue.prototype.$off = function (event, fn) {\n        var vm = this;\n        // all\n        if (!arguments.length) {\n          vm._events = Object.create(null);\n          return vm\n        }\n        // array of events\n        if (Array.isArray(event)) {\n          for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n            vm.$off(event[i$1], fn);\n          }\n          return vm\n        }\n        // specific event\n        var cbs = vm._events[event];\n        if (!cbs) {\n          return vm\n        }\n        if (!fn) {\n          vm._events[event] = null;\n          return vm\n        }\n        // specific handler\n        var cb;\n        var i = cbs.length;\n        while (i--) {\n          cb = cbs[i];\n          if (cb === fn || cb.fn === fn) {\n            cbs.splice(i, 1);\n            break\n          }\n        }\n        return vm\n      };\n  \n      Vue.prototype.$emit = function (event) {\n        var vm = this;\n        {\n          var lowerCaseEvent = event.toLowerCase();\n          if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n            tip(\n              \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n              (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and you cannot use \" +\n              \"v-on to listen to camelCase events when using in-DOM templates. \" +\n              \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n            );\n          }\n        }\n        var cbs = vm._events[event];\n        if (cbs) {\n          cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n          var args = toArray(arguments, 1);\n          var info = \"event handler for \\\"\" + event + \"\\\"\";\n          for (var i = 0, l = cbs.length; i < l; i++) {\n            invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n          }\n        }\n        return vm\n      };\n    }\n  \n    /*  */\n  \n    var activeInstance = null;\n    var isUpdatingChildComponent = false;\n  \n    function setActiveInstance(vm) {\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      return function () {\n        activeInstance = prevActiveInstance;\n      }\n    }\n  \n    function initLifecycle (vm) {\n      var options = vm.$options;\n  \n      // locate first non-abstract parent\n      var parent = options.parent;\n      if (parent && !options.abstract) {\n        while (parent.$options.abstract && parent.$parent) {\n          parent = parent.$parent;\n        }\n        parent.$children.push(vm);\n      }\n  \n      vm.$parent = parent;\n      vm.$root = parent ? parent.$root : vm;\n  \n      vm.$children = [];\n      vm.$refs = {};\n  \n      vm._watcher = null;\n      vm._inactive = null;\n      vm._directInactive = false;\n      vm._isMounted = false;\n      vm._isDestroyed = false;\n      vm._isBeingDestroyed = false;\n    }\n  \n    function lifecycleMixin (Vue) {\n      Vue.prototype._update = function (vnode, hydrating) {\n        var vm = this;\n        var prevEl = vm.$el;\n        var prevVnode = vm._vnode;\n        var restoreActiveInstance = setActiveInstance(vm);\n        vm._vnode = vnode;\n        // Vue.prototype.__patch__ is injected in entry points\n        // based on the rendering backend used.\n        if (!prevVnode) {\n          // initial render\n          vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n        } else {\n          // updates\n          vm.$el = vm.__patch__(prevVnode, vnode);\n        }\n        restoreActiveInstance();\n        // update __vue__ reference\n        if (prevEl) {\n          prevEl.__vue__ = null;\n        }\n        if (vm.$el) {\n          vm.$el.__vue__ = vm;\n        }\n        // if parent is an HOC, update its $el as well\n        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n          vm.$parent.$el = vm.$el;\n        }\n        // updated hook is called by the scheduler to ensure that children are\n        // updated in a parent's updated hook.\n      };\n  \n      Vue.prototype.$forceUpdate = function () {\n        var vm = this;\n        if (vm._watcher) {\n          vm._watcher.update();\n        }\n      };\n  \n      Vue.prototype.$destroy = function () {\n        var vm = this;\n        if (vm._isBeingDestroyed) {\n          return\n        }\n        callHook(vm, 'beforeDestroy');\n        vm._isBeingDestroyed = true;\n        // remove self from parent\n        var parent = vm.$parent;\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n          remove(parent.$children, vm);\n        }\n        // teardown watchers\n        if (vm._watcher) {\n          vm._watcher.teardown();\n        }\n        var i = vm._watchers.length;\n        while (i--) {\n          vm._watchers[i].teardown();\n        }\n        // remove reference from data ob\n        // frozen object may not have observer.\n        if (vm._data.__ob__) {\n          vm._data.__ob__.vmCount--;\n        }\n        // call the last hook...\n        vm._isDestroyed = true;\n        // invoke destroy hooks on current rendered tree\n        vm.__patch__(vm._vnode, null);\n        // fire destroyed hook\n        callHook(vm, 'destroyed');\n        // turn off all instance listeners.\n        vm.$off();\n        // remove __vue__ reference\n        if (vm.$el) {\n          vm.$el.__vue__ = null;\n        }\n        // release circular reference (#6759)\n        if (vm.$vnode) {\n          vm.$vnode.parent = null;\n        }\n      };\n    }\n  \n    function mountComponent (\n      vm,\n      el,\n      hydrating\n    ) {\n      vm.$el = el;\n      if (!vm.$options.render) {\n        vm.$options.render = createEmptyVNode;\n        {\n          /* istanbul ignore if */\n          if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n            vm.$options.el || el) {\n            warn(\n              'You are using the runtime-only build of Vue where the template ' +\n              'compiler is not available. Either pre-compile the templates into ' +\n              'render functions, or use the compiler-included build.',\n              vm\n            );\n          } else {\n            warn(\n              'Failed to mount component: template or render function not defined.',\n              vm\n            );\n          }\n        }\n      }\n      callHook(vm, 'beforeMount');\n  \n      var updateComponent;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        updateComponent = function () {\n          var name = vm._name;\n          var id = vm._uid;\n          var startTag = \"vue-perf-start:\" + id;\n          var endTag = \"vue-perf-end:\" + id;\n  \n          mark(startTag);\n          var vnode = vm._render();\n          mark(endTag);\n          measure((\"vue \" + name + \" render\"), startTag, endTag);\n  \n          mark(startTag);\n          vm._update(vnode, hydrating);\n          mark(endTag);\n          measure((\"vue \" + name + \" patch\"), startTag, endTag);\n        };\n      } else {\n        updateComponent = function () {\n          vm._update(vm._render(), hydrating);\n        };\n      }\n  \n      // we set this to vm._watcher inside the watcher's constructor\n      // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n      // component's mounted hook), which relies on vm._watcher being already defined\n      new Watcher(vm, updateComponent, noop, {\n        before: function before () {\n          if (vm._isMounted && !vm._isDestroyed) {\n            callHook(vm, 'beforeUpdate');\n          }\n        }\n      }, true /* isRenderWatcher */);\n      hydrating = false;\n  \n      // manually mounted instance, call mounted on self\n      // mounted is called for render-created child components in its inserted hook\n      if (vm.$vnode == null) {\n        vm._isMounted = true;\n        callHook(vm, 'mounted');\n      }\n      return vm\n    }\n  \n    function updateChildComponent (\n      vm,\n      propsData,\n      listeners,\n      parentVnode,\n      renderChildren\n    ) {\n      {\n        isUpdatingChildComponent = true;\n      }\n  \n      // determine whether component has slot children\n      // we need to do this before overwriting $options._renderChildren.\n  \n      // check if there are dynamic scopedSlots (hand-written or compiled but with\n      // dynamic slot names). Static scoped slots compiled from template has the\n      // \"$stable\" marker.\n      var newScopedSlots = parentVnode.data.scopedSlots;\n      var oldScopedSlots = vm.$scopedSlots;\n      var hasDynamicScopedSlot = !!(\n        (newScopedSlots && !newScopedSlots.$stable) ||\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\n        (!newScopedSlots && vm.$scopedSlots.$key)\n      );\n  \n      // Any static slot children from the parent may have changed during parent's\n      // update. Dynamic scoped slots may also have changed. In such cases, a forced\n      // update is necessary to ensure correctness.\n      var needsForceUpdate = !!(\n        renderChildren ||               // has new static slots\n        vm.$options._renderChildren ||  // has old static slots\n        hasDynamicScopedSlot\n      );\n  \n      vm.$options._parentVnode = parentVnode;\n      vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  \n      if (vm._vnode) { // update child tree's parent\n        vm._vnode.parent = parentVnode;\n      }\n      vm.$options._renderChildren = renderChildren;\n  \n      // update $attrs and $listeners hash\n      // these are also reactive so they may trigger child update if the child\n      // used them during render\n      vm.$attrs = parentVnode.data.attrs || emptyObject;\n      vm.$listeners = listeners || emptyObject;\n  \n      // update props\n      if (propsData && vm.$options.props) {\n        toggleObserving(false);\n        var props = vm._props;\n        var propKeys = vm.$options._propKeys || [];\n        for (var i = 0; i < propKeys.length; i++) {\n          var key = propKeys[i];\n          var propOptions = vm.$options.props; // wtf flow?\n          props[key] = validateProp(key, propOptions, propsData, vm);\n        }\n        toggleObserving(true);\n        // keep a copy of raw propsData\n        vm.$options.propsData = propsData;\n      }\n  \n      // update listeners\n      listeners = listeners || emptyObject;\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n  \n      // resolve slots + force update if has children\n      if (needsForceUpdate) {\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n        vm.$forceUpdate();\n      }\n  \n      {\n        isUpdatingChildComponent = false;\n      }\n    }\n  \n    function isInInactiveTree (vm) {\n      while (vm && (vm = vm.$parent)) {\n        if (vm._inactive) { return true }\n      }\n      return false\n    }\n  \n    function activateChildComponent (vm, direct) {\n      if (direct) {\n        vm._directInactive = false;\n        if (isInInactiveTree(vm)) {\n          return\n        }\n      } else if (vm._directInactive) {\n        return\n      }\n      if (vm._inactive || vm._inactive === null) {\n        vm._inactive = false;\n        for (var i = 0; i < vm.$children.length; i++) {\n          activateChildComponent(vm.$children[i]);\n        }\n        callHook(vm, 'activated');\n      }\n    }\n  \n    function deactivateChildComponent (vm, direct) {\n      if (direct) {\n        vm._directInactive = true;\n        if (isInInactiveTree(vm)) {\n          return\n        }\n      }\n      if (!vm._inactive) {\n        vm._inactive = true;\n        for (var i = 0; i < vm.$children.length; i++) {\n          deactivateChildComponent(vm.$children[i]);\n        }\n        callHook(vm, 'deactivated');\n      }\n    }\n  \n    function callHook (vm, hook) {\n      // #7573 disable dep collection when invoking lifecycle hooks\n      pushTarget();\n      var handlers = vm.$options[hook];\n      var info = hook + \" hook\";\n      if (handlers) {\n        for (var i = 0, j = handlers.length; i < j; i++) {\n          invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n        }\n      }\n      if (vm._hasHookEvent) {\n        vm.$emit('hook:' + hook);\n      }\n      popTarget();\n    }\n  \n    /*  */\n  \n    var MAX_UPDATE_COUNT = 100;\n  \n    var queue = [];\n    var activatedChildren = [];\n    var has = {};\n    var circular = {};\n    var waiting = false;\n    var flushing = false;\n    var index = 0;\n  \n    /**\n     * Reset the scheduler's state.\n     */\n    function resetSchedulerState () {\n      index = queue.length = activatedChildren.length = 0;\n      has = {};\n      {\n        circular = {};\n      }\n      waiting = flushing = false;\n    }\n  \n    // Async edge case #6566 requires saving the timestamp when event listeners are\n    // attached. However, calling performance.now() has a perf overhead especially\n    // if the page has thousands of event listeners. Instead, we take a timestamp\n    // every time the scheduler flushes and use that for all event listeners\n    // attached during that flush.\n    var currentFlushTimestamp = 0;\n  \n    // Async edge case fix requires storing an event listener's attach timestamp.\n    var getNow = Date.now;\n  \n    // Determine what event timestamp the browser is using. Annoyingly, the\n    // timestamp can either be hi-res (relative to page load) or low-res\n    // (relative to UNIX epoch), so in order to compare time we have to use the\n    // same timestamp type when saving the flush timestamp.\n    // All IE versions use low-res event timestamps, and have problematic clock\n    // implementations (#9632)\n    if (inBrowser && !isIE) {\n      var performance = window.performance;\n      if (\n        performance &&\n        typeof performance.now === 'function' &&\n        getNow() > document.createEvent('Event').timeStamp\n      ) {\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\n        // smaller than it, it means the event is using a hi-res timestamp,\n        // and we need to use the hi-res version for event listener timestamps as\n        // well.\n        getNow = function () { return performance.now(); };\n      }\n    }\n  \n    /**\n     * Flush both queues and run the watchers.\n     */\n    function flushSchedulerQueue () {\n      currentFlushTimestamp = getNow();\n      flushing = true;\n      var watcher, id;\n  \n      // Sort queue before flush.\n      // This ensures that:\n      // 1. Components are updated from parent to child. (because parent is always\n      //    created before the child)\n      // 2. A component's user watchers are run before its render watcher (because\n      //    user watchers are created before the render watcher)\n      // 3. If a component is destroyed during a parent component's watcher run,\n      //    its watchers can be skipped.\n      queue.sort(function (a, b) { return a.id - b.id; });\n  \n      // do not cache length because more watchers might be pushed\n      // as we run existing watchers\n      for (index = 0; index < queue.length; index++) {\n        watcher = queue[index];\n        if (watcher.before) {\n          watcher.before();\n        }\n        id = watcher.id;\n        has[id] = null;\n        watcher.run();\n        // in dev build, check and stop circular updates.\n        if (has[id] != null) {\n          circular[id] = (circular[id] || 0) + 1;\n          if (circular[id] > MAX_UPDATE_COUNT) {\n            warn(\n              'You may have an infinite update loop ' + (\n                watcher.user\n                  ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                  : \"in a component render function.\"\n              ),\n              watcher.vm\n            );\n            break\n          }\n        }\n      }\n  \n      // keep copies of post queues before resetting state\n      var activatedQueue = activatedChildren.slice();\n      var updatedQueue = queue.slice();\n  \n      resetSchedulerState();\n  \n      // call component updated and activated hooks\n      callActivatedHooks(activatedQueue);\n      callUpdatedHooks(updatedQueue);\n  \n      // devtool hook\n      /* istanbul ignore if */\n      if (devtools && config.devtools) {\n        devtools.emit('flush');\n      }\n    }\n  \n    function callUpdatedHooks (queue) {\n      var i = queue.length;\n      while (i--) {\n        var watcher = queue[i];\n        var vm = watcher.vm;\n        if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'updated');\n        }\n      }\n    }\n  \n    /**\n     * Queue a kept-alive component that was activated during patch.\n     * The queue will be processed after the entire tree has been patched.\n     */\n    function queueActivatedComponent (vm) {\n      // setting _inactive to false here so that a render function can\n      // rely on checking whether it's in an inactive tree (e.g. router-view)\n      vm._inactive = false;\n      activatedChildren.push(vm);\n    }\n  \n    function callActivatedHooks (queue) {\n      for (var i = 0; i < queue.length; i++) {\n        queue[i]._inactive = true;\n        activateChildComponent(queue[i], true /* true */);\n      }\n    }\n  \n    /**\n     * Push a watcher into the watcher queue.\n     * Jobs with duplicate IDs will be skipped unless it's\n     * pushed when the queue is being flushed.\n     */\n    function queueWatcher (watcher) {\n      var id = watcher.id;\n      if (has[id] == null) {\n        has[id] = true;\n        if (!flushing) {\n          queue.push(watcher);\n        } else {\n          // if already flushing, splice the watcher based on its id\n          // if already past its id, it will be run next immediately.\n          var i = queue.length - 1;\n          while (i > index && queue[i].id > watcher.id) {\n            i--;\n          }\n          queue.splice(i + 1, 0, watcher);\n        }\n        // queue the flush\n        if (!waiting) {\n          waiting = true;\n  \n          if (!config.async) {\n            flushSchedulerQueue();\n            return\n          }\n          nextTick(flushSchedulerQueue);\n        }\n      }\n    }\n  \n    /*  */\n  \n  \n  \n    var uid$2 = 0;\n  \n    /**\n     * A watcher parses an expression, collects dependencies,\n     * and fires callback when the expression value changes.\n     * This is used for both the $watch() api and directives.\n     */\n    var Watcher = function Watcher (\n      vm,\n      expOrFn,\n      cb,\n      options,\n      isRenderWatcher\n    ) {\n      this.vm = vm;\n      if (isRenderWatcher) {\n        vm._watcher = this;\n      }\n      vm._watchers.push(this);\n      // options\n      if (options) {\n        this.deep = !!options.deep;\n        this.user = !!options.user;\n        this.lazy = !!options.lazy;\n        this.sync = !!options.sync;\n        this.before = options.before;\n      } else {\n        this.deep = this.user = this.lazy = this.sync = false;\n      }\n      this.cb = cb;\n      this.id = ++uid$2; // uid for batching\n      this.active = true;\n      this.dirty = this.lazy; // for lazy watchers\n      this.deps = [];\n      this.newDeps = [];\n      this.depIds = new _Set();\n      this.newDepIds = new _Set();\n      this.expression = expOrFn.toString();\n      // parse expression for getter\n      if (typeof expOrFn === 'function') {\n        this.getter = expOrFn;\n      } else {\n        this.getter = parsePath(expOrFn);\n        if (!this.getter) {\n          this.getter = noop;\n          warn(\n            \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n            'Watcher only accepts simple dot-delimited paths. ' +\n            'For full control, use a function instead.',\n            vm\n          );\n        }\n      }\n      this.value = this.lazy\n        ? undefined\n        : this.get();\n    };\n  \n    /**\n     * Evaluate the getter, and re-collect dependencies.\n     */\n    Watcher.prototype.get = function get () {\n      pushTarget(this);\n      var value;\n      var vm = this.vm;\n      try {\n        value = this.getter.call(vm, vm);\n      } catch (e) {\n        if (this.user) {\n          handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        } else {\n          throw e\n        }\n      } finally {\n        // \"touch\" every property so they are all tracked as\n        // dependencies for deep watching\n        if (this.deep) {\n          traverse(value);\n        }\n        popTarget();\n        this.cleanupDeps();\n      }\n      return value\n    };\n  \n    /**\n     * Add a dependency to this directive.\n     */\n    Watcher.prototype.addDep = function addDep (dep) {\n      var id = dep.id;\n      if (!this.newDepIds.has(id)) {\n        this.newDepIds.add(id);\n        this.newDeps.push(dep);\n        if (!this.depIds.has(id)) {\n          dep.addSub(this);\n        }\n      }\n    };\n  \n    /**\n     * Clean up for dependency collection.\n     */\n    Watcher.prototype.cleanupDeps = function cleanupDeps () {\n      var i = this.deps.length;\n      while (i--) {\n        var dep = this.deps[i];\n        if (!this.newDepIds.has(dep.id)) {\n          dep.removeSub(this);\n        }\n      }\n      var tmp = this.depIds;\n      this.depIds = this.newDepIds;\n      this.newDepIds = tmp;\n      this.newDepIds.clear();\n      tmp = this.deps;\n      this.deps = this.newDeps;\n      this.newDeps = tmp;\n      this.newDeps.length = 0;\n    };\n  \n    /**\n     * Subscriber interface.\n     * Will be called when a dependency changes.\n     */\n    Watcher.prototype.update = function update () {\n      /* istanbul ignore else */\n      if (this.lazy) {\n        this.dirty = true;\n      } else if (this.sync) {\n        this.run();\n      } else {\n        queueWatcher(this);\n      }\n    };\n  \n    /**\n     * Scheduler job interface.\n     * Will be called by the scheduler.\n     */\n    Watcher.prototype.run = function run () {\n      if (this.active) {\n        var value = this.get();\n        if (\n          value !== this.value ||\n          // Deep watchers and watchers on Object/Arrays should fire even\n          // when the value is the same, because the value may\n          // have mutated.\n          isObject(value) ||\n          this.deep\n        ) {\n          // set new value\n          var oldValue = this.value;\n          this.value = value;\n          if (this.user) {\n            var info = \"callback for watcher \\\"\" + (this.expression) + \"\\\"\";\n            invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n          } else {\n            this.cb.call(this.vm, value, oldValue);\n          }\n        }\n      }\n    };\n  \n    /**\n     * Evaluate the value of the watcher.\n     * This only gets called for lazy watchers.\n     */\n    Watcher.prototype.evaluate = function evaluate () {\n      this.value = this.get();\n      this.dirty = false;\n    };\n  \n    /**\n     * Depend on all deps collected by this watcher.\n     */\n    Watcher.prototype.depend = function depend () {\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].depend();\n      }\n    };\n  \n    /**\n     * Remove self from all dependencies' subscriber list.\n     */\n    Watcher.prototype.teardown = function teardown () {\n      if (this.active) {\n        // remove self from vm's watcher list\n        // this is a somewhat expensive operation so we skip it\n        // if the vm is being destroyed.\n        if (!this.vm._isBeingDestroyed) {\n          remove(this.vm._watchers, this);\n        }\n        var i = this.deps.length;\n        while (i--) {\n          this.deps[i].removeSub(this);\n        }\n        this.active = false;\n      }\n    };\n  \n    /*  */\n  \n    var sharedPropertyDefinition = {\n      enumerable: true,\n      configurable: true,\n      get: noop,\n      set: noop\n    };\n  \n    function proxy (target, sourceKey, key) {\n      sharedPropertyDefinition.get = function proxyGetter () {\n        return this[sourceKey][key]\n      };\n      sharedPropertyDefinition.set = function proxySetter (val) {\n        this[sourceKey][key] = val;\n      };\n      Object.defineProperty(target, key, sharedPropertyDefinition);\n    }\n  \n    function initState (vm) {\n      vm._watchers = [];\n      var opts = vm.$options;\n      if (opts.props) { initProps(vm, opts.props); }\n      if (opts.methods) { initMethods(vm, opts.methods); }\n      if (opts.data) {\n        initData(vm);\n      } else {\n        observe(vm._data = {}, true /* asRootData */);\n      }\n      if (opts.computed) { initComputed(vm, opts.computed); }\n      if (opts.watch && opts.watch !== nativeWatch) {\n        initWatch(vm, opts.watch);\n      }\n    }\n  \n    function initProps (vm, propsOptions) {\n      var propsData = vm.$options.propsData || {};\n      var props = vm._props = {};\n      // cache prop keys so that future props updates can iterate using Array\n      // instead of dynamic object key enumeration.\n      var keys = vm.$options._propKeys = [];\n      var isRoot = !vm.$parent;\n      // root instance props should be converted\n      if (!isRoot) {\n        toggleObserving(false);\n      }\n      var loop = function ( key ) {\n        keys.push(key);\n        var value = validateProp(key, propsOptions, propsData, vm);\n        /* istanbul ignore else */\n        {\n          var hyphenatedKey = hyphenate(key);\n          if (isReservedAttribute(hyphenatedKey) ||\n              config.isReservedAttr(hyphenatedKey)) {\n            warn(\n              (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n              vm\n            );\n          }\n          defineReactive$$1(props, key, value, function () {\n            if (!isRoot && !isUpdatingChildComponent) {\n              warn(\n                \"Avoid mutating a prop directly since the value will be \" +\n                \"overwritten whenever the parent component re-renders. \" +\n                \"Instead, use a data or computed property based on the prop's \" +\n                \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            }\n          });\n        }\n        // static props are already proxied on the component's prototype\n        // during Vue.extend(). We only need to proxy props defined at\n        // instantiation here.\n        if (!(key in vm)) {\n          proxy(vm, \"_props\", key);\n        }\n      };\n  \n      for (var key in propsOptions) loop( key );\n      toggleObserving(true);\n    }\n  \n    function initData (vm) {\n      var data = vm.$options.data;\n      data = vm._data = typeof data === 'function'\n        ? getData(data, vm)\n        : data || {};\n      if (!isPlainObject(data)) {\n        data = {};\n        warn(\n          'data functions should return an object:\\n' +\n          'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n          vm\n        );\n      }\n      // proxy data on instance\n      var keys = Object.keys(data);\n      var props = vm.$options.props;\n      var methods = vm.$options.methods;\n      var i = keys.length;\n      while (i--) {\n        var key = keys[i];\n        {\n          if (methods && hasOwn(methods, key)) {\n            warn(\n              (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n              vm\n            );\n          }\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n            \"Use prop default value instead.\",\n            vm\n          );\n        } else if (!isReserved(key)) {\n          proxy(vm, \"_data\", key);\n        }\n      }\n      // observe data\n      observe(data, true /* asRootData */);\n    }\n  \n    function getData (data, vm) {\n      // #7573 disable dep collection when invoking data getters\n      pushTarget();\n      try {\n        return data.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, \"data()\");\n        return {}\n      } finally {\n        popTarget();\n      }\n    }\n  \n    var computedWatcherOptions = { lazy: true };\n  \n    function initComputed (vm, computed) {\n      // $flow-disable-line\n      var watchers = vm._computedWatchers = Object.create(null);\n      // computed properties are just getters during SSR\n      var isSSR = isServerRendering();\n  \n      for (var key in computed) {\n        var userDef = computed[key];\n        var getter = typeof userDef === 'function' ? userDef : userDef.get;\n        if (getter == null) {\n          warn(\n            (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n            vm\n          );\n        }\n  \n        if (!isSSR) {\n          // create internal watcher for the computed property.\n          watchers[key] = new Watcher(\n            vm,\n            getter || noop,\n            noop,\n            computedWatcherOptions\n          );\n        }\n  \n        // component-defined computed properties are already defined on the\n        // component prototype. We only need to define computed properties defined\n        // at instantiation here.\n        if (!(key in vm)) {\n          defineComputed(vm, key, userDef);\n        } else {\n          if (key in vm.$data) {\n            warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n          } else if (vm.$options.props && key in vm.$options.props) {\n            warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n          } else if (vm.$options.methods && key in vm.$options.methods) {\n            warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a method.\"), vm);\n          }\n        }\n      }\n    }\n  \n    function defineComputed (\n      target,\n      key,\n      userDef\n    ) {\n      var shouldCache = !isServerRendering();\n      if (typeof userDef === 'function') {\n        sharedPropertyDefinition.get = shouldCache\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef);\n        sharedPropertyDefinition.set = noop;\n      } else {\n        sharedPropertyDefinition.get = userDef.get\n          ? shouldCache && userDef.cache !== false\n            ? createComputedGetter(key)\n            : createGetterInvoker(userDef.get)\n          : noop;\n        sharedPropertyDefinition.set = userDef.set || noop;\n      }\n      if (sharedPropertyDefinition.set === noop) {\n        sharedPropertyDefinition.set = function () {\n          warn(\n            (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n            this\n          );\n        };\n      }\n      Object.defineProperty(target, key, sharedPropertyDefinition);\n    }\n  \n    function createComputedGetter (key) {\n      return function computedGetter () {\n        var watcher = this._computedWatchers && this._computedWatchers[key];\n        if (watcher) {\n          if (watcher.dirty) {\n            watcher.evaluate();\n          }\n          if (Dep.target) {\n            watcher.depend();\n          }\n          return watcher.value\n        }\n      }\n    }\n  \n    function createGetterInvoker(fn) {\n      return function computedGetter () {\n        return fn.call(this, this)\n      }\n    }\n  \n    function initMethods (vm, methods) {\n      var props = vm.$options.props;\n      for (var key in methods) {\n        {\n          if (typeof methods[key] !== 'function') {\n            warn(\n              \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n              \"Did you reference the function correctly?\",\n              vm\n            );\n          }\n          if (props && hasOwn(props, key)) {\n            warn(\n              (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n              vm\n            );\n          }\n          if ((key in vm) && isReserved(key)) {\n            warn(\n              \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n              \"Avoid defining component methods that start with _ or $.\"\n            );\n          }\n        }\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n      }\n    }\n  \n    function initWatch (vm, watch) {\n      for (var key in watch) {\n        var handler = watch[key];\n        if (Array.isArray(handler)) {\n          for (var i = 0; i < handler.length; i++) {\n            createWatcher(vm, key, handler[i]);\n          }\n        } else {\n          createWatcher(vm, key, handler);\n        }\n      }\n    }\n  \n    function createWatcher (\n      vm,\n      expOrFn,\n      handler,\n      options\n    ) {\n      if (isPlainObject(handler)) {\n        options = handler;\n        handler = handler.handler;\n      }\n      if (typeof handler === 'string') {\n        handler = vm[handler];\n      }\n      return vm.$watch(expOrFn, handler, options)\n    }\n  \n    function stateMixin (Vue) {\n      // flow somehow has problems with directly declared definition object\n      // when using Object.defineProperty, so we have to procedurally build up\n      // the object here.\n      var dataDef = {};\n      dataDef.get = function () { return this._data };\n      var propsDef = {};\n      propsDef.get = function () { return this._props };\n      {\n        dataDef.set = function () {\n          warn(\n            'Avoid replacing instance root $data. ' +\n            'Use nested data properties instead.',\n            this\n          );\n        };\n        propsDef.set = function () {\n          warn(\"$props is readonly.\", this);\n        };\n      }\n      Object.defineProperty(Vue.prototype, '$data', dataDef);\n      Object.defineProperty(Vue.prototype, '$props', propsDef);\n  \n      Vue.prototype.$set = set;\n      Vue.prototype.$delete = del;\n  \n      Vue.prototype.$watch = function (\n        expOrFn,\n        cb,\n        options\n      ) {\n        var vm = this;\n        if (isPlainObject(cb)) {\n          return createWatcher(vm, expOrFn, cb, options)\n        }\n        options = options || {};\n        options.user = true;\n        var watcher = new Watcher(vm, expOrFn, cb, options);\n        if (options.immediate) {\n          var info = \"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\";\n          pushTarget();\n          invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n          popTarget();\n        }\n        return function unwatchFn () {\n          watcher.teardown();\n        }\n      };\n    }\n  \n    /*  */\n  \n    var uid$3 = 0;\n  \n    function initMixin (Vue) {\n      Vue.prototype._init = function (options) {\n        var vm = this;\n        // a uid\n        vm._uid = uid$3++;\n  \n        var startTag, endTag;\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          startTag = \"vue-perf-start:\" + (vm._uid);\n          endTag = \"vue-perf-end:\" + (vm._uid);\n          mark(startTag);\n        }\n  \n        // a flag to avoid this being observed\n        vm._isVue = true;\n        // merge options\n        if (options && options._isComponent) {\n          // optimize internal component instantiation\n          // since dynamic options merging is pretty slow, and none of the\n          // internal component options needs special treatment.\n          initInternalComponent(vm, options);\n        } else {\n          vm.$options = mergeOptions(\n            resolveConstructorOptions(vm.constructor),\n            options || {},\n            vm\n          );\n        }\n        /* istanbul ignore else */\n        {\n          initProxy(vm);\n        }\n        // expose real self\n        vm._self = vm;\n        initLifecycle(vm);\n        initEvents(vm);\n        initRender(vm);\n        callHook(vm, 'beforeCreate');\n        initInjections(vm); // resolve injections before data/props\n        initState(vm);\n        initProvide(vm); // resolve provide after data/props\n        callHook(vm, 'created');\n  \n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          vm._name = formatComponentName(vm, false);\n          mark(endTag);\n          measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n        }\n  \n        if (vm.$options.el) {\n          vm.$mount(vm.$options.el);\n        }\n      };\n    }\n  \n    function initInternalComponent (vm, options) {\n      var opts = vm.$options = Object.create(vm.constructor.options);\n      // doing this because it's faster than dynamic enumeration.\n      var parentVnode = options._parentVnode;\n      opts.parent = options.parent;\n      opts._parentVnode = parentVnode;\n  \n      var vnodeComponentOptions = parentVnode.componentOptions;\n      opts.propsData = vnodeComponentOptions.propsData;\n      opts._parentListeners = vnodeComponentOptions.listeners;\n      opts._renderChildren = vnodeComponentOptions.children;\n      opts._componentTag = vnodeComponentOptions.tag;\n  \n      if (options.render) {\n        opts.render = options.render;\n        opts.staticRenderFns = options.staticRenderFns;\n      }\n    }\n  \n    function resolveConstructorOptions (Ctor) {\n      var options = Ctor.options;\n      if (Ctor.super) {\n        var superOptions = resolveConstructorOptions(Ctor.super);\n        var cachedSuperOptions = Ctor.superOptions;\n        if (superOptions !== cachedSuperOptions) {\n          // super option changed,\n          // need to resolve new options.\n          Ctor.superOptions = superOptions;\n          // check if there are any late-modified/attached options (#4976)\n          var modifiedOptions = resolveModifiedOptions(Ctor);\n          // update base extend options\n          if (modifiedOptions) {\n            extend(Ctor.extendOptions, modifiedOptions);\n          }\n          options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n          if (options.name) {\n            options.components[options.name] = Ctor;\n          }\n        }\n      }\n      return options\n    }\n  \n    function resolveModifiedOptions (Ctor) {\n      var modified;\n      var latest = Ctor.options;\n      var sealed = Ctor.sealedOptions;\n      for (var key in latest) {\n        if (latest[key] !== sealed[key]) {\n          if (!modified) { modified = {}; }\n          modified[key] = latest[key];\n        }\n      }\n      return modified\n    }\n  \n    function Vue (options) {\n      if (!(this instanceof Vue)\n      ) {\n        warn('Vue is a constructor and should be called with the `new` keyword');\n      }\n      this._init(options);\n    }\n  \n    initMixin(Vue);\n    stateMixin(Vue);\n    eventsMixin(Vue);\n    lifecycleMixin(Vue);\n    renderMixin(Vue);\n  \n    /*  */\n  \n    function initUse (Vue) {\n      Vue.use = function (plugin) {\n        var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n        if (installedPlugins.indexOf(plugin) > -1) {\n          return this\n        }\n  \n        // additional parameters\n        var args = toArray(arguments, 1);\n        args.unshift(this);\n        if (typeof plugin.install === 'function') {\n          plugin.install.apply(plugin, args);\n        } else if (typeof plugin === 'function') {\n          plugin.apply(null, args);\n        }\n        installedPlugins.push(plugin);\n        return this\n      };\n    }\n  \n    /*  */\n  \n    function initMixin$1 (Vue) {\n      Vue.mixin = function (mixin) {\n        this.options = mergeOptions(this.options, mixin);\n        return this\n      };\n    }\n  \n    /*  */\n  \n    function initExtend (Vue) {\n      /**\n       * Each instance constructor, including Vue, has a unique\n       * cid. This enables us to create wrapped \"child\n       * constructors\" for prototypal inheritance and cache them.\n       */\n      Vue.cid = 0;\n      var cid = 1;\n  \n      /**\n       * Class inheritance\n       */\n      Vue.extend = function (extendOptions) {\n        extendOptions = extendOptions || {};\n        var Super = this;\n        var SuperId = Super.cid;\n        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n        if (cachedCtors[SuperId]) {\n          return cachedCtors[SuperId]\n        }\n  \n        var name = extendOptions.name || Super.options.name;\n        if (name) {\n          validateComponentName(name);\n        }\n  \n        var Sub = function VueComponent (options) {\n          this._init(options);\n        };\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.cid = cid++;\n        Sub.options = mergeOptions(\n          Super.options,\n          extendOptions\n        );\n        Sub['super'] = Super;\n  \n        // For props and computed properties, we define the proxy getters on\n        // the Vue instances at extension time, on the extended prototype. This\n        // avoids Object.defineProperty calls for each instance created.\n        if (Sub.options.props) {\n          initProps$1(Sub);\n        }\n        if (Sub.options.computed) {\n          initComputed$1(Sub);\n        }\n  \n        // allow further extension/mixin/plugin usage\n        Sub.extend = Super.extend;\n        Sub.mixin = Super.mixin;\n        Sub.use = Super.use;\n  \n        // create asset registers, so extended classes\n        // can have their private assets too.\n        ASSET_TYPES.forEach(function (type) {\n          Sub[type] = Super[type];\n        });\n        // enable recursive self-lookup\n        if (name) {\n          Sub.options.components[name] = Sub;\n        }\n  \n        // keep a reference to the super options at extension time.\n        // later at instantiation we can check if Super's options have\n        // been updated.\n        Sub.superOptions = Super.options;\n        Sub.extendOptions = extendOptions;\n        Sub.sealedOptions = extend({}, Sub.options);\n  \n        // cache constructor\n        cachedCtors[SuperId] = Sub;\n        return Sub\n      };\n    }\n  \n    function initProps$1 (Comp) {\n      var props = Comp.options.props;\n      for (var key in props) {\n        proxy(Comp.prototype, \"_props\", key);\n      }\n    }\n  \n    function initComputed$1 (Comp) {\n      var computed = Comp.options.computed;\n      for (var key in computed) {\n        defineComputed(Comp.prototype, key, computed[key]);\n      }\n    }\n  \n    /*  */\n  \n    function initAssetRegisters (Vue) {\n      /**\n       * Create asset registration methods.\n       */\n      ASSET_TYPES.forEach(function (type) {\n        Vue[type] = function (\n          id,\n          definition\n        ) {\n          if (!definition) {\n            return this.options[type + 's'][id]\n          } else {\n            /* istanbul ignore if */\n            if (type === 'component') {\n              validateComponentName(id);\n            }\n            if (type === 'component' && isPlainObject(definition)) {\n              definition.name = definition.name || id;\n              definition = this.options._base.extend(definition);\n            }\n            if (type === 'directive' && typeof definition === 'function') {\n              definition = { bind: definition, update: definition };\n            }\n            this.options[type + 's'][id] = definition;\n            return definition\n          }\n        };\n      });\n    }\n  \n    /*  */\n  \n  \n  \n  \n  \n    function getComponentName (opts) {\n      return opts && (opts.Ctor.options.name || opts.tag)\n    }\n  \n    function matches (pattern, name) {\n      if (Array.isArray(pattern)) {\n        return pattern.indexOf(name) > -1\n      } else if (typeof pattern === 'string') {\n        return pattern.split(',').indexOf(name) > -1\n      } else if (isRegExp(pattern)) {\n        return pattern.test(name)\n      }\n      /* istanbul ignore next */\n      return false\n    }\n  \n    function pruneCache (keepAliveInstance, filter) {\n      var cache = keepAliveInstance.cache;\n      var keys = keepAliveInstance.keys;\n      var _vnode = keepAliveInstance._vnode;\n      for (var key in cache) {\n        var entry = cache[key];\n        if (entry) {\n          var name = entry.name;\n          if (name && !filter(name)) {\n            pruneCacheEntry(cache, key, keys, _vnode);\n          }\n        }\n      }\n    }\n  \n    function pruneCacheEntry (\n      cache,\n      key,\n      keys,\n      current\n    ) {\n      var entry = cache[key];\n      if (entry && (!current || entry.tag !== current.tag)) {\n        entry.componentInstance.$destroy();\n      }\n      cache[key] = null;\n      remove(keys, key);\n    }\n  \n    var patternTypes = [String, RegExp, Array];\n  \n    var KeepAlive = {\n      name: 'keep-alive',\n      abstract: true,\n  \n      props: {\n        include: patternTypes,\n        exclude: patternTypes,\n        max: [String, Number]\n      },\n  \n      methods: {\n        cacheVNode: function cacheVNode() {\n          var ref = this;\n          var cache = ref.cache;\n          var keys = ref.keys;\n          var vnodeToCache = ref.vnodeToCache;\n          var keyToCache = ref.keyToCache;\n          if (vnodeToCache) {\n            var tag = vnodeToCache.tag;\n            var componentInstance = vnodeToCache.componentInstance;\n            var componentOptions = vnodeToCache.componentOptions;\n            cache[keyToCache] = {\n              name: getComponentName(componentOptions),\n              tag: tag,\n              componentInstance: componentInstance,\n            };\n            keys.push(keyToCache);\n            // prune oldest entry\n            if (this.max && keys.length > parseInt(this.max)) {\n              pruneCacheEntry(cache, keys[0], keys, this._vnode);\n            }\n            this.vnodeToCache = null;\n          }\n        }\n      },\n  \n      created: function created () {\n        this.cache = Object.create(null);\n        this.keys = [];\n      },\n  \n      destroyed: function destroyed () {\n        for (var key in this.cache) {\n          pruneCacheEntry(this.cache, key, this.keys);\n        }\n      },\n  \n      mounted: function mounted () {\n        var this$1 = this;\n  \n        this.cacheVNode();\n        this.$watch('include', function (val) {\n          pruneCache(this$1, function (name) { return matches(val, name); });\n        });\n        this.$watch('exclude', function (val) {\n          pruneCache(this$1, function (name) { return !matches(val, name); });\n        });\n      },\n  \n      updated: function updated () {\n        this.cacheVNode();\n      },\n  \n      render: function render () {\n        var slot = this.$slots.default;\n        var vnode = getFirstComponentChild(slot);\n        var componentOptions = vnode && vnode.componentOptions;\n        if (componentOptions) {\n          // check pattern\n          var name = getComponentName(componentOptions);\n          var ref = this;\n          var include = ref.include;\n          var exclude = ref.exclude;\n          if (\n            // not included\n            (include && (!name || !matches(include, name))) ||\n            // excluded\n            (exclude && name && matches(exclude, name))\n          ) {\n            return vnode\n          }\n  \n          var ref$1 = this;\n          var cache = ref$1.cache;\n          var keys = ref$1.keys;\n          var key = vnode.key == null\n            // same constructor may get registered as different local components\n            // so cid alone is not enough (#3269)\n            ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n            : vnode.key;\n          if (cache[key]) {\n            vnode.componentInstance = cache[key].componentInstance;\n            // make current key freshest\n            remove(keys, key);\n            keys.push(key);\n          } else {\n            // delay setting the cache until update\n            this.vnodeToCache = vnode;\n            this.keyToCache = key;\n          }\n  \n          vnode.data.keepAlive = true;\n        }\n        return vnode || (slot && slot[0])\n      }\n    };\n  \n    var builtInComponents = {\n      KeepAlive: KeepAlive\n    };\n  \n    /*  */\n  \n    function initGlobalAPI (Vue) {\n      // config\n      var configDef = {};\n      configDef.get = function () { return config; };\n      {\n        configDef.set = function () {\n          warn(\n            'Do not replace the Vue.config object, set individual fields instead.'\n          );\n        };\n      }\n      Object.defineProperty(Vue, 'config', configDef);\n  \n      // exposed util methods.\n      // NOTE: these are not considered part of the public API - avoid relying on\n      // them unless you are aware of the risk.\n      Vue.util = {\n        warn: warn,\n        extend: extend,\n        mergeOptions: mergeOptions,\n        defineReactive: defineReactive$$1\n      };\n  \n      Vue.set = set;\n      Vue.delete = del;\n      Vue.nextTick = nextTick;\n  \n      // 2.6 explicit observable API\n      Vue.observable = function (obj) {\n        observe(obj);\n        return obj\n      };\n  \n      Vue.options = Object.create(null);\n      ASSET_TYPES.forEach(function (type) {\n        Vue.options[type + 's'] = Object.create(null);\n      });\n  \n      // this is used to identify the \"base\" constructor to extend all plain-object\n      // components with in Weex's multi-instance scenarios.\n      Vue.options._base = Vue;\n  \n      extend(Vue.options.components, builtInComponents);\n  \n      initUse(Vue);\n      initMixin$1(Vue);\n      initExtend(Vue);\n      initAssetRegisters(Vue);\n    }\n  \n    initGlobalAPI(Vue);\n  \n    Object.defineProperty(Vue.prototype, '$isServer', {\n      get: isServerRendering\n    });\n  \n    Object.defineProperty(Vue.prototype, '$ssrContext', {\n      get: function get () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext\n      }\n    });\n  \n    // expose FunctionalRenderContext for ssr runtime helper installation\n    Object.defineProperty(Vue, 'FunctionalRenderContext', {\n      value: FunctionalRenderContext\n    });\n  \n    Vue.version = '2.6.14';\n  \n    /*  */\n  \n    // these are reserved for web because they are directly compiled away\n    // during template compilation\n    var isReservedAttr = makeMap('style,class');\n  \n    // attributes that should be using props for binding\n    var acceptValue = makeMap('input,textarea,option,select,progress');\n    var mustUseProp = function (tag, type, attr) {\n      return (\n        (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n        (attr === 'selected' && tag === 'option') ||\n        (attr === 'checked' && tag === 'input') ||\n        (attr === 'muted' && tag === 'video')\n      )\n    };\n  \n    var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  \n    var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n  \n    var convertEnumeratedValue = function (key, value) {\n      return isFalsyAttrValue(value) || value === 'false'\n        ? 'false'\n        // allow arbitrary string value for contenteditable\n        : key === 'contenteditable' && isValidContentEditableValue(value)\n          ? value\n          : 'true'\n    };\n  \n    var isBooleanAttr = makeMap(\n      'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n      'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n      'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n      'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n      'required,reversed,scoped,seamless,selected,sortable,' +\n      'truespeed,typemustmatch,visible'\n    );\n  \n    var xlinkNS = 'http://www.w3.org/1999/xlink';\n  \n    var isXlink = function (name) {\n      return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n    };\n  \n    var getXlinkProp = function (name) {\n      return isXlink(name) ? name.slice(6, name.length) : ''\n    };\n  \n    var isFalsyAttrValue = function (val) {\n      return val == null || val === false\n    };\n  \n    /*  */\n  \n    function genClassForVnode (vnode) {\n      var data = vnode.data;\n      var parentNode = vnode;\n      var childNode = vnode;\n      while (isDef(childNode.componentInstance)) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data) {\n          data = mergeClassData(childNode.data, data);\n        }\n      }\n      while (isDef(parentNode = parentNode.parent)) {\n        if (parentNode && parentNode.data) {\n          data = mergeClassData(data, parentNode.data);\n        }\n      }\n      return renderClass(data.staticClass, data.class)\n    }\n  \n    function mergeClassData (child, parent) {\n      return {\n        staticClass: concat(child.staticClass, parent.staticClass),\n        class: isDef(child.class)\n          ? [child.class, parent.class]\n          : parent.class\n      }\n    }\n  \n    function renderClass (\n      staticClass,\n      dynamicClass\n    ) {\n      if (isDef(staticClass) || isDef(dynamicClass)) {\n        return concat(staticClass, stringifyClass(dynamicClass))\n      }\n      /* istanbul ignore next */\n      return ''\n    }\n  \n    function concat (a, b) {\n      return a ? b ? (a + ' ' + b) : a : (b || '')\n    }\n  \n    function stringifyClass (value) {\n      if (Array.isArray(value)) {\n        return stringifyArray(value)\n      }\n      if (isObject(value)) {\n        return stringifyObject(value)\n      }\n      if (typeof value === 'string') {\n        return value\n      }\n      /* istanbul ignore next */\n      return ''\n    }\n  \n    function stringifyArray (value) {\n      var res = '';\n      var stringified;\n      for (var i = 0, l = value.length; i < l; i++) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          if (res) { res += ' '; }\n          res += stringified;\n        }\n      }\n      return res\n    }\n  \n    function stringifyObject (value) {\n      var res = '';\n      for (var key in value) {\n        if (value[key]) {\n          if (res) { res += ' '; }\n          res += key;\n        }\n      }\n      return res\n    }\n  \n    /*  */\n  \n    var namespaceMap = {\n      svg: 'http://www.w3.org/2000/svg',\n      math: 'http://www.w3.org/1998/Math/MathML'\n    };\n  \n    var isHTMLTag = makeMap(\n      'html,body,base,head,link,meta,style,title,' +\n      'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n      'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n      'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n      's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n      'embed,object,param,source,canvas,script,noscript,del,ins,' +\n      'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n      'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n      'output,progress,select,textarea,' +\n      'details,dialog,menu,menuitem,summary,' +\n      'content,element,shadow,template,blockquote,iframe,tfoot'\n    );\n  \n    // this map is intentionally selective, only covering SVG elements that may\n    // contain child elements.\n    var isSVG = makeMap(\n      'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n      'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n      'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n      true\n    );\n  \n    var isPreTag = function (tag) { return tag === 'pre'; };\n  \n    var isReservedTag = function (tag) {\n      return isHTMLTag(tag) || isSVG(tag)\n    };\n  \n    function getTagNamespace (tag) {\n      if (isSVG(tag)) {\n        return 'svg'\n      }\n      // basic support for MathML\n      // note it doesn't support other MathML elements being component roots\n      if (tag === 'math') {\n        return 'math'\n      }\n    }\n  \n    var unknownElementCache = Object.create(null);\n    function isUnknownElement (tag) {\n      /* istanbul ignore if */\n      if (!inBrowser) {\n        return true\n      }\n      if (isReservedTag(tag)) {\n        return false\n      }\n      tag = tag.toLowerCase();\n      /* istanbul ignore if */\n      if (unknownElementCache[tag] != null) {\n        return unknownElementCache[tag]\n      }\n      var el = document.createElement(tag);\n      if (tag.indexOf('-') > -1) {\n        // http://stackoverflow.com/a/28210364/1070244\n        return (unknownElementCache[tag] = (\n          el.constructor === window.HTMLUnknownElement ||\n          el.constructor === window.HTMLElement\n        ))\n      } else {\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n      }\n    }\n  \n    var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  \n    /*  */\n  \n    /**\n     * Query an element selector if it's not an element already.\n     */\n    function query (el) {\n      if (typeof el === 'string') {\n        var selected = document.querySelector(el);\n        if (!selected) {\n          warn(\n            'Cannot find element: ' + el\n          );\n          return document.createElement('div')\n        }\n        return selected\n      } else {\n        return el\n      }\n    }\n  \n    /*  */\n  \n    function createElement$1 (tagName, vnode) {\n      var elm = document.createElement(tagName);\n      if (tagName !== 'select') {\n        return elm\n      }\n      // false or null will remove the attribute but undefined will not\n      if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n        elm.setAttribute('multiple', 'multiple');\n      }\n      return elm\n    }\n  \n    function createElementNS (namespace, tagName) {\n      return document.createElementNS(namespaceMap[namespace], tagName)\n    }\n  \n    function createTextNode (text) {\n      return document.createTextNode(text)\n    }\n  \n    function createComment (text) {\n      return document.createComment(text)\n    }\n  \n    function insertBefore (parentNode, newNode, referenceNode) {\n      parentNode.insertBefore(newNode, referenceNode);\n    }\n  \n    function removeChild (node, child) {\n      node.removeChild(child);\n    }\n  \n    function appendChild (node, child) {\n      node.appendChild(child);\n    }\n  \n    function parentNode (node) {\n      return node.parentNode\n    }\n  \n    function nextSibling (node) {\n      return node.nextSibling\n    }\n  \n    function tagName (node) {\n      return node.tagName\n    }\n  \n    function setTextContent (node, text) {\n      node.textContent = text;\n    }\n  \n    function setStyleScope (node, scopeId) {\n      node.setAttribute(scopeId, '');\n    }\n  \n    var nodeOps = /*#__PURE__*/Object.freeze({\n      createElement: createElement$1,\n      createElementNS: createElementNS,\n      createTextNode: createTextNode,\n      createComment: createComment,\n      insertBefore: insertBefore,\n      removeChild: removeChild,\n      appendChild: appendChild,\n      parentNode: parentNode,\n      nextSibling: nextSibling,\n      tagName: tagName,\n      setTextContent: setTextContent,\n      setStyleScope: setStyleScope\n    });\n  \n    /*  */\n  \n    var ref = {\n      create: function create (_, vnode) {\n        registerRef(vnode);\n      },\n      update: function update (oldVnode, vnode) {\n        if (oldVnode.data.ref !== vnode.data.ref) {\n          registerRef(oldVnode, true);\n          registerRef(vnode);\n        }\n      },\n      destroy: function destroy (vnode) {\n        registerRef(vnode, true);\n      }\n    };\n  \n    function registerRef (vnode, isRemoval) {\n      var key = vnode.data.ref;\n      if (!isDef(key)) { return }\n  \n      var vm = vnode.context;\n      var ref = vnode.componentInstance || vnode.elm;\n      var refs = vm.$refs;\n      if (isRemoval) {\n        if (Array.isArray(refs[key])) {\n          remove(refs[key], ref);\n        } else if (refs[key] === ref) {\n          refs[key] = undefined;\n        }\n      } else {\n        if (vnode.data.refInFor) {\n          if (!Array.isArray(refs[key])) {\n            refs[key] = [ref];\n          } else if (refs[key].indexOf(ref) < 0) {\n            // $flow-disable-line\n            refs[key].push(ref);\n          }\n        } else {\n          refs[key] = ref;\n        }\n      }\n    }\n  \n    /**\n     * Virtual DOM patching algorithm based on Snabbdom by\n     * Simon Friis Vindum (@paldepind)\n     * Licensed under the MIT License\n     * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n     *\n     * modified by Evan You (@yyx990803)\n     *\n     * Not type-checking this because this file is perf-critical and the cost\n     * of making flow understand it is not worth it.\n     */\n  \n    var emptyNode = new VNode('', {}, []);\n  \n    var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n  \n    function sameVnode (a, b) {\n      return (\n        a.key === b.key &&\n        a.asyncFactory === b.asyncFactory && (\n          (\n            a.tag === b.tag &&\n            a.isComment === b.isComment &&\n            isDef(a.data) === isDef(b.data) &&\n            sameInputType(a, b)\n          ) || (\n            isTrue(a.isAsyncPlaceholder) &&\n            isUndef(b.asyncFactory.error)\n          )\n        )\n      )\n    }\n  \n    function sameInputType (a, b) {\n      if (a.tag !== 'input') { return true }\n      var i;\n      var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n      var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n      return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n    }\n  \n    function createKeyToOldIdx (children, beginIdx, endIdx) {\n      var i, key;\n      var map = {};\n      for (i = beginIdx; i <= endIdx; ++i) {\n        key = children[i].key;\n        if (isDef(key)) { map[key] = i; }\n      }\n      return map\n    }\n  \n    function createPatchFunction (backend) {\n      var i, j;\n      var cbs = {};\n  \n      var modules = backend.modules;\n      var nodeOps = backend.nodeOps;\n  \n      for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n          if (isDef(modules[j][hooks[i]])) {\n            cbs[hooks[i]].push(modules[j][hooks[i]]);\n          }\n        }\n      }\n  \n      function emptyNodeAt (elm) {\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n      }\n  \n      function createRmCb (childElm, listeners) {\n        function remove$$1 () {\n          if (--remove$$1.listeners === 0) {\n            removeNode(childElm);\n          }\n        }\n        remove$$1.listeners = listeners;\n        return remove$$1\n      }\n  \n      function removeNode (el) {\n        var parent = nodeOps.parentNode(el);\n        // element may have already been removed due to v-html / v-text\n        if (isDef(parent)) {\n          nodeOps.removeChild(parent, el);\n        }\n      }\n  \n      function isUnknownElement$$1 (vnode, inVPre) {\n        return (\n          !inVPre &&\n          !vnode.ns &&\n          !(\n            config.ignoredElements.length &&\n            config.ignoredElements.some(function (ignore) {\n              return isRegExp(ignore)\n                ? ignore.test(vnode.tag)\n                : ignore === vnode.tag\n            })\n          ) &&\n          config.isUnknownElement(vnode.tag)\n        )\n      }\n  \n      var creatingElmInVPre = 0;\n  \n      function createElm (\n        vnode,\n        insertedVnodeQueue,\n        parentElm,\n        refElm,\n        nested,\n        ownerArray,\n        index\n      ) {\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n          // This vnode was used in a previous render!\n          // now it's used as a new node, overwriting its elm would cause\n          // potential patch errors down the road when it's used as an insertion\n          // reference node. Instead, we clone the node on-demand before creating\n          // associated DOM element for it.\n          vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n  \n        vnode.isRootInsert = !nested; // for transition enter check\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n          return\n        }\n  \n        var data = vnode.data;\n        var children = vnode.children;\n        var tag = vnode.tag;\n        if (isDef(tag)) {\n          {\n            if (data && data.pre) {\n              creatingElmInVPre++;\n            }\n            if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n              warn(\n                'Unknown custom element: <' + tag + '> - did you ' +\n                'register the component correctly? For recursive components, ' +\n                'make sure to provide the \"name\" option.',\n                vnode.context\n              );\n            }\n          }\n  \n          vnode.elm = vnode.ns\n            ? nodeOps.createElementNS(vnode.ns, tag)\n            : nodeOps.createElement(tag, vnode);\n          setScope(vnode);\n  \n          /* istanbul ignore if */\n          {\n            createChildren(vnode, children, insertedVnodeQueue);\n            if (isDef(data)) {\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n            }\n            insert(parentElm, vnode.elm, refElm);\n          }\n  \n          if (data && data.pre) {\n            creatingElmInVPre--;\n          }\n        } else if (isTrue(vnode.isComment)) {\n          vnode.elm = nodeOps.createComment(vnode.text);\n          insert(parentElm, vnode.elm, refElm);\n        } else {\n          vnode.elm = nodeOps.createTextNode(vnode.text);\n          insert(parentElm, vnode.elm, refElm);\n        }\n      }\n  \n      function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n        var i = vnode.data;\n        if (isDef(i)) {\n          var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n          if (isDef(i = i.hook) && isDef(i = i.init)) {\n            i(vnode, false /* hydrating */);\n          }\n          // after calling the init hook, if the vnode is a child component\n          // it should've created a child instance and mounted it. the child\n          // component also has set the placeholder vnode's elm.\n          // in that case we can just return the element and be done.\n          if (isDef(vnode.componentInstance)) {\n            initComponent(vnode, insertedVnodeQueue);\n            insert(parentElm, vnode.elm, refElm);\n            if (isTrue(isReactivated)) {\n              reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n            }\n            return true\n          }\n        }\n      }\n  \n      function initComponent (vnode, insertedVnodeQueue) {\n        if (isDef(vnode.data.pendingInsert)) {\n          insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n          vnode.data.pendingInsert = null;\n        }\n        vnode.elm = vnode.componentInstance.$el;\n        if (isPatchable(vnode)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n          setScope(vnode);\n        } else {\n          // empty component root.\n          // skip all element-related modules except for ref (#3455)\n          registerRef(vnode);\n          // make sure to invoke the insert hook\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n  \n      function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n        var i;\n        // hack for #4339: a reactivated component with inner transition\n        // does not trigger because the inner node's created hooks are not called\n        // again. It's not ideal to involve module-specific logic in here but\n        // there doesn't seem to be a better way to do it.\n        var innerNode = vnode;\n        while (innerNode.componentInstance) {\n          innerNode = innerNode.componentInstance._vnode;\n          if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n            for (i = 0; i < cbs.activate.length; ++i) {\n              cbs.activate[i](emptyNode, innerNode);\n            }\n            insertedVnodeQueue.push(innerNode);\n            break\n          }\n        }\n        // unlike a newly created component,\n        // a reactivated keep-alive component doesn't insert itself\n        insert(parentElm, vnode.elm, refElm);\n      }\n  \n      function insert (parent, elm, ref$$1) {\n        if (isDef(parent)) {\n          if (isDef(ref$$1)) {\n            if (nodeOps.parentNode(ref$$1) === parent) {\n              nodeOps.insertBefore(parent, elm, ref$$1);\n            }\n          } else {\n            nodeOps.appendChild(parent, elm);\n          }\n        }\n      }\n  \n      function createChildren (vnode, children, insertedVnodeQueue) {\n        if (Array.isArray(children)) {\n          {\n            checkDuplicateKeys(children);\n          }\n          for (var i = 0; i < children.length; ++i) {\n            createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n          }\n        } else if (isPrimitive(vnode.text)) {\n          nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n        }\n      }\n  \n      function isPatchable (vnode) {\n        while (vnode.componentInstance) {\n          vnode = vnode.componentInstance._vnode;\n        }\n        return isDef(vnode.tag)\n      }\n  \n      function invokeCreateHooks (vnode, insertedVnodeQueue) {\n        for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n          cbs.create[i$1](emptyNode, vnode);\n        }\n        i = vnode.data.hook; // Reuse variable\n        if (isDef(i)) {\n          if (isDef(i.create)) { i.create(emptyNode, vnode); }\n          if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n        }\n      }\n  \n      // set scope id attribute for scoped CSS.\n      // this is implemented as a special case to avoid the overhead\n      // of going through the normal attribute patching process.\n      function setScope (vnode) {\n        var i;\n        if (isDef(i = vnode.fnScopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        } else {\n          var ancestor = vnode;\n          while (ancestor) {\n            if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n              nodeOps.setStyleScope(vnode.elm, i);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n        // for slot content they should also get the scopeId from the host instance.\n        if (isDef(i = activeInstance) &&\n          i !== vnode.context &&\n          i !== vnode.fnContext &&\n          isDef(i = i.$options._scopeId)\n        ) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n      }\n  \n      function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n          createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n        }\n      }\n  \n      function invokeDestroyHook (vnode) {\n        var i, j;\n        var data = vnode.data;\n        if (isDef(data)) {\n          if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n          for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n        }\n        if (isDef(i = vnode.children)) {\n          for (j = 0; j < vnode.children.length; ++j) {\n            invokeDestroyHook(vnode.children[j]);\n          }\n        }\n      }\n  \n      function removeVnodes (vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n          var ch = vnodes[startIdx];\n          if (isDef(ch)) {\n            if (isDef(ch.tag)) {\n              removeAndInvokeRemoveHook(ch);\n              invokeDestroyHook(ch);\n            } else { // Text node\n              removeNode(ch.elm);\n            }\n          }\n        }\n      }\n  \n      function removeAndInvokeRemoveHook (vnode, rm) {\n        if (isDef(rm) || isDef(vnode.data)) {\n          var i;\n          var listeners = cbs.remove.length + 1;\n          if (isDef(rm)) {\n            // we have a recursively passed down rm callback\n            // increase the listeners count\n            rm.listeners += listeners;\n          } else {\n            // directly removing\n            rm = createRmCb(vnode.elm, listeners);\n          }\n          // recursively invoke hooks on child component root node\n          if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n            removeAndInvokeRemoveHook(i, rm);\n          }\n          for (i = 0; i < cbs.remove.length; ++i) {\n            cbs.remove[i](vnode, rm);\n          }\n          if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n            i(vnode, rm);\n          } else {\n            rm();\n          }\n        } else {\n          removeNode(vnode.elm);\n        }\n      }\n  \n      function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n        var oldStartIdx = 0;\n        var newStartIdx = 0;\n        var oldEndIdx = oldCh.length - 1;\n        var oldStartVnode = oldCh[0];\n        var oldEndVnode = oldCh[oldEndIdx];\n        var newEndIdx = newCh.length - 1;\n        var newStartVnode = newCh[0];\n        var newEndVnode = newCh[newEndIdx];\n        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n  \n        // removeOnly is a special flag used only by <transition-group>\n        // to ensure removed elements stay in correct relative positions\n        // during leaving transitions\n        var canMove = !removeOnly;\n  \n        {\n          checkDuplicateKeys(newCh);\n        }\n  \n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n          if (isUndef(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n          } else if (isUndef(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n          } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n          } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n          } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n          } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n            idxInOld = isDef(newStartVnode.key)\n              ? oldKeyToIdx[newStartVnode.key]\n              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n            if (isUndef(idxInOld)) { // New element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            } else {\n              vnodeToMove = oldCh[idxInOld];\n              if (sameVnode(vnodeToMove, newStartVnode)) {\n                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                oldCh[idxInOld] = undefined;\n                canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n              } else {\n                // same key but different element. treat as new element\n                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n              }\n            }\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n        if (oldStartIdx > oldEndIdx) {\n          refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n          addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        } else if (newStartIdx > newEndIdx) {\n          removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n        }\n      }\n  \n      function checkDuplicateKeys (children) {\n        var seenKeys = {};\n        for (var i = 0; i < children.length; i++) {\n          var vnode = children[i];\n          var key = vnode.key;\n          if (isDef(key)) {\n            if (seenKeys[key]) {\n              warn(\n                (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n                vnode.context\n              );\n            } else {\n              seenKeys[key] = true;\n            }\n          }\n        }\n      }\n  \n      function findIdxInOld (node, oldCh, start, end) {\n        for (var i = start; i < end; i++) {\n          var c = oldCh[i];\n          if (isDef(c) && sameVnode(node, c)) { return i }\n        }\n      }\n  \n      function patchVnode (\n        oldVnode,\n        vnode,\n        insertedVnodeQueue,\n        ownerArray,\n        index,\n        removeOnly\n      ) {\n        if (oldVnode === vnode) {\n          return\n        }\n  \n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n          // clone reused vnode\n          vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n  \n        var elm = vnode.elm = oldVnode.elm;\n  \n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\n          if (isDef(vnode.asyncFactory.resolved)) {\n            hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n          } else {\n            vnode.isAsyncPlaceholder = true;\n          }\n          return\n        }\n  \n        // reuse element for static trees.\n        // note we only do this if the vnode is cloned -\n        // if the new node is not cloned it means the render functions have been\n        // reset by the hot-reload-api and we need to do a proper re-render.\n        if (isTrue(vnode.isStatic) &&\n          isTrue(oldVnode.isStatic) &&\n          vnode.key === oldVnode.key &&\n          (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n        ) {\n          vnode.componentInstance = oldVnode.componentInstance;\n          return\n        }\n  \n        var i;\n        var data = vnode.data;\n        if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n          i(oldVnode, vnode);\n        }\n  \n        var oldCh = oldVnode.children;\n        var ch = vnode.children;\n        if (isDef(data) && isPatchable(vnode)) {\n          for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n          if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n        }\n        if (isUndef(vnode.text)) {\n          if (isDef(oldCh) && isDef(ch)) {\n            if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n          } else if (isDef(ch)) {\n            {\n              checkDuplicateKeys(ch);\n            }\n            if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n          } else if (isDef(oldCh)) {\n            removeVnodes(oldCh, 0, oldCh.length - 1);\n          } else if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n        } else if (oldVnode.text !== vnode.text) {\n          nodeOps.setTextContent(elm, vnode.text);\n        }\n        if (isDef(data)) {\n          if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n        }\n      }\n  \n      function invokeInsertHook (vnode, queue, initial) {\n        // delay insert hooks for component root nodes, invoke them after the\n        // element is really inserted\n        if (isTrue(initial) && isDef(vnode.parent)) {\n          vnode.parent.data.pendingInsert = queue;\n        } else {\n          for (var i = 0; i < queue.length; ++i) {\n            queue[i].data.hook.insert(queue[i]);\n          }\n        }\n      }\n  \n      var hydrationBailed = false;\n      // list of modules that can skip create hook during hydration because they\n      // are already rendered on the client or has no need for initialization\n      // Note: style is excluded because it relies on initial clone for future\n      // deep updates (#7063).\n      var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n  \n      // Note: this is a browser-only function so we can assume elms are DOM nodes.\n      function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n        var i;\n        var tag = vnode.tag;\n        var data = vnode.data;\n        var children = vnode.children;\n        inVPre = inVPre || (data && data.pre);\n        vnode.elm = elm;\n  \n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n          vnode.isAsyncPlaceholder = true;\n          return true\n        }\n        // assert node match\n        {\n          if (!assertNodeMatch(elm, vnode, inVPre)) {\n            return false\n          }\n        }\n        if (isDef(data)) {\n          if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n          if (isDef(i = vnode.componentInstance)) {\n            // child component. it should have hydrated its own tree.\n            initComponent(vnode, insertedVnodeQueue);\n            return true\n          }\n        }\n        if (isDef(tag)) {\n          if (isDef(children)) {\n            // empty element, allow client to pick up and populate children\n            if (!elm.hasChildNodes()) {\n              createChildren(vnode, children, insertedVnodeQueue);\n            } else {\n              // v-html and domProps: innerHTML\n              if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n                if (i !== elm.innerHTML) {\n                  /* istanbul ignore if */\n                  if (typeof console !== 'undefined' &&\n                    !hydrationBailed\n                  ) {\n                    hydrationBailed = true;\n                    console.warn('Parent: ', elm);\n                    console.warn('server innerHTML: ', i);\n                    console.warn('client innerHTML: ', elm.innerHTML);\n                  }\n                  return false\n                }\n              } else {\n                // iterate and compare children lists\n                var childrenMatch = true;\n                var childNode = elm.firstChild;\n                for (var i$1 = 0; i$1 < children.length; i$1++) {\n                  if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                    childrenMatch = false;\n                    break\n                  }\n                  childNode = childNode.nextSibling;\n                }\n                // if childNode is not null, it means the actual childNodes list is\n                // longer than the virtual children list.\n                if (!childrenMatch || childNode) {\n                  /* istanbul ignore if */\n                  if (typeof console !== 'undefined' &&\n                    !hydrationBailed\n                  ) {\n                    hydrationBailed = true;\n                    console.warn('Parent: ', elm);\n                    console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                  }\n                  return false\n                }\n              }\n            }\n          }\n          if (isDef(data)) {\n            var fullInvoke = false;\n            for (var key in data) {\n              if (!isRenderedModule(key)) {\n                fullInvoke = true;\n                invokeCreateHooks(vnode, insertedVnodeQueue);\n                break\n              }\n            }\n            if (!fullInvoke && data['class']) {\n              // ensure collecting deps for deep class bindings for future updates\n              traverse(data['class']);\n            }\n          }\n        } else if (elm.data !== vnode.text) {\n          elm.data = vnode.text;\n        }\n        return true\n      }\n  \n      function assertNodeMatch (node, vnode, inVPre) {\n        if (isDef(vnode.tag)) {\n          return vnode.tag.indexOf('vue-component') === 0 || (\n            !isUnknownElement$$1(vnode, inVPre) &&\n            vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n          )\n        } else {\n          return node.nodeType === (vnode.isComment ? 8 : 3)\n        }\n      }\n  \n      return function patch (oldVnode, vnode, hydrating, removeOnly) {\n        if (isUndef(vnode)) {\n          if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n          return\n        }\n  \n        var isInitialPatch = false;\n        var insertedVnodeQueue = [];\n  \n        if (isUndef(oldVnode)) {\n          // empty mount (likely as component), create new root element\n          isInitialPatch = true;\n          createElm(vnode, insertedVnodeQueue);\n        } else {\n          var isRealElement = isDef(oldVnode.nodeType);\n          if (!isRealElement && sameVnode(oldVnode, vnode)) {\n            // patch existing root node\n            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n          } else {\n            if (isRealElement) {\n              // mounting to a real element\n              // check if this is server-rendered content and if we can perform\n              // a successful hydration.\n              if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n                oldVnode.removeAttribute(SSR_ATTR);\n                hydrating = true;\n              }\n              if (isTrue(hydrating)) {\n                if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                  invokeInsertHook(vnode, insertedVnodeQueue, true);\n                  return oldVnode\n                } else {\n                  warn(\n                    'The client-side rendered virtual DOM tree is not matching ' +\n                    'server-rendered content. This is likely caused by incorrect ' +\n                    'HTML markup, for example nesting block-level elements inside ' +\n                    '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                    'full client-side render.'\n                  );\n                }\n              }\n              // either not server-rendered, or hydration failed.\n              // create an empty node and replace it\n              oldVnode = emptyNodeAt(oldVnode);\n            }\n  \n            // replacing existing element\n            var oldElm = oldVnode.elm;\n            var parentElm = nodeOps.parentNode(oldElm);\n  \n            // create new node\n            createElm(\n              vnode,\n              insertedVnodeQueue,\n              // extremely rare edge case: do not insert if old element is in a\n              // leaving transition. Only happens when combining transition +\n              // keep-alive + HOCs. (#4590)\n              oldElm._leaveCb ? null : parentElm,\n              nodeOps.nextSibling(oldElm)\n            );\n  \n            // update parent placeholder node element, recursively\n            if (isDef(vnode.parent)) {\n              var ancestor = vnode.parent;\n              var patchable = isPatchable(vnode);\n              while (ancestor) {\n                for (var i = 0; i < cbs.destroy.length; ++i) {\n                  cbs.destroy[i](ancestor);\n                }\n                ancestor.elm = vnode.elm;\n                if (patchable) {\n                  for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                    cbs.create[i$1](emptyNode, ancestor);\n                  }\n                  // #6513\n                  // invoke insert hooks that may have been merged by create hooks.\n                  // e.g. for directives that uses the \"inserted\" hook.\n                  var insert = ancestor.data.hook.insert;\n                  if (insert.merged) {\n                    // start at index 1 to avoid re-invoking component mounted hook\n                    for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                      insert.fns[i$2]();\n                    }\n                  }\n                } else {\n                  registerRef(ancestor);\n                }\n                ancestor = ancestor.parent;\n              }\n            }\n  \n            // destroy old node\n            if (isDef(parentElm)) {\n              removeVnodes([oldVnode], 0, 0);\n            } else if (isDef(oldVnode.tag)) {\n              invokeDestroyHook(oldVnode);\n            }\n          }\n        }\n  \n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n        return vnode.elm\n      }\n    }\n  \n    /*  */\n  \n    var directives = {\n      create: updateDirectives,\n      update: updateDirectives,\n      destroy: function unbindDirectives (vnode) {\n        updateDirectives(vnode, emptyNode);\n      }\n    };\n  \n    function updateDirectives (oldVnode, vnode) {\n      if (oldVnode.data.directives || vnode.data.directives) {\n        _update(oldVnode, vnode);\n      }\n    }\n  \n    function _update (oldVnode, vnode) {\n      var isCreate = oldVnode === emptyNode;\n      var isDestroy = vnode === emptyNode;\n      var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n      var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n  \n      var dirsWithInsert = [];\n      var dirsWithPostpatch = [];\n  \n      var key, oldDir, dir;\n      for (key in newDirs) {\n        oldDir = oldDirs[key];\n        dir = newDirs[key];\n        if (!oldDir) {\n          // new directive, bind\n          callHook$1(dir, 'bind', vnode, oldVnode);\n          if (dir.def && dir.def.inserted) {\n            dirsWithInsert.push(dir);\n          }\n        } else {\n          // existing directive, update\n          dir.oldValue = oldDir.value;\n          dir.oldArg = oldDir.arg;\n          callHook$1(dir, 'update', vnode, oldVnode);\n          if (dir.def && dir.def.componentUpdated) {\n            dirsWithPostpatch.push(dir);\n          }\n        }\n      }\n  \n      if (dirsWithInsert.length) {\n        var callInsert = function () {\n          for (var i = 0; i < dirsWithInsert.length; i++) {\n            callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n          }\n        };\n        if (isCreate) {\n          mergeVNodeHook(vnode, 'insert', callInsert);\n        } else {\n          callInsert();\n        }\n      }\n  \n      if (dirsWithPostpatch.length) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          for (var i = 0; i < dirsWithPostpatch.length; i++) {\n            callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n          }\n        });\n      }\n  \n      if (!isCreate) {\n        for (key in oldDirs) {\n          if (!newDirs[key]) {\n            // no longer present, unbind\n            callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n          }\n        }\n      }\n    }\n  \n    var emptyModifiers = Object.create(null);\n  \n    function normalizeDirectives$1 (\n      dirs,\n      vm\n    ) {\n      var res = Object.create(null);\n      if (!dirs) {\n        // $flow-disable-line\n        return res\n      }\n      var i, dir;\n      for (i = 0; i < dirs.length; i++) {\n        dir = dirs[i];\n        if (!dir.modifiers) {\n          // $flow-disable-line\n          dir.modifiers = emptyModifiers;\n        }\n        res[getRawDirName(dir)] = dir;\n        dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n      }\n      // $flow-disable-line\n      return res\n    }\n  \n    function getRawDirName (dir) {\n      return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n    }\n  \n    function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n      var fn = dir.def && dir.def[hook];\n      if (fn) {\n        try {\n          fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n        } catch (e) {\n          handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n        }\n      }\n    }\n  \n    var baseModules = [\n      ref,\n      directives\n    ];\n  \n    /*  */\n  \n    function updateAttrs (oldVnode, vnode) {\n      var opts = vnode.componentOptions;\n      if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n        return\n      }\n      if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n        return\n      }\n      var key, cur, old;\n      var elm = vnode.elm;\n      var oldAttrs = oldVnode.data.attrs || {};\n      var attrs = vnode.data.attrs || {};\n      // clone observed objects, as the user probably wants to mutate it\n      if (isDef(attrs.__ob__)) {\n        attrs = vnode.data.attrs = extend({}, attrs);\n      }\n  \n      for (key in attrs) {\n        cur = attrs[key];\n        old = oldAttrs[key];\n        if (old !== cur) {\n          setAttr(elm, key, cur, vnode.data.pre);\n        }\n      }\n      // #4391: in IE9, setting type can reset value for input[type=radio]\n      // #6666: IE/Edge forces progress value down to 1 before setting a max\n      /* istanbul ignore if */\n      if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n        setAttr(elm, 'value', attrs.value);\n      }\n      for (key in oldAttrs) {\n        if (isUndef(attrs[key])) {\n          if (isXlink(key)) {\n            elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n          } else if (!isEnumeratedAttr(key)) {\n            elm.removeAttribute(key);\n          }\n        }\n      }\n    }\n  \n    function setAttr (el, key, value, isInPre) {\n      if (isInPre || el.tagName.indexOf('-') > -1) {\n        baseSetAttr(el, key, value);\n      } else if (isBooleanAttr(key)) {\n        // set attribute for blank value\n        // e.g. <option disabled>Select one</option>\n        if (isFalsyAttrValue(value)) {\n          el.removeAttribute(key);\n        } else {\n          // technically allowfullscreen is a boolean attribute for <iframe>,\n          // but Flash expects a value of \"true\" when used on <embed> tag\n          value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n            ? 'true'\n            : key;\n          el.setAttribute(key, value);\n        }\n      } else if (isEnumeratedAttr(key)) {\n        el.setAttribute(key, convertEnumeratedValue(key, value));\n      } else if (isXlink(key)) {\n        if (isFalsyAttrValue(value)) {\n          el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else {\n          el.setAttributeNS(xlinkNS, key, value);\n        }\n      } else {\n        baseSetAttr(el, key, value);\n      }\n    }\n  \n    function baseSetAttr (el, key, value) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // #7138: IE10 & 11 fires input event when setting placeholder on\n        // <textarea>... block the first input event and remove the blocker\n        // immediately.\n        /* istanbul ignore if */\n        if (\n          isIE && !isIE9 &&\n          el.tagName === 'TEXTAREA' &&\n          key === 'placeholder' && value !== '' && !el.__ieph\n        ) {\n          var blocker = function (e) {\n            e.stopImmediatePropagation();\n            el.removeEventListener('input', blocker);\n          };\n          el.addEventListener('input', blocker);\n          // $flow-disable-line\n          el.__ieph = true; /* IE placeholder patched */\n        }\n        el.setAttribute(key, value);\n      }\n    }\n  \n    var attrs = {\n      create: updateAttrs,\n      update: updateAttrs\n    };\n  \n    /*  */\n  \n    function updateClass (oldVnode, vnode) {\n      var el = vnode.elm;\n      var data = vnode.data;\n      var oldData = oldVnode.data;\n      if (\n        isUndef(data.staticClass) &&\n        isUndef(data.class) && (\n          isUndef(oldData) || (\n            isUndef(oldData.staticClass) &&\n            isUndef(oldData.class)\n          )\n        )\n      ) {\n        return\n      }\n  \n      var cls = genClassForVnode(vnode);\n  \n      // handle transition classes\n      var transitionClass = el._transitionClasses;\n      if (isDef(transitionClass)) {\n        cls = concat(cls, stringifyClass(transitionClass));\n      }\n  \n      // set the class\n      if (cls !== el._prevClass) {\n        el.setAttribute('class', cls);\n        el._prevClass = cls;\n      }\n    }\n  \n    var klass = {\n      create: updateClass,\n      update: updateClass\n    };\n  \n    /*  */\n  \n    var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n  \n    function parseFilters (exp) {\n      var inSingle = false;\n      var inDouble = false;\n      var inTemplateString = false;\n      var inRegex = false;\n      var curly = 0;\n      var square = 0;\n      var paren = 0;\n      var lastFilterIndex = 0;\n      var c, prev, i, expression, filters;\n  \n      for (i = 0; i < exp.length; i++) {\n        prev = c;\n        c = exp.charCodeAt(i);\n        if (inSingle) {\n          if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n        } else if (inDouble) {\n          if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n        } else if (inTemplateString) {\n          if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n        } else if (inRegex) {\n          if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n        } else if (\n          c === 0x7C && // pipe\n          exp.charCodeAt(i + 1) !== 0x7C &&\n          exp.charCodeAt(i - 1) !== 0x7C &&\n          !curly && !square && !paren\n        ) {\n          if (expression === undefined) {\n            // first filter, end of expression\n            lastFilterIndex = i + 1;\n            expression = exp.slice(0, i).trim();\n          } else {\n            pushFilter();\n          }\n        } else {\n          switch (c) {\n            case 0x22: inDouble = true; break         // \"\n            case 0x27: inSingle = true; break         // '\n            case 0x60: inTemplateString = true; break // `\n            case 0x28: paren++; break                 // (\n            case 0x29: paren--; break                 // )\n            case 0x5B: square++; break                // [\n            case 0x5D: square--; break                // ]\n            case 0x7B: curly++; break                 // {\n            case 0x7D: curly--; break                 // }\n          }\n          if (c === 0x2f) { // /\n            var j = i - 1;\n            var p = (void 0);\n            // find first non-whitespace prev char\n            for (; j >= 0; j--) {\n              p = exp.charAt(j);\n              if (p !== ' ') { break }\n            }\n            if (!p || !validDivisionCharRE.test(p)) {\n              inRegex = true;\n            }\n          }\n        }\n      }\n  \n      if (expression === undefined) {\n        expression = exp.slice(0, i).trim();\n      } else if (lastFilterIndex !== 0) {\n        pushFilter();\n      }\n  \n      function pushFilter () {\n        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n        lastFilterIndex = i + 1;\n      }\n  \n      if (filters) {\n        for (i = 0; i < filters.length; i++) {\n          expression = wrapFilter(expression, filters[i]);\n        }\n      }\n  \n      return expression\n    }\n  \n    function wrapFilter (exp, filter) {\n      var i = filter.indexOf('(');\n      if (i < 0) {\n        // _f: resolveFilter\n        return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n      } else {\n        var name = filter.slice(0, i);\n        var args = filter.slice(i + 1);\n        return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n      }\n    }\n  \n    /*  */\n  \n  \n  \n    /* eslint-disable no-unused-vars */\n    function baseWarn (msg, range) {\n      console.error((\"[Vue compiler]: \" + msg));\n    }\n    /* eslint-enable no-unused-vars */\n  \n    function pluckModuleFunction (\n      modules,\n      key\n    ) {\n      return modules\n        ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n        : []\n    }\n  \n    function addProp (el, name, value, range, dynamic) {\n      (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n      el.plain = false;\n    }\n  \n    function addAttr (el, name, value, range, dynamic) {\n      var attrs = dynamic\n        ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n        : (el.attrs || (el.attrs = []));\n      attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n      el.plain = false;\n    }\n  \n    // add a raw attr (use this in preTransforms)\n    function addRawAttr (el, name, value, range) {\n      el.attrsMap[name] = value;\n      el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n    }\n  \n    function addDirective (\n      el,\n      name,\n      rawName,\n      value,\n      arg,\n      isDynamicArg,\n      modifiers,\n      range\n    ) {\n      (el.directives || (el.directives = [])).push(rangeSetItem({\n        name: name,\n        rawName: rawName,\n        value: value,\n        arg: arg,\n        isDynamicArg: isDynamicArg,\n        modifiers: modifiers\n      }, range));\n      el.plain = false;\n    }\n  \n    function prependModifierMarker (symbol, name, dynamic) {\n      return dynamic\n        ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n        : symbol + name // mark the event as captured\n    }\n  \n    function addHandler (\n      el,\n      name,\n      value,\n      modifiers,\n      important,\n      warn,\n      range,\n      dynamic\n    ) {\n      modifiers = modifiers || emptyObject;\n      // warn prevent and passive modifier\n      /* istanbul ignore if */\n      if (\n        warn &&\n        modifiers.prevent && modifiers.passive\n      ) {\n        warn(\n          'passive and prevent can\\'t be used together. ' +\n          'Passive handler can\\'t prevent default event.',\n          range\n        );\n      }\n  \n      // normalize click.right and click.middle since they don't actually fire\n      // this is technically browser-specific, but at least for now browsers are\n      // the only target envs that have right/middle clicks.\n      if (modifiers.right) {\n        if (dynamic) {\n          name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n        } else if (name === 'click') {\n          name = 'contextmenu';\n          delete modifiers.right;\n        }\n      } else if (modifiers.middle) {\n        if (dynamic) {\n          name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n        } else if (name === 'click') {\n          name = 'mouseup';\n        }\n      }\n  \n      // check capture modifier\n      if (modifiers.capture) {\n        delete modifiers.capture;\n        name = prependModifierMarker('!', name, dynamic);\n      }\n      if (modifiers.once) {\n        delete modifiers.once;\n        name = prependModifierMarker('~', name, dynamic);\n      }\n      /* istanbul ignore if */\n      if (modifiers.passive) {\n        delete modifiers.passive;\n        name = prependModifierMarker('&', name, dynamic);\n      }\n  \n      var events;\n      if (modifiers.native) {\n        delete modifiers.native;\n        events = el.nativeEvents || (el.nativeEvents = {});\n      } else {\n        events = el.events || (el.events = {});\n      }\n  \n      var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n      if (modifiers !== emptyObject) {\n        newHandler.modifiers = modifiers;\n      }\n  \n      var handlers = events[name];\n      /* istanbul ignore if */\n      if (Array.isArray(handlers)) {\n        important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n      } else if (handlers) {\n        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n      } else {\n        events[name] = newHandler;\n      }\n  \n      el.plain = false;\n    }\n  \n    function getRawBindingAttr (\n      el,\n      name\n    ) {\n      return el.rawAttrsMap[':' + name] ||\n        el.rawAttrsMap['v-bind:' + name] ||\n        el.rawAttrsMap[name]\n    }\n  \n    function getBindingAttr (\n      el,\n      name,\n      getStatic\n    ) {\n      var dynamicValue =\n        getAndRemoveAttr(el, ':' + name) ||\n        getAndRemoveAttr(el, 'v-bind:' + name);\n      if (dynamicValue != null) {\n        return parseFilters(dynamicValue)\n      } else if (getStatic !== false) {\n        var staticValue = getAndRemoveAttr(el, name);\n        if (staticValue != null) {\n          return JSON.stringify(staticValue)\n        }\n      }\n    }\n  \n    // note: this only removes the attr from the Array (attrsList) so that it\n    // doesn't get processed by processAttrs.\n    // By default it does NOT remove it from the map (attrsMap) because the map is\n    // needed during codegen.\n    function getAndRemoveAttr (\n      el,\n      name,\n      removeFromMap\n    ) {\n      var val;\n      if ((val = el.attrsMap[name]) != null) {\n        var list = el.attrsList;\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i].name === name) {\n            list.splice(i, 1);\n            break\n          }\n        }\n      }\n      if (removeFromMap) {\n        delete el.attrsMap[name];\n      }\n      return val\n    }\n  \n    function getAndRemoveAttrByRegex (\n      el,\n      name\n    ) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        var attr = list[i];\n        if (name.test(attr.name)) {\n          list.splice(i, 1);\n          return attr\n        }\n      }\n    }\n  \n    function rangeSetItem (\n      item,\n      range\n    ) {\n      if (range) {\n        if (range.start != null) {\n          item.start = range.start;\n        }\n        if (range.end != null) {\n          item.end = range.end;\n        }\n      }\n      return item\n    }\n  \n    /*  */\n  \n    /**\n     * Cross-platform code generation for component v-model\n     */\n    function genComponentModel (\n      el,\n      value,\n      modifiers\n    ) {\n      var ref = modifiers || {};\n      var number = ref.number;\n      var trim = ref.trim;\n  \n      var baseValueExpression = '$$v';\n      var valueExpression = baseValueExpression;\n      if (trim) {\n        valueExpression =\n          \"(typeof \" + baseValueExpression + \" === 'string'\" +\n          \"? \" + baseValueExpression + \".trim()\" +\n          \": \" + baseValueExpression + \")\";\n      }\n      if (number) {\n        valueExpression = \"_n(\" + valueExpression + \")\";\n      }\n      var assignment = genAssignmentCode(value, valueExpression);\n  \n      el.model = {\n        value: (\"(\" + value + \")\"),\n        expression: JSON.stringify(value),\n        callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n      };\n    }\n  \n    /**\n     * Cross-platform codegen helper for generating v-model value assignment code.\n     */\n    function genAssignmentCode (\n      value,\n      assignment\n    ) {\n      var res = parseModel(value);\n      if (res.key === null) {\n        return (value + \"=\" + assignment)\n      } else {\n        return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n      }\n    }\n  \n    /**\n     * Parse a v-model expression into a base path and a final key segment.\n     * Handles both dot-path and possible square brackets.\n     *\n     * Possible cases:\n     *\n     * - test\n     * - test[key]\n     * - test[test1[key]]\n     * - test[\"a\"][key]\n     * - xxx.test[a[a].test1[key]]\n     * - test.xxx.a[\"asa\"][test1[key]]\n     *\n     */\n  \n    var len, str, chr, index$1, expressionPos, expressionEndPos;\n  \n  \n  \n    function parseModel (val) {\n      // Fix https://github.com/vuejs/vue/pull/7730\n      // allow v-model=\"obj.val \" (trailing whitespace)\n      val = val.trim();\n      len = val.length;\n  \n      if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n        index$1 = val.lastIndexOf('.');\n        if (index$1 > -1) {\n          return {\n            exp: val.slice(0, index$1),\n            key: '\"' + val.slice(index$1 + 1) + '\"'\n          }\n        } else {\n          return {\n            exp: val,\n            key: null\n          }\n        }\n      }\n  \n      str = val;\n      index$1 = expressionPos = expressionEndPos = 0;\n  \n      while (!eof()) {\n        chr = next();\n        /* istanbul ignore if */\n        if (isStringStart(chr)) {\n          parseString(chr);\n        } else if (chr === 0x5B) {\n          parseBracket(chr);\n        }\n      }\n  \n      return {\n        exp: val.slice(0, expressionPos),\n        key: val.slice(expressionPos + 1, expressionEndPos)\n      }\n    }\n  \n    function next () {\n      return str.charCodeAt(++index$1)\n    }\n  \n    function eof () {\n      return index$1 >= len\n    }\n  \n    function isStringStart (chr) {\n      return chr === 0x22 || chr === 0x27\n    }\n  \n    function parseBracket (chr) {\n      var inBracket = 1;\n      expressionPos = index$1;\n      while (!eof()) {\n        chr = next();\n        if (isStringStart(chr)) {\n          parseString(chr);\n          continue\n        }\n        if (chr === 0x5B) { inBracket++; }\n        if (chr === 0x5D) { inBracket--; }\n        if (inBracket === 0) {\n          expressionEndPos = index$1;\n          break\n        }\n      }\n    }\n  \n    function parseString (chr) {\n      var stringQuote = chr;\n      while (!eof()) {\n        chr = next();\n        if (chr === stringQuote) {\n          break\n        }\n      }\n    }\n  \n    /*  */\n  \n    var warn$1;\n  \n    // in some cases, the event used has to be determined at runtime\n    // so we used some reserved tokens during compile.\n    var RANGE_TOKEN = '__r';\n    var CHECKBOX_RADIO_TOKEN = '__c';\n  \n    function model (\n      el,\n      dir,\n      _warn\n    ) {\n      warn$1 = _warn;\n      var value = dir.value;\n      var modifiers = dir.modifiers;\n      var tag = el.tag;\n      var type = el.attrsMap.type;\n  \n      {\n        // inputs with type=\"file\" are read only and setting the input's\n        // value will throw an error.\n        if (tag === 'input' && type === 'file') {\n          warn$1(\n            \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n            \"File inputs are read only. Use a v-on:change listener instead.\",\n            el.rawAttrsMap['v-model']\n          );\n        }\n      }\n  \n      if (el.component) {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false\n      } else if (tag === 'select') {\n        genSelect(el, value, modifiers);\n      } else if (tag === 'input' && type === 'checkbox') {\n        genCheckboxModel(el, value, modifiers);\n      } else if (tag === 'input' && type === 'radio') {\n        genRadioModel(el, value, modifiers);\n      } else if (tag === 'input' || tag === 'textarea') {\n        genDefaultModel(el, value, modifiers);\n      } else if (!config.isReservedTag(tag)) {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false\n      } else {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"v-model is not supported on this element type. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          el.rawAttrsMap['v-model']\n        );\n      }\n  \n      // ensure runtime directive metadata\n      return true\n    }\n  \n    function genCheckboxModel (\n      el,\n      value,\n      modifiers\n    ) {\n      var number = modifiers && modifiers.number;\n      var valueBinding = getBindingAttr(el, 'value') || 'null';\n      var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n      var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n      addProp(el, 'checked',\n        \"Array.isArray(\" + value + \")\" +\n        \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n          trueValueBinding === 'true'\n            ? (\":(\" + value + \")\")\n            : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n        )\n      );\n      addHandler(el, 'change',\n        \"var $$a=\" + value + \",\" +\n            '$$el=$event.target,' +\n            \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n        'if(Array.isArray($$a)){' +\n          \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n              '$$i=_i($$a,$$v);' +\n          \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n          \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n        \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n        null, true\n      );\n    }\n  \n    function genRadioModel (\n      el,\n      value,\n      modifiers\n    ) {\n      var number = modifiers && modifiers.number;\n      var valueBinding = getBindingAttr(el, 'value') || 'null';\n      valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n      addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n      addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n    }\n  \n    function genSelect (\n      el,\n      value,\n      modifiers\n    ) {\n      var number = modifiers && modifiers.number;\n      var selectedVal = \"Array.prototype.filter\" +\n        \".call($event.target.options,function(o){return o.selected})\" +\n        \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n        \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n  \n      var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n      var code = \"var $$selectedVal = \" + selectedVal + \";\";\n      code = code + \" \" + (genAssignmentCode(value, assignment));\n      addHandler(el, 'change', code, null, true);\n    }\n  \n    function genDefaultModel (\n      el,\n      value,\n      modifiers\n    ) {\n      var type = el.attrsMap.type;\n  \n      // warn if v-bind:value conflicts with v-model\n      // except for inputs with v-bind:type\n      {\n        var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n        var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n        if (value$1 && !typeBinding) {\n          var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n          warn$1(\n            binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n            'because the latter already expands to a value binding internally',\n            el.rawAttrsMap[binding]\n          );\n        }\n      }\n  \n      var ref = modifiers || {};\n      var lazy = ref.lazy;\n      var number = ref.number;\n      var trim = ref.trim;\n      var needCompositionGuard = !lazy && type !== 'range';\n      var event = lazy\n        ? 'change'\n        : type === 'range'\n          ? RANGE_TOKEN\n          : 'input';\n  \n      var valueExpression = '$event.target.value';\n      if (trim) {\n        valueExpression = \"$event.target.value.trim()\";\n      }\n      if (number) {\n        valueExpression = \"_n(\" + valueExpression + \")\";\n      }\n  \n      var code = genAssignmentCode(value, valueExpression);\n      if (needCompositionGuard) {\n        code = \"if($event.target.composing)return;\" + code;\n      }\n  \n      addProp(el, 'value', (\"(\" + value + \")\"));\n      addHandler(el, event, code, null, true);\n      if (trim || number) {\n        addHandler(el, 'blur', '$forceUpdate()');\n      }\n    }\n  \n    /*  */\n  \n    // normalize v-model event tokens that can only be determined at runtime.\n    // it's important to place the event as the first in the array because\n    // the whole point is ensuring the v-model callback gets called before\n    // user-attached handlers.\n    function normalizeEvents (on) {\n      /* istanbul ignore if */\n      if (isDef(on[RANGE_TOKEN])) {\n        // IE input[type=range] only supports `change` event\n        var event = isIE ? 'change' : 'input';\n        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n        delete on[RANGE_TOKEN];\n      }\n      // This was originally intended to fix #4521 but no longer necessary\n      // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n      /* istanbul ignore if */\n      if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n        delete on[CHECKBOX_RADIO_TOKEN];\n      }\n    }\n  \n    var target$1;\n  \n    function createOnceHandler$1 (event, handler, capture) {\n      var _target = target$1; // save current target element in closure\n      return function onceHandler () {\n        var res = handler.apply(null, arguments);\n        if (res !== null) {\n          remove$2(event, onceHandler, capture, _target);\n        }\n      }\n    }\n  \n    // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n    // implementation and does not fire microtasks in between event propagation, so\n    // safe to exclude.\n    var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n  \n    function add$1 (\n      name,\n      handler,\n      capture,\n      passive\n    ) {\n      // async edge case #6566: inner click event triggers patch, event handler\n      // attached to outer element during patch, and triggered again. This\n      // happens because browsers fire microtask ticks between event propagation.\n      // the solution is simple: we save the timestamp when a handler is attached,\n      // and the handler would only fire if the event passed to it was fired\n      // AFTER it was attached.\n      if (useMicrotaskFix) {\n        var attachedTimestamp = currentFlushTimestamp;\n        var original = handler;\n        handler = original._wrapper = function (e) {\n          if (\n            // no bubbling, should always fire.\n            // this is just a safety net in case event.timeStamp is unreliable in\n            // certain weird environments...\n            e.target === e.currentTarget ||\n            // event is fired after handler attachment\n            e.timeStamp >= attachedTimestamp ||\n            // bail for environments that have buggy event.timeStamp implementations\n            // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n            // #9681 QtWebEngine event.timeStamp is negative value\n            e.timeStamp <= 0 ||\n            // #9448 bail if event is fired in another document in a multi-page\n            // electron/nw.js app, since event.timeStamp will be using a different\n            // starting reference\n            e.target.ownerDocument !== document\n          ) {\n            return original.apply(this, arguments)\n          }\n        };\n      }\n      target$1.addEventListener(\n        name,\n        handler,\n        supportsPassive\n          ? { capture: capture, passive: passive }\n          : capture\n      );\n    }\n  \n    function remove$2 (\n      name,\n      handler,\n      capture,\n      _target\n    ) {\n      (_target || target$1).removeEventListener(\n        name,\n        handler._wrapper || handler,\n        capture\n      );\n    }\n  \n    function updateDOMListeners (oldVnode, vnode) {\n      if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n        return\n      }\n      var on = vnode.data.on || {};\n      var oldOn = oldVnode.data.on || {};\n      target$1 = vnode.elm;\n      normalizeEvents(on);\n      updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n      target$1 = undefined;\n    }\n  \n    var events = {\n      create: updateDOMListeners,\n      update: updateDOMListeners\n    };\n  \n    /*  */\n  \n    var svgContainer;\n  \n    function updateDOMProps (oldVnode, vnode) {\n      if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n        return\n      }\n      var key, cur;\n      var elm = vnode.elm;\n      var oldProps = oldVnode.data.domProps || {};\n      var props = vnode.data.domProps || {};\n      // clone observed objects, as the user probably wants to mutate it\n      if (isDef(props.__ob__)) {\n        props = vnode.data.domProps = extend({}, props);\n      }\n  \n      for (key in oldProps) {\n        if (!(key in props)) {\n          elm[key] = '';\n        }\n      }\n  \n      for (key in props) {\n        cur = props[key];\n        // ignore children if the node has textContent or innerHTML,\n        // as these will throw away existing DOM nodes and cause removal errors\n        // on subsequent patches (#3360)\n        if (key === 'textContent' || key === 'innerHTML') {\n          if (vnode.children) { vnode.children.length = 0; }\n          if (cur === oldProps[key]) { continue }\n          // #6601 work around Chrome version <= 55 bug where single textNode\n          // replaced by innerHTML/textContent retains its parentNode property\n          if (elm.childNodes.length === 1) {\n            elm.removeChild(elm.childNodes[0]);\n          }\n        }\n  \n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\n          // store value as _value as well since\n          // non-string values will be stringified\n          elm._value = cur;\n          // avoid resetting cursor position when value is the same\n          var strCur = isUndef(cur) ? '' : String(cur);\n          if (shouldUpdateValue(elm, strCur)) {\n            elm.value = strCur;\n          }\n        } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n          // IE doesn't support innerHTML for SVG elements\n          svgContainer = svgContainer || document.createElement('div');\n          svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n          var svg = svgContainer.firstChild;\n          while (elm.firstChild) {\n            elm.removeChild(elm.firstChild);\n          }\n          while (svg.firstChild) {\n            elm.appendChild(svg.firstChild);\n          }\n        } else if (\n          // skip the update if old and new VDOM state is the same.\n          // `value` is handled separately because the DOM value may be temporarily\n          // out of sync with VDOM state due to focus, composition and modifiers.\n          // This  #4521 by skipping the unnecessary `checked` update.\n          cur !== oldProps[key]\n        ) {\n          // some property updates can throw\n          // e.g. `value` on <progress> w/ non-finite value\n          try {\n            elm[key] = cur;\n          } catch (e) {}\n        }\n      }\n    }\n  \n    // check platforms/web/util/attrs.js acceptValue\n  \n  \n    function shouldUpdateValue (elm, checkVal) {\n      return (!elm.composing && (\n        elm.tagName === 'OPTION' ||\n        isNotInFocusAndDirty(elm, checkVal) ||\n        isDirtyWithModifiers(elm, checkVal)\n      ))\n    }\n  \n    function isNotInFocusAndDirty (elm, checkVal) {\n      // return true when textbox (.number and .trim) loses focus and its value is\n      // not equal to the updated value\n      var notInFocus = true;\n      // #6157\n      // work around IE bug when accessing document.activeElement in an iframe\n      try { notInFocus = document.activeElement !== elm; } catch (e) {}\n      return notInFocus && elm.value !== checkVal\n    }\n  \n    function isDirtyWithModifiers (elm, newVal) {\n      var value = elm.value;\n      var modifiers = elm._vModifiers; // injected by v-model runtime\n      if (isDef(modifiers)) {\n        if (modifiers.number) {\n          return toNumber(value) !== toNumber(newVal)\n        }\n        if (modifiers.trim) {\n          return value.trim() !== newVal.trim()\n        }\n      }\n      return value !== newVal\n    }\n  \n    var domProps = {\n      create: updateDOMProps,\n      update: updateDOMProps\n    };\n  \n    /*  */\n  \n    var parseStyleText = cached(function (cssText) {\n      var res = {};\n      var listDelimiter = /;(?![^(]*\\))/g;\n      var propertyDelimiter = /:(.+)/;\n      cssText.split(listDelimiter).forEach(function (item) {\n        if (item) {\n          var tmp = item.split(propertyDelimiter);\n          tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n        }\n      });\n      return res\n    });\n  \n    // merge static and dynamic style data on the same vnode\n    function normalizeStyleData (data) {\n      var style = normalizeStyleBinding(data.style);\n      // static style is pre-processed into an object during compilation\n      // and is always a fresh object, so it's safe to merge into it\n      return data.staticStyle\n        ? extend(data.staticStyle, style)\n        : style\n    }\n  \n    // normalize possible array / string values into Object\n    function normalizeStyleBinding (bindingStyle) {\n      if (Array.isArray(bindingStyle)) {\n        return toObject(bindingStyle)\n      }\n      if (typeof bindingStyle === 'string') {\n        return parseStyleText(bindingStyle)\n      }\n      return bindingStyle\n    }\n  \n    /**\n     * parent component style should be after child's\n     * so that parent component's style could override it\n     */\n    function getStyle (vnode, checkChild) {\n      var res = {};\n      var styleData;\n  \n      if (checkChild) {\n        var childNode = vnode;\n        while (childNode.componentInstance) {\n          childNode = childNode.componentInstance._vnode;\n          if (\n            childNode && childNode.data &&\n            (styleData = normalizeStyleData(childNode.data))\n          ) {\n            extend(res, styleData);\n          }\n        }\n      }\n  \n      if ((styleData = normalizeStyleData(vnode.data))) {\n        extend(res, styleData);\n      }\n  \n      var parentNode = vnode;\n      while ((parentNode = parentNode.parent)) {\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n          extend(res, styleData);\n        }\n      }\n      return res\n    }\n  \n    /*  */\n  \n    var cssVarRE = /^--/;\n    var importantRE = /\\s*!important$/;\n    var setProp = function (el, name, val) {\n      /* istanbul ignore if */\n      if (cssVarRE.test(name)) {\n        el.style.setProperty(name, val);\n      } else if (importantRE.test(val)) {\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n      } else {\n        var normalizedName = normalize(name);\n        if (Array.isArray(val)) {\n          // Support values array created by autoprefixer, e.g.\n          // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n          // Set them one by one, and the browser will only set those it can recognize\n          for (var i = 0, len = val.length; i < len; i++) {\n            el.style[normalizedName] = val[i];\n          }\n        } else {\n          el.style[normalizedName] = val;\n        }\n      }\n    };\n  \n    var vendorNames = ['Webkit', 'Moz', 'ms'];\n  \n    var emptyStyle;\n    var normalize = cached(function (prop) {\n      emptyStyle = emptyStyle || document.createElement('div').style;\n      prop = camelize(prop);\n      if (prop !== 'filter' && (prop in emptyStyle)) {\n        return prop\n      }\n      var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n      for (var i = 0; i < vendorNames.length; i++) {\n        var name = vendorNames[i] + capName;\n        if (name in emptyStyle) {\n          return name\n        }\n      }\n    });\n  \n    function updateStyle (oldVnode, vnode) {\n      var data = vnode.data;\n      var oldData = oldVnode.data;\n  \n      if (isUndef(data.staticStyle) && isUndef(data.style) &&\n        isUndef(oldData.staticStyle) && isUndef(oldData.style)\n      ) {\n        return\n      }\n  \n      var cur, name;\n      var el = vnode.elm;\n      var oldStaticStyle = oldData.staticStyle;\n      var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n  \n      // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n      var oldStyle = oldStaticStyle || oldStyleBinding;\n  \n      var style = normalizeStyleBinding(vnode.data.style) || {};\n  \n      // store normalized style under a different key for next diff\n      // make sure to clone it if it's reactive, since the user likely wants\n      // to mutate it.\n      vnode.data.normalizedStyle = isDef(style.__ob__)\n        ? extend({}, style)\n        : style;\n  \n      var newStyle = getStyle(vnode, true);\n  \n      for (name in oldStyle) {\n        if (isUndef(newStyle[name])) {\n          setProp(el, name, '');\n        }\n      }\n      for (name in newStyle) {\n        cur = newStyle[name];\n        if (cur !== oldStyle[name]) {\n          // ie9 setting to null has no effect, must use empty string\n          setProp(el, name, cur == null ? '' : cur);\n        }\n      }\n    }\n  \n    var style = {\n      create: updateStyle,\n      update: updateStyle\n    };\n  \n    /*  */\n  \n    var whitespaceRE = /\\s+/;\n  \n    /**\n     * Add class with compatibility for SVG since classList is not supported on\n     * SVG elements in IE\n     */\n    function addClass (el, cls) {\n      /* istanbul ignore if */\n      if (!cls || !(cls = cls.trim())) {\n        return\n      }\n  \n      /* istanbul ignore else */\n      if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n          cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n        } else {\n          el.classList.add(cls);\n        }\n      } else {\n        var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\n          el.setAttribute('class', (cur + cls).trim());\n        }\n      }\n    }\n  \n    /**\n     * Remove class with compatibility for SVG since classList is not supported on\n     * SVG elements in IE\n     */\n    function removeClass (el, cls) {\n      /* istanbul ignore if */\n      if (!cls || !(cls = cls.trim())) {\n        return\n      }\n  \n      /* istanbul ignore else */\n      if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n          cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n        } else {\n          el.classList.remove(cls);\n        }\n        if (!el.classList.length) {\n          el.removeAttribute('class');\n        }\n      } else {\n        var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n        var tar = ' ' + cls + ' ';\n        while (cur.indexOf(tar) >= 0) {\n          cur = cur.replace(tar, ' ');\n        }\n        cur = cur.trim();\n        if (cur) {\n          el.setAttribute('class', cur);\n        } else {\n          el.removeAttribute('class');\n        }\n      }\n    }\n  \n    /*  */\n  \n    function resolveTransition (def$$1) {\n      if (!def$$1) {\n        return\n      }\n      /* istanbul ignore else */\n      if (typeof def$$1 === 'object') {\n        var res = {};\n        if (def$$1.css !== false) {\n          extend(res, autoCssTransition(def$$1.name || 'v'));\n        }\n        extend(res, def$$1);\n        return res\n      } else if (typeof def$$1 === 'string') {\n        return autoCssTransition(def$$1)\n      }\n    }\n  \n    var autoCssTransition = cached(function (name) {\n      return {\n        enterClass: (name + \"-enter\"),\n        enterToClass: (name + \"-enter-to\"),\n        enterActiveClass: (name + \"-enter-active\"),\n        leaveClass: (name + \"-leave\"),\n        leaveToClass: (name + \"-leave-to\"),\n        leaveActiveClass: (name + \"-leave-active\")\n      }\n    });\n  \n    var hasTransition = inBrowser && !isIE9;\n    var TRANSITION = 'transition';\n    var ANIMATION = 'animation';\n  \n    // Transition property/event sniffing\n    var transitionProp = 'transition';\n    var transitionEndEvent = 'transitionend';\n    var animationProp = 'animation';\n    var animationEndEvent = 'animationend';\n    if (hasTransition) {\n      /* istanbul ignore if */\n      if (window.ontransitionend === undefined &&\n        window.onwebkittransitionend !== undefined\n      ) {\n        transitionProp = 'WebkitTransition';\n        transitionEndEvent = 'webkitTransitionEnd';\n      }\n      if (window.onanimationend === undefined &&\n        window.onwebkitanimationend !== undefined\n      ) {\n        animationProp = 'WebkitAnimation';\n        animationEndEvent = 'webkitAnimationEnd';\n      }\n    }\n  \n    // binding to window is necessary to make hot reload work in IE in strict mode\n    var raf = inBrowser\n      ? window.requestAnimationFrame\n        ? window.requestAnimationFrame.bind(window)\n        : setTimeout\n      : /* istanbul ignore next */ function (fn) { return fn(); };\n  \n    function nextFrame (fn) {\n      raf(function () {\n        raf(fn);\n      });\n    }\n  \n    function addTransitionClass (el, cls) {\n      var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n      if (transitionClasses.indexOf(cls) < 0) {\n        transitionClasses.push(cls);\n        addClass(el, cls);\n      }\n    }\n  \n    function removeTransitionClass (el, cls) {\n      if (el._transitionClasses) {\n        remove(el._transitionClasses, cls);\n      }\n      removeClass(el, cls);\n    }\n  \n    function whenTransitionEnds (\n      el,\n      expectedType,\n      cb\n    ) {\n      var ref = getTransitionInfo(el, expectedType);\n      var type = ref.type;\n      var timeout = ref.timeout;\n      var propCount = ref.propCount;\n      if (!type) { return cb() }\n      var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n      var ended = 0;\n      var end = function () {\n        el.removeEventListener(event, onEnd);\n        cb();\n      };\n      var onEnd = function (e) {\n        if (e.target === el) {\n          if (++ended >= propCount) {\n            end();\n          }\n        }\n      };\n      setTimeout(function () {\n        if (ended < propCount) {\n          end();\n        }\n      }, timeout + 1);\n      el.addEventListener(event, onEnd);\n    }\n  \n    var transformRE = /\\b(transform|all)(,|$)/;\n  \n    function getTransitionInfo (el, expectedType) {\n      var styles = window.getComputedStyle(el);\n      // JSDOM may return undefined for transition properties\n      var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n      var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n      var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n      var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n      var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n      var animationTimeout = getTimeout(animationDelays, animationDurations);\n  \n      var type;\n      var timeout = 0;\n      var propCount = 0;\n      /* istanbul ignore if */\n      if (expectedType === TRANSITION) {\n        if (transitionTimeout > 0) {\n          type = TRANSITION;\n          timeout = transitionTimeout;\n          propCount = transitionDurations.length;\n        }\n      } else if (expectedType === ANIMATION) {\n        if (animationTimeout > 0) {\n          type = ANIMATION;\n          timeout = animationTimeout;\n          propCount = animationDurations.length;\n        }\n      } else {\n        timeout = Math.max(transitionTimeout, animationTimeout);\n        type = timeout > 0\n          ? transitionTimeout > animationTimeout\n            ? TRANSITION\n            : ANIMATION\n          : null;\n        propCount = type\n          ? type === TRANSITION\n            ? transitionDurations.length\n            : animationDurations.length\n          : 0;\n      }\n      var hasTransform =\n        type === TRANSITION &&\n        transformRE.test(styles[transitionProp + 'Property']);\n      return {\n        type: type,\n        timeout: timeout,\n        propCount: propCount,\n        hasTransform: hasTransform\n      }\n    }\n  \n    function getTimeout (delays, durations) {\n      /* istanbul ignore next */\n      while (delays.length < durations.length) {\n        delays = delays.concat(delays);\n      }\n  \n      return Math.max.apply(null, durations.map(function (d, i) {\n        return toMs(d) + toMs(delays[i])\n      }))\n    }\n  \n    // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n    // in a locale-dependent way, using a comma instead of a dot.\n    // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n    // as a floor function) causing unexpected behaviors\n    function toMs (s) {\n      return Number(s.slice(0, -1).replace(',', '.')) * 1000\n    }\n  \n    /*  */\n  \n    function enter (vnode, toggleDisplay) {\n      var el = vnode.elm;\n  \n      // call leave callback now\n      if (isDef(el._leaveCb)) {\n        el._leaveCb.cancelled = true;\n        el._leaveCb();\n      }\n  \n      var data = resolveTransition(vnode.data.transition);\n      if (isUndef(data)) {\n        return\n      }\n  \n      /* istanbul ignore if */\n      if (isDef(el._enterCb) || el.nodeType !== 1) {\n        return\n      }\n  \n      var css = data.css;\n      var type = data.type;\n      var enterClass = data.enterClass;\n      var enterToClass = data.enterToClass;\n      var enterActiveClass = data.enterActiveClass;\n      var appearClass = data.appearClass;\n      var appearToClass = data.appearToClass;\n      var appearActiveClass = data.appearActiveClass;\n      var beforeEnter = data.beforeEnter;\n      var enter = data.enter;\n      var afterEnter = data.afterEnter;\n      var enterCancelled = data.enterCancelled;\n      var beforeAppear = data.beforeAppear;\n      var appear = data.appear;\n      var afterAppear = data.afterAppear;\n      var appearCancelled = data.appearCancelled;\n      var duration = data.duration;\n  \n      // activeInstance will always be the <transition> component managing this\n      // transition. One edge case to check is when the <transition> is placed\n      // as the root node of a child component. In that case we need to check\n      // <transition>'s parent for appear check.\n      var context = activeInstance;\n      var transitionNode = activeInstance.$vnode;\n      while (transitionNode && transitionNode.parent) {\n        context = transitionNode.context;\n        transitionNode = transitionNode.parent;\n      }\n  \n      var isAppear = !context._isMounted || !vnode.isRootInsert;\n  \n      if (isAppear && !appear && appear !== '') {\n        return\n      }\n  \n      var startClass = isAppear && appearClass\n        ? appearClass\n        : enterClass;\n      var activeClass = isAppear && appearActiveClass\n        ? appearActiveClass\n        : enterActiveClass;\n      var toClass = isAppear && appearToClass\n        ? appearToClass\n        : enterToClass;\n  \n      var beforeEnterHook = isAppear\n        ? (beforeAppear || beforeEnter)\n        : beforeEnter;\n      var enterHook = isAppear\n        ? (typeof appear === 'function' ? appear : enter)\n        : enter;\n      var afterEnterHook = isAppear\n        ? (afterAppear || afterEnter)\n        : afterEnter;\n      var enterCancelledHook = isAppear\n        ? (appearCancelled || enterCancelled)\n        : enterCancelled;\n  \n      var explicitEnterDuration = toNumber(\n        isObject(duration)\n          ? duration.enter\n          : duration\n      );\n  \n      if (explicitEnterDuration != null) {\n        checkDuration(explicitEnterDuration, 'enter', vnode);\n      }\n  \n      var expectsCSS = css !== false && !isIE9;\n      var userWantsControl = getHookArgumentsLength(enterHook);\n  \n      var cb = el._enterCb = once(function () {\n        if (expectsCSS) {\n          removeTransitionClass(el, toClass);\n          removeTransitionClass(el, activeClass);\n        }\n        if (cb.cancelled) {\n          if (expectsCSS) {\n            removeTransitionClass(el, startClass);\n          }\n          enterCancelledHook && enterCancelledHook(el);\n        } else {\n          afterEnterHook && afterEnterHook(el);\n        }\n        el._enterCb = null;\n      });\n  \n      if (!vnode.data.show) {\n        // remove pending leave element on enter by injecting an insert hook\n        mergeVNodeHook(vnode, 'insert', function () {\n          var parent = el.parentNode;\n          var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n          if (pendingNode &&\n            pendingNode.tag === vnode.tag &&\n            pendingNode.elm._leaveCb\n          ) {\n            pendingNode.elm._leaveCb();\n          }\n          enterHook && enterHook(el, cb);\n        });\n      }\n  \n      // start enter transition\n      beforeEnterHook && beforeEnterHook(el);\n      if (expectsCSS) {\n        addTransitionClass(el, startClass);\n        addTransitionClass(el, activeClass);\n        nextFrame(function () {\n          removeTransitionClass(el, startClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, toClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitEnterDuration)) {\n                setTimeout(cb, explicitEnterDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n  \n      if (vnode.data.show) {\n        toggleDisplay && toggleDisplay();\n        enterHook && enterHook(el, cb);\n      }\n  \n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  \n    function leave (vnode, rm) {\n      var el = vnode.elm;\n  \n      // call enter callback now\n      if (isDef(el._enterCb)) {\n        el._enterCb.cancelled = true;\n        el._enterCb();\n      }\n  \n      var data = resolveTransition(vnode.data.transition);\n      if (isUndef(data) || el.nodeType !== 1) {\n        return rm()\n      }\n  \n      /* istanbul ignore if */\n      if (isDef(el._leaveCb)) {\n        return\n      }\n  \n      var css = data.css;\n      var type = data.type;\n      var leaveClass = data.leaveClass;\n      var leaveToClass = data.leaveToClass;\n      var leaveActiveClass = data.leaveActiveClass;\n      var beforeLeave = data.beforeLeave;\n      var leave = data.leave;\n      var afterLeave = data.afterLeave;\n      var leaveCancelled = data.leaveCancelled;\n      var delayLeave = data.delayLeave;\n      var duration = data.duration;\n  \n      var expectsCSS = css !== false && !isIE9;\n      var userWantsControl = getHookArgumentsLength(leave);\n  \n      var explicitLeaveDuration = toNumber(\n        isObject(duration)\n          ? duration.leave\n          : duration\n      );\n  \n      if (isDef(explicitLeaveDuration)) {\n        checkDuration(explicitLeaveDuration, 'leave', vnode);\n      }\n  \n      var cb = el._leaveCb = once(function () {\n        if (el.parentNode && el.parentNode._pending) {\n          el.parentNode._pending[vnode.key] = null;\n        }\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveToClass);\n          removeTransitionClass(el, leaveActiveClass);\n        }\n        if (cb.cancelled) {\n          if (expectsCSS) {\n            removeTransitionClass(el, leaveClass);\n          }\n          leaveCancelled && leaveCancelled(el);\n        } else {\n          rm();\n          afterLeave && afterLeave(el);\n        }\n        el._leaveCb = null;\n      });\n  \n      if (delayLeave) {\n        delayLeave(performLeave);\n      } else {\n        performLeave();\n      }\n  \n      function performLeave () {\n        // the delayed leave may have already been cancelled\n        if (cb.cancelled) {\n          return\n        }\n        // record leaving element\n        if (!vnode.data.show && el.parentNode) {\n          (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n        }\n        beforeLeave && beforeLeave(el);\n        if (expectsCSS) {\n          addTransitionClass(el, leaveClass);\n          addTransitionClass(el, leaveActiveClass);\n          nextFrame(function () {\n            removeTransitionClass(el, leaveClass);\n            if (!cb.cancelled) {\n              addTransitionClass(el, leaveToClass);\n              if (!userWantsControl) {\n                if (isValidDuration(explicitLeaveDuration)) {\n                  setTimeout(cb, explicitLeaveDuration);\n                } else {\n                  whenTransitionEnds(el, type, cb);\n                }\n              }\n            }\n          });\n        }\n        leave && leave(el, cb);\n        if (!expectsCSS && !userWantsControl) {\n          cb();\n        }\n      }\n    }\n  \n    // only used in dev mode\n    function checkDuration (val, name, vnode) {\n      if (typeof val !== 'number') {\n        warn(\n          \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n          \"got \" + (JSON.stringify(val)) + \".\",\n          vnode.context\n        );\n      } else if (isNaN(val)) {\n        warn(\n          \"<transition> explicit \" + name + \" duration is NaN - \" +\n          'the duration expression might be incorrect.',\n          vnode.context\n        );\n      }\n    }\n  \n    function isValidDuration (val) {\n      return typeof val === 'number' && !isNaN(val)\n    }\n  \n    /**\n     * Normalize a transition hook's argument length. The hook may be:\n     * - a merged hook (invoker) with the original in .fns\n     * - a wrapped component method (check ._length)\n     * - a plain function (.length)\n     */\n    function getHookArgumentsLength (fn) {\n      if (isUndef(fn)) {\n        return false\n      }\n      var invokerFns = fn.fns;\n      if (isDef(invokerFns)) {\n        // invoker\n        return getHookArgumentsLength(\n          Array.isArray(invokerFns)\n            ? invokerFns[0]\n            : invokerFns\n        )\n      } else {\n        return (fn._length || fn.length) > 1\n      }\n    }\n  \n    function _enter (_, vnode) {\n      if (vnode.data.show !== true) {\n        enter(vnode);\n      }\n    }\n  \n    var transition = inBrowser ? {\n      create: _enter,\n      activate: _enter,\n      remove: function remove$$1 (vnode, rm) {\n        /* istanbul ignore else */\n        if (vnode.data.show !== true) {\n          leave(vnode, rm);\n        } else {\n          rm();\n        }\n      }\n    } : {};\n  \n    var platformModules = [\n      attrs,\n      klass,\n      events,\n      domProps,\n      style,\n      transition\n    ];\n  \n    /*  */\n  \n    // the directive module should be applied last, after all\n    // built-in modules have been applied.\n    var modules = platformModules.concat(baseModules);\n  \n    var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n  \n    /**\n     * Not type checking this file because flow doesn't like attaching\n     * properties to Elements.\n     */\n  \n    /* istanbul ignore if */\n    if (isIE9) {\n      // http://www.matts411.com/post/internet-explorer-9-oninput/\n      document.addEventListener('selectionchange', function () {\n        var el = document.activeElement;\n        if (el && el.vmodel) {\n          trigger(el, 'input');\n        }\n      });\n    }\n  \n    var directive = {\n      inserted: function inserted (el, binding, vnode, oldVnode) {\n        if (vnode.tag === 'select') {\n          // #6903\n          if (oldVnode.elm && !oldVnode.elm._vOptions) {\n            mergeVNodeHook(vnode, 'postpatch', function () {\n              directive.componentUpdated(el, binding, vnode);\n            });\n          } else {\n            setSelected(el, binding, vnode.context);\n          }\n          el._vOptions = [].map.call(el.options, getValue);\n        } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n          el._vModifiers = binding.modifiers;\n          if (!binding.modifiers.lazy) {\n            el.addEventListener('compositionstart', onCompositionStart);\n            el.addEventListener('compositionend', onCompositionEnd);\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\n            // switching focus before confirming composition choice\n            // this also fixes the issue where some browsers e.g. iOS Chrome\n            // fires \"change\" instead of \"input\" on autocomplete.\n            el.addEventListener('change', onCompositionEnd);\n            /* istanbul ignore if */\n            if (isIE9) {\n              el.vmodel = true;\n            }\n          }\n        }\n      },\n  \n      componentUpdated: function componentUpdated (el, binding, vnode) {\n        if (vnode.tag === 'select') {\n          setSelected(el, binding, vnode.context);\n          // in case the options rendered by v-for have changed,\n          // it's possible that the value is out-of-sync with the rendered options.\n          // detect such cases and filter out values that no longer has a matching\n          // option in the DOM.\n          var prevOptions = el._vOptions;\n          var curOptions = el._vOptions = [].map.call(el.options, getValue);\n          if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n            // trigger change event if\n            // no matching option found for at least one value\n            var needReset = el.multiple\n              ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n              : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n            if (needReset) {\n              trigger(el, 'change');\n            }\n          }\n        }\n      }\n    };\n  \n    function setSelected (el, binding, vm) {\n      actuallySetSelected(el, binding, vm);\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(function () {\n          actuallySetSelected(el, binding, vm);\n        }, 0);\n      }\n    }\n  \n    function actuallySetSelected (el, binding, vm) {\n      var value = binding.value;\n      var isMultiple = el.multiple;\n      if (isMultiple && !Array.isArray(value)) {\n        warn(\n          \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n          \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n          vm\n        );\n        return\n      }\n      var selected, option;\n      for (var i = 0, l = el.options.length; i < l; i++) {\n        option = el.options[i];\n        if (isMultiple) {\n          selected = looseIndexOf(value, getValue(option)) > -1;\n          if (option.selected !== selected) {\n            option.selected = selected;\n          }\n        } else {\n          if (looseEqual(getValue(option), value)) {\n            if (el.selectedIndex !== i) {\n              el.selectedIndex = i;\n            }\n            return\n          }\n        }\n      }\n      if (!isMultiple) {\n        el.selectedIndex = -1;\n      }\n    }\n  \n    function hasNoMatchingOption (value, options) {\n      return options.every(function (o) { return !looseEqual(o, value); })\n    }\n  \n    function getValue (option) {\n      return '_value' in option\n        ? option._value\n        : option.value\n    }\n  \n    function onCompositionStart (e) {\n      e.target.composing = true;\n    }\n  \n    function onCompositionEnd (e) {\n      // prevent triggering an input event for no reason\n      if (!e.target.composing) { return }\n      e.target.composing = false;\n      trigger(e.target, 'input');\n    }\n  \n    function trigger (el, type) {\n      var e = document.createEvent('HTMLEvents');\n      e.initEvent(type, true, true);\n      el.dispatchEvent(e);\n    }\n  \n    /*  */\n  \n    // recursively search for possible transition defined inside the component root\n    function locateNode (vnode) {\n      return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n        ? locateNode(vnode.componentInstance._vnode)\n        : vnode\n    }\n  \n    var show = {\n      bind: function bind (el, ref, vnode) {\n        var value = ref.value;\n  \n        vnode = locateNode(vnode);\n        var transition$$1 = vnode.data && vnode.data.transition;\n        var originalDisplay = el.__vOriginalDisplay =\n          el.style.display === 'none' ? '' : el.style.display;\n        if (value && transition$$1) {\n          vnode.data.show = true;\n          enter(vnode, function () {\n            el.style.display = originalDisplay;\n          });\n        } else {\n          el.style.display = value ? originalDisplay : 'none';\n        }\n      },\n  \n      update: function update (el, ref, vnode) {\n        var value = ref.value;\n        var oldValue = ref.oldValue;\n  \n        /* istanbul ignore if */\n        if (!value === !oldValue) { return }\n        vnode = locateNode(vnode);\n        var transition$$1 = vnode.data && vnode.data.transition;\n        if (transition$$1) {\n          vnode.data.show = true;\n          if (value) {\n            enter(vnode, function () {\n              el.style.display = el.__vOriginalDisplay;\n            });\n          } else {\n            leave(vnode, function () {\n              el.style.display = 'none';\n            });\n          }\n        } else {\n          el.style.display = value ? el.__vOriginalDisplay : 'none';\n        }\n      },\n  \n      unbind: function unbind (\n        el,\n        binding,\n        vnode,\n        oldVnode,\n        isDestroy\n      ) {\n        if (!isDestroy) {\n          el.style.display = el.__vOriginalDisplay;\n        }\n      }\n    };\n  \n    var platformDirectives = {\n      model: directive,\n      show: show\n    };\n  \n    /*  */\n  \n    var transitionProps = {\n      name: String,\n      appear: Boolean,\n      css: Boolean,\n      mode: String,\n      type: String,\n      enterClass: String,\n      leaveClass: String,\n      enterToClass: String,\n      leaveToClass: String,\n      enterActiveClass: String,\n      leaveActiveClass: String,\n      appearClass: String,\n      appearActiveClass: String,\n      appearToClass: String,\n      duration: [Number, String, Object]\n    };\n  \n    // in case the child is also an abstract component, e.g. <keep-alive>\n    // we want to recursively retrieve the real component to be rendered\n    function getRealChild (vnode) {\n      var compOptions = vnode && vnode.componentOptions;\n      if (compOptions && compOptions.Ctor.options.abstract) {\n        return getRealChild(getFirstComponentChild(compOptions.children))\n      } else {\n        return vnode\n      }\n    }\n  \n    function extractTransitionData (comp) {\n      var data = {};\n      var options = comp.$options;\n      // props\n      for (var key in options.propsData) {\n        data[key] = comp[key];\n      }\n      // events.\n      // extract listeners and pass them directly to the transition methods\n      var listeners = options._parentListeners;\n      for (var key$1 in listeners) {\n        data[camelize(key$1)] = listeners[key$1];\n      }\n      return data\n    }\n  \n    function placeholder (h, rawChild) {\n      if (/\\d-keep-alive$/.test(rawChild.tag)) {\n        return h('keep-alive', {\n          props: rawChild.componentOptions.propsData\n        })\n      }\n    }\n  \n    function hasParentTransition (vnode) {\n      while ((vnode = vnode.parent)) {\n        if (vnode.data.transition) {\n          return true\n        }\n      }\n    }\n  \n    function isSameChild (child, oldChild) {\n      return oldChild.key === child.key && oldChild.tag === child.tag\n    }\n  \n    var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n  \n    var isVShowDirective = function (d) { return d.name === 'show'; };\n  \n    var Transition = {\n      name: 'transition',\n      props: transitionProps,\n      abstract: true,\n  \n      render: function render (h) {\n        var this$1 = this;\n  \n        var children = this.$slots.default;\n        if (!children) {\n          return\n        }\n  \n        // filter out text nodes (possible whitespaces)\n        children = children.filter(isNotTextNode);\n        /* istanbul ignore if */\n        if (!children.length) {\n          return\n        }\n  \n        // warn multiple elements\n        if (children.length > 1) {\n          warn(\n            '<transition> can only be used on a single element. Use ' +\n            '<transition-group> for lists.',\n            this.$parent\n          );\n        }\n  \n        var mode = this.mode;\n  \n        // warn invalid mode\n        if (mode && mode !== 'in-out' && mode !== 'out-in'\n        ) {\n          warn(\n            'invalid <transition> mode: ' + mode,\n            this.$parent\n          );\n        }\n  \n        var rawChild = children[0];\n  \n        // if this is a component root node and the component's\n        // parent container node also has transition, skip.\n        if (hasParentTransition(this.$vnode)) {\n          return rawChild\n        }\n  \n        // apply transition data to child\n        // use getRealChild() to ignore abstract components e.g. keep-alive\n        var child = getRealChild(rawChild);\n        /* istanbul ignore if */\n        if (!child) {\n          return rawChild\n        }\n  \n        if (this._leaving) {\n          return placeholder(h, rawChild)\n        }\n  \n        // ensure a key that is unique to the vnode type and to this transition\n        // component instance. This key will be used to remove pending leaving nodes\n        // during entering.\n        var id = \"__transition-\" + (this._uid) + \"-\";\n        child.key = child.key == null\n          ? child.isComment\n            ? id + 'comment'\n            : id + child.tag\n          : isPrimitive(child.key)\n            ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n            : child.key;\n  \n        var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n        var oldRawChild = this._vnode;\n        var oldChild = getRealChild(oldRawChild);\n  \n        // mark v-show\n        // so that the transition module can hand over the control to the directive\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n          child.data.show = true;\n        }\n  \n        if (\n          oldChild &&\n          oldChild.data &&\n          !isSameChild(child, oldChild) &&\n          !isAsyncPlaceholder(oldChild) &&\n          // #6687 component root is a comment node\n          !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n        ) {\n          // replace old child transition data with fresh one\n          // important for dynamic transitions!\n          var oldData = oldChild.data.transition = extend({}, data);\n          // handle transition mode\n          if (mode === 'out-in') {\n            // return placeholder node and queue update when leave finishes\n            this._leaving = true;\n            mergeVNodeHook(oldData, 'afterLeave', function () {\n              this$1._leaving = false;\n              this$1.$forceUpdate();\n            });\n            return placeholder(h, rawChild)\n          } else if (mode === 'in-out') {\n            if (isAsyncPlaceholder(child)) {\n              return oldRawChild\n            }\n            var delayedLeave;\n            var performLeave = function () { delayedLeave(); };\n            mergeVNodeHook(data, 'afterEnter', performLeave);\n            mergeVNodeHook(data, 'enterCancelled', performLeave);\n            mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n          }\n        }\n  \n        return rawChild\n      }\n    };\n  \n    /*  */\n  \n    var props = extend({\n      tag: String,\n      moveClass: String\n    }, transitionProps);\n  \n    delete props.mode;\n  \n    var TransitionGroup = {\n      props: props,\n  \n      beforeMount: function beforeMount () {\n        var this$1 = this;\n  \n        var update = this._update;\n        this._update = function (vnode, hydrating) {\n          var restoreActiveInstance = setActiveInstance(this$1);\n          // force removing pass\n          this$1.__patch__(\n            this$1._vnode,\n            this$1.kept,\n            false, // hydrating\n            true // removeOnly (!important, avoids unnecessary moves)\n          );\n          this$1._vnode = this$1.kept;\n          restoreActiveInstance();\n          update.call(this$1, vnode, hydrating);\n        };\n      },\n  \n      render: function render (h) {\n        var tag = this.tag || this.$vnode.data.tag || 'span';\n        var map = Object.create(null);\n        var prevChildren = this.prevChildren = this.children;\n        var rawChildren = this.$slots.default || [];\n        var children = this.children = [];\n        var transitionData = extractTransitionData(this);\n  \n        for (var i = 0; i < rawChildren.length; i++) {\n          var c = rawChildren[i];\n          if (c.tag) {\n            if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n              children.push(c);\n              map[c.key] = c\n              ;(c.data || (c.data = {})).transition = transitionData;\n            } else {\n              var opts = c.componentOptions;\n              var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n              warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n            }\n          }\n        }\n  \n        if (prevChildren) {\n          var kept = [];\n          var removed = [];\n          for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n            var c$1 = prevChildren[i$1];\n            c$1.data.transition = transitionData;\n            c$1.data.pos = c$1.elm.getBoundingClientRect();\n            if (map[c$1.key]) {\n              kept.push(c$1);\n            } else {\n              removed.push(c$1);\n            }\n          }\n          this.kept = h(tag, null, kept);\n          this.removed = removed;\n        }\n  \n        return h(tag, null, children)\n      },\n  \n      updated: function updated () {\n        var children = this.prevChildren;\n        var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n          return\n        }\n  \n        // we divide the work into three loops to avoid mixing DOM reads and writes\n        // in each iteration - which helps prevent layout thrashing.\n        children.forEach(callPendingCbs);\n        children.forEach(recordPosition);\n        children.forEach(applyTranslation);\n  \n        // force reflow to put everything in position\n        // assign to this to avoid being removed in tree-shaking\n        // $flow-disable-line\n        this._reflow = document.body.offsetHeight;\n  \n        children.forEach(function (c) {\n          if (c.data.moved) {\n            var el = c.elm;\n            var s = el.style;\n            addTransitionClass(el, moveClass);\n            s.transform = s.WebkitTransform = s.transitionDuration = '';\n            el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n              if (e && e.target !== el) {\n                return\n              }\n              if (!e || /transform$/.test(e.propertyName)) {\n                el.removeEventListener(transitionEndEvent, cb);\n                el._moveCb = null;\n                removeTransitionClass(el, moveClass);\n              }\n            });\n          }\n        });\n      },\n  \n      methods: {\n        hasMove: function hasMove (el, moveClass) {\n          /* istanbul ignore if */\n          if (!hasTransition) {\n            return false\n          }\n          /* istanbul ignore if */\n          if (this._hasMove) {\n            return this._hasMove\n          }\n          // Detect whether an element with the move class applied has\n          // CSS transitions. Since the element may be inside an entering\n          // transition at this very moment, we make a clone of it and remove\n          // all other transition classes applied to ensure only the move class\n          // is applied.\n          var clone = el.cloneNode();\n          if (el._transitionClasses) {\n            el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n          }\n          addClass(clone, moveClass);\n          clone.style.display = 'none';\n          this.$el.appendChild(clone);\n          var info = getTransitionInfo(clone);\n          this.$el.removeChild(clone);\n          return (this._hasMove = info.hasTransform)\n        }\n      }\n    };\n  \n    function callPendingCbs (c) {\n      /* istanbul ignore if */\n      if (c.elm._moveCb) {\n        c.elm._moveCb();\n      }\n      /* istanbul ignore if */\n      if (c.elm._enterCb) {\n        c.elm._enterCb();\n      }\n    }\n  \n    function recordPosition (c) {\n      c.data.newPos = c.elm.getBoundingClientRect();\n    }\n  \n    function applyTranslation (c) {\n      var oldPos = c.data.pos;\n      var newPos = c.data.newPos;\n      var dx = oldPos.left - newPos.left;\n      var dy = oldPos.top - newPos.top;\n      if (dx || dy) {\n        c.data.moved = true;\n        var s = c.elm.style;\n        s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n        s.transitionDuration = '0s';\n      }\n    }\n  \n    var platformComponents = {\n      Transition: Transition,\n      TransitionGroup: TransitionGroup\n    };\n  \n    /*  */\n  \n    // install platform specific utils\n    Vue.config.mustUseProp = mustUseProp;\n    Vue.config.isReservedTag = isReservedTag;\n    Vue.config.isReservedAttr = isReservedAttr;\n    Vue.config.getTagNamespace = getTagNamespace;\n    Vue.config.isUnknownElement = isUnknownElement;\n  \n    // install platform runtime directives & components\n    extend(Vue.options.directives, platformDirectives);\n    extend(Vue.options.components, platformComponents);\n  \n    // install platform patch function\n    Vue.prototype.__patch__ = inBrowser ? patch : noop;\n  \n    // public mount method\n    Vue.prototype.$mount = function (\n      el,\n      hydrating\n    ) {\n      el = el && inBrowser ? query(el) : undefined;\n      return mountComponent(this, el, hydrating)\n    };\n  \n    // devtools global hook\n    /* istanbul ignore next */\n    if (inBrowser) {\n      setTimeout(function () {\n        if (config.devtools) {\n          if (devtools) {\n            devtools.emit('init', Vue);\n          } else {\n            console[console.info ? 'info' : 'log'](\n              'Download the Vue Devtools extension for a better development experience:\\n' +\n              'https://github.com/vuejs/vue-devtools'\n            );\n          }\n        }\n        if (config.productionTip !== false &&\n          typeof console !== 'undefined'\n        ) {\n          console[console.info ? 'info' : 'log'](\n            \"You are running Vue in development mode.\\n\" +\n            \"Make sure to turn on production mode when deploying for production.\\n\" +\n            \"See more tips at https://vuejs.org/guide/deployment.html\"\n          );\n        }\n      }, 0);\n    }\n  \n    /*  */\n  \n    var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n    var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  \n    var buildRegex = cached(function (delimiters) {\n      var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n      var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n      return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n    });\n  \n  \n  \n    function parseText (\n      text,\n      delimiters\n    ) {\n      var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n      if (!tagRE.test(text)) {\n        return\n      }\n      var tokens = [];\n      var rawTokens = [];\n      var lastIndex = tagRE.lastIndex = 0;\n      var match, index, tokenValue;\n      while ((match = tagRE.exec(text))) {\n        index = match.index;\n        // push text token\n        if (index > lastIndex) {\n          rawTokens.push(tokenValue = text.slice(lastIndex, index));\n          tokens.push(JSON.stringify(tokenValue));\n        }\n        // tag token\n        var exp = parseFilters(match[1].trim());\n        tokens.push((\"_s(\" + exp + \")\"));\n        rawTokens.push({ '@binding': exp });\n        lastIndex = index + match[0].length;\n      }\n      if (lastIndex < text.length) {\n        rawTokens.push(tokenValue = text.slice(lastIndex));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      return {\n        expression: tokens.join('+'),\n        tokens: rawTokens\n      }\n    }\n  \n    /*  */\n  \n    function transformNode (el, options) {\n      var warn = options.warn || baseWarn;\n      var staticClass = getAndRemoveAttr(el, 'class');\n      if (staticClass) {\n        var res = parseText(staticClass, options.delimiters);\n        if (res) {\n          warn(\n            \"class=\\\"\" + staticClass + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n            el.rawAttrsMap['class']\n          );\n        }\n      }\n      if (staticClass) {\n        el.staticClass = JSON.stringify(staticClass);\n      }\n      var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n      if (classBinding) {\n        el.classBinding = classBinding;\n      }\n    }\n  \n    function genData (el) {\n      var data = '';\n      if (el.staticClass) {\n        data += \"staticClass:\" + (el.staticClass) + \",\";\n      }\n      if (el.classBinding) {\n        data += \"class:\" + (el.classBinding) + \",\";\n      }\n      return data\n    }\n  \n    var klass$1 = {\n      staticKeys: ['staticClass'],\n      transformNode: transformNode,\n      genData: genData\n    };\n  \n    /*  */\n  \n    function transformNode$1 (el, options) {\n      var warn = options.warn || baseWarn;\n      var staticStyle = getAndRemoveAttr(el, 'style');\n      if (staticStyle) {\n        /* istanbul ignore if */\n        {\n          var res = parseText(staticStyle, options.delimiters);\n          if (res) {\n            warn(\n              \"style=\\\"\" + staticStyle + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n              el.rawAttrsMap['style']\n            );\n          }\n        }\n        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n      }\n  \n      var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n      if (styleBinding) {\n        el.styleBinding = styleBinding;\n      }\n    }\n  \n    function genData$1 (el) {\n      var data = '';\n      if (el.staticStyle) {\n        data += \"staticStyle:\" + (el.staticStyle) + \",\";\n      }\n      if (el.styleBinding) {\n        data += \"style:(\" + (el.styleBinding) + \"),\";\n      }\n      return data\n    }\n  \n    var style$1 = {\n      staticKeys: ['staticStyle'],\n      transformNode: transformNode$1,\n      genData: genData$1\n    };\n  \n    /*  */\n  \n    var decoder;\n  \n    var he = {\n      decode: function decode (html) {\n        decoder = decoder || document.createElement('div');\n        decoder.innerHTML = html;\n        return decoder.textContent\n      }\n    };\n  \n    /*  */\n  \n    var isUnaryTag = makeMap(\n      'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n      'link,meta,param,source,track,wbr'\n    );\n  \n    // Elements that you can, intentionally, leave open\n    // (and which close themselves)\n    var canBeLeftOpenTag = makeMap(\n      'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n    );\n  \n    // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n    // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n    var isNonPhrasingTag = makeMap(\n      'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n      'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n      'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n      'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n      'title,tr,track'\n    );\n  \n    /**\n     * Not type-checking this file because it's mostly vendor code.\n     */\n  \n    // Regular Expressions for parsing tags and attributes\n    var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n    var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n    var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\n    var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n    var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n    var startTagClose = /^\\s*(\\/?)>/;\n    var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n    var doctype = /^<!DOCTYPE [^>]+>/i;\n    // #7298: escape - to avoid being passed as HTML comment when inlined in page\n    var comment = /^<!\\--/;\n    var conditionalComment = /^<!\\[/;\n  \n    // Special Elements (can contain anything)\n    var isPlainTextElement = makeMap('script,style,textarea', true);\n    var reCache = {};\n  \n    var decodingMap = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&amp;': '&',\n      '&#10;': '\\n',\n      '&#9;': '\\t',\n      '&#39;': \"'\"\n    };\n    var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n    var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n  \n    // #5992\n    var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n    var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n  \n    function decodeAttr (value, shouldDecodeNewlines) {\n      var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n      return value.replace(re, function (match) { return decodingMap[match]; })\n    }\n  \n    function parseHTML (html, options) {\n      var stack = [];\n      var expectHTML = options.expectHTML;\n      var isUnaryTag$$1 = options.isUnaryTag || no;\n      var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n      var index = 0;\n      var last, lastTag;\n      while (html) {\n        last = html;\n        // Make sure we're not in a plaintext content element like script/style\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n          var textEnd = html.indexOf('<');\n          if (textEnd === 0) {\n            // Comment:\n            if (comment.test(html)) {\n              var commentEnd = html.indexOf('-->');\n  \n              if (commentEnd >= 0) {\n                if (options.shouldKeepComment) {\n                  options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n                }\n                advance(commentEnd + 3);\n                continue\n              }\n            }\n  \n            // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n            if (conditionalComment.test(html)) {\n              var conditionalEnd = html.indexOf(']>');\n  \n              if (conditionalEnd >= 0) {\n                advance(conditionalEnd + 2);\n                continue\n              }\n            }\n  \n            // Doctype:\n            var doctypeMatch = html.match(doctype);\n            if (doctypeMatch) {\n              advance(doctypeMatch[0].length);\n              continue\n            }\n  \n            // End tag:\n            var endTagMatch = html.match(endTag);\n            if (endTagMatch) {\n              var curIndex = index;\n              advance(endTagMatch[0].length);\n              parseEndTag(endTagMatch[1], curIndex, index);\n              continue\n            }\n  \n            // Start tag:\n            var startTagMatch = parseStartTag();\n            if (startTagMatch) {\n              handleStartTag(startTagMatch);\n              if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n                advance(1);\n              }\n              continue\n            }\n          }\n  \n          var text = (void 0), rest = (void 0), next = (void 0);\n          if (textEnd >= 0) {\n            rest = html.slice(textEnd);\n            while (\n              !endTag.test(rest) &&\n              !startTagOpen.test(rest) &&\n              !comment.test(rest) &&\n              !conditionalComment.test(rest)\n            ) {\n              // < in plain text, be forgiving and treat it as text\n              next = rest.indexOf('<', 1);\n              if (next < 0) { break }\n              textEnd += next;\n              rest = html.slice(textEnd);\n            }\n            text = html.substring(0, textEnd);\n          }\n  \n          if (textEnd < 0) {\n            text = html;\n          }\n  \n          if (text) {\n            advance(text.length);\n          }\n  \n          if (options.chars && text) {\n            options.chars(text, index - text.length, index);\n          }\n        } else {\n          var endTagLength = 0;\n          var stackedTag = lastTag.toLowerCase();\n          var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n          var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n            endTagLength = endTag.length;\n            if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n              text = text\n                .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n                .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n            }\n            if (shouldIgnoreFirstNewline(stackedTag, text)) {\n              text = text.slice(1);\n            }\n            if (options.chars) {\n              options.chars(text);\n            }\n            return ''\n          });\n          index += html.length - rest$1.length;\n          html = rest$1;\n          parseEndTag(stackedTag, index - endTagLength, index);\n        }\n  \n        if (html === last) {\n          options.chars && options.chars(html);\n          if (!stack.length && options.warn) {\n            options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n          }\n          break\n        }\n      }\n  \n      // Clean up any remaining tags\n      parseEndTag();\n  \n      function advance (n) {\n        index += n;\n        html = html.substring(n);\n      }\n  \n      function parseStartTag () {\n        var start = html.match(startTagOpen);\n        if (start) {\n          var match = {\n            tagName: start[1],\n            attrs: [],\n            start: index\n          };\n          advance(start[0].length);\n          var end, attr;\n          while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n            attr.start = index;\n            advance(attr[0].length);\n            attr.end = index;\n            match.attrs.push(attr);\n          }\n          if (end) {\n            match.unarySlash = end[1];\n            advance(end[0].length);\n            match.end = index;\n            return match\n          }\n        }\n      }\n  \n      function handleStartTag (match) {\n        var tagName = match.tagName;\n        var unarySlash = match.unarySlash;\n  \n        if (expectHTML) {\n          if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n            parseEndTag(lastTag);\n          }\n          if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n            parseEndTag(tagName);\n          }\n        }\n  \n        var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n  \n        var l = match.attrs.length;\n        var attrs = new Array(l);\n        for (var i = 0; i < l; i++) {\n          var args = match.attrs[i];\n          var value = args[3] || args[4] || args[5] || '';\n          var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n            ? options.shouldDecodeNewlinesForHref\n            : options.shouldDecodeNewlines;\n          attrs[i] = {\n            name: args[1],\n            value: decodeAttr(value, shouldDecodeNewlines)\n          };\n          if (options.outputSourceRange) {\n            attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n            attrs[i].end = args.end;\n          }\n        }\n  \n        if (!unary) {\n          stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n          lastTag = tagName;\n        }\n  \n        if (options.start) {\n          options.start(tagName, attrs, unary, match.start, match.end);\n        }\n      }\n  \n      function parseEndTag (tagName, start, end) {\n        var pos, lowerCasedTagName;\n        if (start == null) { start = index; }\n        if (end == null) { end = index; }\n  \n        // Find the closest opened tag of the same type\n        if (tagName) {\n          lowerCasedTagName = tagName.toLowerCase();\n          for (pos = stack.length - 1; pos >= 0; pos--) {\n            if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n              break\n            }\n          }\n        } else {\n          // If no tag name is provided, clean shop\n          pos = 0;\n        }\n  \n        if (pos >= 0) {\n          // Close all the open elements, up the stack\n          for (var i = stack.length - 1; i >= pos; i--) {\n            if (i > pos || !tagName &&\n              options.warn\n            ) {\n              options.warn(\n                (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n                { start: stack[i].start, end: stack[i].end }\n              );\n            }\n            if (options.end) {\n              options.end(stack[i].tag, start, end);\n            }\n          }\n  \n          // Remove the open elements from the stack\n          stack.length = pos;\n          lastTag = pos && stack[pos - 1].tag;\n        } else if (lowerCasedTagName === 'br') {\n          if (options.start) {\n            options.start(tagName, [], true, start, end);\n          }\n        } else if (lowerCasedTagName === 'p') {\n          if (options.start) {\n            options.start(tagName, [], false, start, end);\n          }\n          if (options.end) {\n            options.end(tagName, start, end);\n          }\n        }\n      }\n    }\n  \n    /*  */\n  \n    var onRE = /^@|^v-on:/;\n    var dirRE = /^v-|^@|^:|^#/;\n    var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n    var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    var stripParensRE = /^\\(|\\)$/g;\n    var dynamicArgRE = /^\\[.*\\]$/;\n  \n    var argRE = /:(.*)$/;\n    var bindRE = /^:|^\\.|^v-bind:/;\n    var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  \n    var slotRE = /^v-slot(:|$)|^#/;\n  \n    var lineBreakRE = /[\\r\\n]/;\n    var whitespaceRE$1 = /[ \\f\\t\\r\\n]+/g;\n  \n    var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  \n    var decodeHTMLCached = cached(he.decode);\n  \n    var emptySlotScopeToken = \"_empty_\";\n  \n    // configurable state\n    var warn$2;\n    var delimiters;\n    var transforms;\n    var preTransforms;\n    var postTransforms;\n    var platformIsPreTag;\n    var platformMustUseProp;\n    var platformGetTagNamespace;\n    var maybeComponent;\n  \n    function createASTElement (\n      tag,\n      attrs,\n      parent\n    ) {\n      return {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        rawAttrsMap: {},\n        parent: parent,\n        children: []\n      }\n    }\n  \n    /**\n     * Convert HTML string to AST.\n     */\n    function parse (\n      template,\n      options\n    ) {\n      warn$2 = options.warn || baseWarn;\n  \n      platformIsPreTag = options.isPreTag || no;\n      platformMustUseProp = options.mustUseProp || no;\n      platformGetTagNamespace = options.getTagNamespace || no;\n      var isReservedTag = options.isReservedTag || no;\n      maybeComponent = function (el) { return !!(\n        el.component ||\n        el.attrsMap[':is'] ||\n        el.attrsMap['v-bind:is'] ||\n        !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))\n      ); };\n      transforms = pluckModuleFunction(options.modules, 'transformNode');\n      preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n      postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  \n      delimiters = options.delimiters;\n  \n      var stack = [];\n      var preserveWhitespace = options.preserveWhitespace !== false;\n      var whitespaceOption = options.whitespace;\n      var root;\n      var currentParent;\n      var inVPre = false;\n      var inPre = false;\n      var warned = false;\n  \n      function warnOnce (msg, range) {\n        if (!warned) {\n          warned = true;\n          warn$2(msg, range);\n        }\n      }\n  \n      function closeElement (element) {\n        trimEndingWhitespace(element);\n        if (!inVPre && !element.processed) {\n          element = processElement(element, options);\n        }\n        // tree management\n        if (!stack.length && element !== root) {\n          // allow root elements with v-if, v-else-if and v-else\n          if (root.if && (element.elseif || element.else)) {\n            {\n              checkRootConstraints(element);\n            }\n            addIfCondition(root, {\n              exp: element.elseif,\n              block: element\n            });\n          } else {\n            warnOnce(\n              \"Component template should contain exactly one root element. \" +\n              \"If you are using v-if on multiple elements, \" +\n              \"use v-else-if to chain them instead.\",\n              { start: element.start }\n            );\n          }\n        }\n        if (currentParent && !element.forbidden) {\n          if (element.elseif || element.else) {\n            processIfConditions(element, currentParent);\n          } else {\n            if (element.slotScope) {\n              // scoped slot\n              // keep it in the children list so that v-else(-if) conditions can\n              // find it as the prev node.\n              var name = element.slotTarget || '\"default\"'\n              ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n            }\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n  \n        // final children cleanup\n        // filter out scoped slots\n        element.children = element.children.filter(function (c) { return !(c).slotScope; });\n        // remove trailing whitespace node again\n        trimEndingWhitespace(element);\n  \n        // check pre state\n        if (element.pre) {\n          inVPre = false;\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = false;\n        }\n        // apply post-transforms\n        for (var i = 0; i < postTransforms.length; i++) {\n          postTransforms[i](element, options);\n        }\n      }\n  \n      function trimEndingWhitespace (el) {\n        // remove trailing whitespace node\n        if (!inPre) {\n          var lastNode;\n          while (\n            (lastNode = el.children[el.children.length - 1]) &&\n            lastNode.type === 3 &&\n            lastNode.text === ' '\n          ) {\n            el.children.pop();\n          }\n        }\n      }\n  \n      function checkRootConstraints (el) {\n        if (el.tag === 'slot' || el.tag === 'template') {\n          warnOnce(\n            \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n            'contain multiple nodes.',\n            { start: el.start }\n          );\n        }\n        if (el.attrsMap.hasOwnProperty('v-for')) {\n          warnOnce(\n            'Cannot use v-for on stateful component root element because ' +\n            'it renders multiple elements.',\n            el.rawAttrsMap['v-for']\n          );\n        }\n      }\n  \n      parseHTML(template, {\n        warn: warn$2,\n        expectHTML: options.expectHTML,\n        isUnaryTag: options.isUnaryTag,\n        canBeLeftOpenTag: options.canBeLeftOpenTag,\n        shouldDecodeNewlines: options.shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n        shouldKeepComment: options.comments,\n        outputSourceRange: options.outputSourceRange,\n        start: function start (tag, attrs, unary, start$1, end) {\n          // check namespace.\n          // inherit parent ns if there is one\n          var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n  \n          // handle IE svg bug\n          /* istanbul ignore if */\n          if (isIE && ns === 'svg') {\n            attrs = guardIESVGBug(attrs);\n          }\n  \n          var element = createASTElement(tag, attrs, currentParent);\n          if (ns) {\n            element.ns = ns;\n          }\n  \n          {\n            if (options.outputSourceRange) {\n              element.start = start$1;\n              element.end = end;\n              element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n                cumulated[attr.name] = attr;\n                return cumulated\n              }, {});\n            }\n            attrs.forEach(function (attr) {\n              if (invalidAttributeRE.test(attr.name)) {\n                warn$2(\n                  \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                  \"spaces, quotes, <, >, / or =.\",\n                  {\n                    start: attr.start + attr.name.indexOf(\"[\"),\n                    end: attr.start + attr.name.length\n                  }\n                );\n              }\n            });\n          }\n  \n          if (isForbiddenTag(element) && !isServerRendering()) {\n            element.forbidden = true;\n            warn$2(\n              'Templates should only be responsible for mapping the state to the ' +\n              'UI. Avoid placing tags with side-effects in your templates, such as ' +\n              \"<\" + tag + \">\" + ', as they will not be parsed.',\n              { start: element.start }\n            );\n          }\n  \n          // apply pre-transforms\n          for (var i = 0; i < preTransforms.length; i++) {\n            element = preTransforms[i](element, options) || element;\n          }\n  \n          if (!inVPre) {\n            processPre(element);\n            if (element.pre) {\n              inVPre = true;\n            }\n          }\n          if (platformIsPreTag(element.tag)) {\n            inPre = true;\n          }\n          if (inVPre) {\n            processRawAttrs(element);\n          } else if (!element.processed) {\n            // structural directives\n            processFor(element);\n            processIf(element);\n            processOnce(element);\n          }\n  \n          if (!root) {\n            root = element;\n            {\n              checkRootConstraints(root);\n            }\n          }\n  \n          if (!unary) {\n            currentParent = element;\n            stack.push(element);\n          } else {\n            closeElement(element);\n          }\n        },\n  \n        end: function end (tag, start, end$1) {\n          var element = stack[stack.length - 1];\n          // pop stack\n          stack.length -= 1;\n          currentParent = stack[stack.length - 1];\n          if (options.outputSourceRange) {\n            element.end = end$1;\n          }\n          closeElement(element);\n        },\n  \n        chars: function chars (text, start, end) {\n          if (!currentParent) {\n            {\n              if (text === template) {\n                warnOnce(\n                  'Component template requires a root element, rather than just text.',\n                  { start: start }\n                );\n              } else if ((text = text.trim())) {\n                warnOnce(\n                  (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                  { start: start }\n                );\n              }\n            }\n            return\n          }\n          // IE textarea placeholder bug\n          /* istanbul ignore if */\n          if (isIE &&\n            currentParent.tag === 'textarea' &&\n            currentParent.attrsMap.placeholder === text\n          ) {\n            return\n          }\n          var children = currentParent.children;\n          if (inPre || text.trim()) {\n            text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n          } else if (!children.length) {\n            // remove the whitespace-only node right after an opening tag\n            text = '';\n          } else if (whitespaceOption) {\n            if (whitespaceOption === 'condense') {\n              // in condense mode, remove the whitespace node if it contains\n              // line break, otherwise condense to a single space\n              text = lineBreakRE.test(text) ? '' : ' ';\n            } else {\n              text = ' ';\n            }\n          } else {\n            text = preserveWhitespace ? ' ' : '';\n          }\n          if (text) {\n            if (!inPre && whitespaceOption === 'condense') {\n              // condense consecutive whitespaces into single space\n              text = text.replace(whitespaceRE$1, ' ');\n            }\n            var res;\n            var child;\n            if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n              child = {\n                type: 2,\n                expression: res.expression,\n                tokens: res.tokens,\n                text: text\n              };\n            } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n              child = {\n                type: 3,\n                text: text\n              };\n            }\n            if (child) {\n              if (options.outputSourceRange) {\n                child.start = start;\n                child.end = end;\n              }\n              children.push(child);\n            }\n          }\n        },\n        comment: function comment (text, start, end) {\n          // adding anything as a sibling to the root node is forbidden\n          // comments should still be allowed, but ignored\n          if (currentParent) {\n            var child = {\n              type: 3,\n              text: text,\n              isComment: true\n            };\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            currentParent.children.push(child);\n          }\n        }\n      });\n      return root\n    }\n  \n    function processPre (el) {\n      if (getAndRemoveAttr(el, 'v-pre') != null) {\n        el.pre = true;\n      }\n    }\n  \n    function processRawAttrs (el) {\n      var list = el.attrsList;\n      var len = list.length;\n      if (len) {\n        var attrs = el.attrs = new Array(len);\n        for (var i = 0; i < len; i++) {\n          attrs[i] = {\n            name: list[i].name,\n            value: JSON.stringify(list[i].value)\n          };\n          if (list[i].start != null) {\n            attrs[i].start = list[i].start;\n            attrs[i].end = list[i].end;\n          }\n        }\n      } else if (!el.pre) {\n        // non root node in pre blocks with no attributes\n        el.plain = true;\n      }\n    }\n  \n    function processElement (\n      element,\n      options\n    ) {\n      processKey(element);\n  \n      // determine whether this is a plain element after\n      // removing structural attributes\n      element.plain = (\n        !element.key &&\n        !element.scopedSlots &&\n        !element.attrsList.length\n      );\n  \n      processRef(element);\n      processSlotContent(element);\n      processSlotOutlet(element);\n      processComponent(element);\n      for (var i = 0; i < transforms.length; i++) {\n        element = transforms[i](element, options) || element;\n      }\n      processAttrs(element);\n      return element\n    }\n  \n    function processKey (el) {\n      var exp = getBindingAttr(el, 'key');\n      if (exp) {\n        {\n          if (el.tag === 'template') {\n            warn$2(\n              \"<template> cannot be keyed. Place the key on real elements instead.\",\n              getRawBindingAttr(el, 'key')\n            );\n          }\n          if (el.for) {\n            var iterator = el.iterator2 || el.iterator1;\n            var parent = el.parent;\n            if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n              warn$2(\n                \"Do not use v-for index as key on <transition-group> children, \" +\n                \"this is the same as not using keys.\",\n                getRawBindingAttr(el, 'key'),\n                true /* tip */\n              );\n            }\n          }\n        }\n        el.key = exp;\n      }\n    }\n  \n    function processRef (el) {\n      var ref = getBindingAttr(el, 'ref');\n      if (ref) {\n        el.ref = ref;\n        el.refInFor = checkInFor(el);\n      }\n    }\n  \n    function processFor (el) {\n      var exp;\n      if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n        var res = parseFor(exp);\n        if (res) {\n          extend(el, res);\n        } else {\n          warn$2(\n            (\"Invalid v-for expression: \" + exp),\n            el.rawAttrsMap['v-for']\n          );\n        }\n      }\n    }\n  \n  \n  \n    function parseFor (exp) {\n      var inMatch = exp.match(forAliasRE);\n      if (!inMatch) { return }\n      var res = {};\n      res.for = inMatch[2].trim();\n      var alias = inMatch[1].trim().replace(stripParensRE, '');\n      var iteratorMatch = alias.match(forIteratorRE);\n      if (iteratorMatch) {\n        res.alias = alias.replace(forIteratorRE, '').trim();\n        res.iterator1 = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n          res.iterator2 = iteratorMatch[2].trim();\n        }\n      } else {\n        res.alias = alias;\n      }\n      return res\n    }\n  \n    function processIf (el) {\n      var exp = getAndRemoveAttr(el, 'v-if');\n      if (exp) {\n        el.if = exp;\n        addIfCondition(el, {\n          exp: exp,\n          block: el\n        });\n      } else {\n        if (getAndRemoveAttr(el, 'v-else') != null) {\n          el.else = true;\n        }\n        var elseif = getAndRemoveAttr(el, 'v-else-if');\n        if (elseif) {\n          el.elseif = elseif;\n        }\n      }\n    }\n  \n    function processIfConditions (el, parent) {\n      var prev = findPrevElement(parent.children);\n      if (prev && prev.if) {\n        addIfCondition(prev, {\n          exp: el.elseif,\n          block: el\n        });\n      } else {\n        warn$2(\n          \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n          \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n          el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n        );\n      }\n    }\n  \n    function findPrevElement (children) {\n      var i = children.length;\n      while (i--) {\n        if (children[i].type === 1) {\n          return children[i]\n        } else {\n          if (children[i].text !== ' ') {\n            warn$2(\n              \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n              \"will be ignored.\",\n              children[i]\n            );\n          }\n          children.pop();\n        }\n      }\n    }\n  \n    function addIfCondition (el, condition) {\n      if (!el.ifConditions) {\n        el.ifConditions = [];\n      }\n      el.ifConditions.push(condition);\n    }\n  \n    function processOnce (el) {\n      var once$$1 = getAndRemoveAttr(el, 'v-once');\n      if (once$$1 != null) {\n        el.once = true;\n      }\n    }\n  \n    // handle content being passed to a component as slot,\n    // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n    function processSlotContent (el) {\n      var slotScope;\n      if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n        if (slotScope) {\n          warn$2(\n            \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n            \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n            \"can also be used on plain elements in addition to <template> to \" +\n            \"denote scoped slots.\",\n            el.rawAttrsMap['scope'],\n            true\n          );\n        }\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n      } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n        /* istanbul ignore if */\n        if (el.attrsMap['v-for']) {\n          warn$2(\n            \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n            \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n            \"scoped slot to make it clearer.\",\n            el.rawAttrsMap['slot-scope'],\n            true\n          );\n        }\n        el.slotScope = slotScope;\n      }\n  \n      // slot=\"xxx\"\n      var slotTarget = getBindingAttr(el, 'slot');\n      if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n        // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n        if (el.tag !== 'template' && !el.slotScope) {\n          addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n        }\n      }\n  \n      // 2.6 v-slot syntax\n      {\n        if (el.tag === 'template') {\n          // v-slot on <template>\n          var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n          if (slotBinding) {\n            {\n              if (el.slotTarget || el.slotScope) {\n                warn$2(\n                  \"Unexpected mixed usage of different slot syntaxes.\",\n                  el\n                );\n              }\n              if (el.parent && !maybeComponent(el.parent)) {\n                warn$2(\n                  \"<template v-slot> can only appear at the root level inside \" +\n                  \"the receiving component\",\n                  el\n                );\n              }\n            }\n            var ref = getSlotName(slotBinding);\n            var name = ref.name;\n            var dynamic = ref.dynamic;\n            el.slotTarget = name;\n            el.slotTargetDynamic = dynamic;\n            el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n          }\n        } else {\n          // v-slot on component, denotes default slot\n          var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n          if (slotBinding$1) {\n            {\n              if (!maybeComponent(el)) {\n                warn$2(\n                  \"v-slot can only be used on components or <template>.\",\n                  slotBinding$1\n                );\n              }\n              if (el.slotScope || el.slotTarget) {\n                warn$2(\n                  \"Unexpected mixed usage of different slot syntaxes.\",\n                  el\n                );\n              }\n              if (el.scopedSlots) {\n                warn$2(\n                  \"To avoid scope ambiguity, the default slot should also use \" +\n                  \"<template> syntax when there are other named slots.\",\n                  slotBinding$1\n                );\n              }\n            }\n            // add the component's children to its default slot\n            var slots = el.scopedSlots || (el.scopedSlots = {});\n            var ref$1 = getSlotName(slotBinding$1);\n            var name$1 = ref$1.name;\n            var dynamic$1 = ref$1.dynamic;\n            var slotContainer = slots[name$1] = createASTElement('template', [], el);\n            slotContainer.slotTarget = name$1;\n            slotContainer.slotTargetDynamic = dynamic$1;\n            slotContainer.children = el.children.filter(function (c) {\n              if (!c.slotScope) {\n                c.parent = slotContainer;\n                return true\n              }\n            });\n            slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n            // remove children as they are returned from scopedSlots now\n            el.children = [];\n            // mark el non-plain so data gets generated\n            el.plain = false;\n          }\n        }\n      }\n    }\n  \n    function getSlotName (binding) {\n      var name = binding.name.replace(slotRE, '');\n      if (!name) {\n        if (binding.name[0] !== '#') {\n          name = 'default';\n        } else {\n          warn$2(\n            \"v-slot shorthand syntax requires a slot name.\",\n            binding\n          );\n        }\n      }\n      return dynamicArgRE.test(name)\n        // dynamic [name]\n        ? { name: name.slice(1, -1), dynamic: true }\n        // static name\n        : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n    }\n  \n    // handle <slot/> outlets\n    function processSlotOutlet (el) {\n      if (el.tag === 'slot') {\n        el.slotName = getBindingAttr(el, 'name');\n        if (el.key) {\n          warn$2(\n            \"`key` does not work on <slot> because slots are abstract outlets \" +\n            \"and can possibly expand into multiple elements. \" +\n            \"Use the key on a wrapping element instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n      }\n    }\n  \n    function processComponent (el) {\n      var binding;\n      if ((binding = getBindingAttr(el, 'is'))) {\n        el.component = binding;\n      }\n      if (getAndRemoveAttr(el, 'inline-template') != null) {\n        el.inlineTemplate = true;\n      }\n    }\n  \n    function processAttrs (el) {\n      var list = el.attrsList;\n      var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n      for (i = 0, l = list.length; i < l; i++) {\n        name = rawName = list[i].name;\n        value = list[i].value;\n        if (dirRE.test(name)) {\n          // mark element as dynamic\n          el.hasBindings = true;\n          // modifiers\n          modifiers = parseModifiers(name.replace(dirRE, ''));\n          // support .foo shorthand syntax for the .prop modifier\n          if (modifiers) {\n            name = name.replace(modifierRE, '');\n          }\n          if (bindRE.test(name)) { // v-bind\n            name = name.replace(bindRE, '');\n            value = parseFilters(value);\n            isDynamic = dynamicArgRE.test(name);\n            if (isDynamic) {\n              name = name.slice(1, -1);\n            }\n            if (\n              value.trim().length === 0\n            ) {\n              warn$2(\n                (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n              );\n            }\n            if (modifiers) {\n              if (modifiers.prop && !isDynamic) {\n                name = camelize(name);\n                if (name === 'innerHtml') { name = 'innerHTML'; }\n              }\n              if (modifiers.camel && !isDynamic) {\n                name = camelize(name);\n              }\n              if (modifiers.sync) {\n                syncGen = genAssignmentCode(value, \"$event\");\n                if (!isDynamic) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (camelize(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                  if (hyphenate(name) !== camelize(name)) {\n                    addHandler(\n                      el,\n                      (\"update:\" + (hyphenate(name))),\n                      syncGen,\n                      null,\n                      false,\n                      warn$2,\n                      list[i]\n                    );\n                  }\n                } else {\n                  // handler w/ dynamic event name\n                  addHandler(\n                    el,\n                    (\"\\\"update:\\\"+(\" + name + \")\"),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i],\n                    true // dynamic\n                  );\n                }\n              }\n            }\n            if ((modifiers && modifiers.prop) || (\n              !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n            )) {\n              addProp(el, name, value, list[i], isDynamic);\n            } else {\n              addAttr(el, name, value, list[i], isDynamic);\n            }\n          } else if (onRE.test(name)) { // v-on\n            name = name.replace(onRE, '');\n            isDynamic = dynamicArgRE.test(name);\n            if (isDynamic) {\n              name = name.slice(1, -1);\n            }\n            addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n          } else { // normal directives\n            name = name.replace(dirRE, '');\n            // parse arg\n            var argMatch = name.match(argRE);\n            var arg = argMatch && argMatch[1];\n            isDynamic = false;\n            if (arg) {\n              name = name.slice(0, -(arg.length + 1));\n              if (dynamicArgRE.test(arg)) {\n                arg = arg.slice(1, -1);\n                isDynamic = true;\n              }\n            }\n            addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n            if (name === 'model') {\n              checkForAliasModel(el, value);\n            }\n          }\n        } else {\n          // literal attribute\n          {\n            var res = parseText(value, delimiters);\n            if (res) {\n              warn$2(\n                name + \"=\\\"\" + value + \"\\\": \" +\n                'Interpolation inside attributes has been removed. ' +\n                'Use v-bind or the colon shorthand instead. For example, ' +\n                'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n                list[i]\n              );\n            }\n          }\n          addAttr(el, name, JSON.stringify(value), list[i]);\n          // #6887 firefox doesn't update muted state if set via attribute\n          // even immediately after element creation\n          if (!el.component &&\n              name === 'muted' &&\n              platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, 'true', list[i]);\n          }\n        }\n      }\n    }\n  \n    function checkInFor (el) {\n      var parent = el;\n      while (parent) {\n        if (parent.for !== undefined) {\n          return true\n        }\n        parent = parent.parent;\n      }\n      return false\n    }\n  \n    function parseModifiers (name) {\n      var match = name.match(modifierRE);\n      if (match) {\n        var ret = {};\n        match.forEach(function (m) { ret[m.slice(1)] = true; });\n        return ret\n      }\n    }\n  \n    function makeAttrsMap (attrs) {\n      var map = {};\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        if (\n          map[attrs[i].name] && !isIE && !isEdge\n        ) {\n          warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n        }\n        map[attrs[i].name] = attrs[i].value;\n      }\n      return map\n    }\n  \n    // for script (e.g. type=\"x/template\") or style, do not decode content\n    function isTextTag (el) {\n      return el.tag === 'script' || el.tag === 'style'\n    }\n  \n    function isForbiddenTag (el) {\n      return (\n        el.tag === 'style' ||\n        (el.tag === 'script' && (\n          !el.attrsMap.type ||\n          el.attrsMap.type === 'text/javascript'\n        ))\n      )\n    }\n  \n    var ieNSBug = /^xmlns:NS\\d+/;\n    var ieNSPrefix = /^NS\\d+:/;\n  \n    /* istanbul ignore next */\n    function guardIESVGBug (attrs) {\n      var res = [];\n      for (var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n        if (!ieNSBug.test(attr.name)) {\n          attr.name = attr.name.replace(ieNSPrefix, '');\n          res.push(attr);\n        }\n      }\n      return res\n    }\n  \n    function checkForAliasModel (el, value) {\n      var _el = el;\n      while (_el) {\n        if (_el.for && _el.alias === value) {\n          warn$2(\n            \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n            \"You are binding v-model directly to a v-for iteration alias. \" +\n            \"This will not be able to modify the v-for source array because \" +\n            \"writing to the alias is like modifying a function local variable. \" +\n            \"Consider using an array of objects and use v-model on an object property instead.\",\n            el.rawAttrsMap['v-model']\n          );\n        }\n        _el = _el.parent;\n      }\n    }\n  \n    /*  */\n  \n    function preTransformNode (el, options) {\n      if (el.tag === 'input') {\n        var map = el.attrsMap;\n        if (!map['v-model']) {\n          return\n        }\n  \n        var typeBinding;\n        if (map[':type'] || map['v-bind:type']) {\n          typeBinding = getBindingAttr(el, 'type');\n        }\n        if (!map.type && !typeBinding && map['v-bind']) {\n          typeBinding = \"(\" + (map['v-bind']) + \").type\";\n        }\n  \n        if (typeBinding) {\n          var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n          var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n          var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n          var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n          // 1. checkbox\n          var branch0 = cloneASTElement(el);\n          // process for on the main node\n          processFor(branch0);\n          addRawAttr(branch0, 'type', 'checkbox');\n          processElement(branch0, options);\n          branch0.processed = true; // prevent it from double-processed\n          branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n          addIfCondition(branch0, {\n            exp: branch0.if,\n            block: branch0\n          });\n          // 2. add radio else-if condition\n          var branch1 = cloneASTElement(el);\n          getAndRemoveAttr(branch1, 'v-for', true);\n          addRawAttr(branch1, 'type', 'radio');\n          processElement(branch1, options);\n          addIfCondition(branch0, {\n            exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n            block: branch1\n          });\n          // 3. other\n          var branch2 = cloneASTElement(el);\n          getAndRemoveAttr(branch2, 'v-for', true);\n          addRawAttr(branch2, ':type', typeBinding);\n          processElement(branch2, options);\n          addIfCondition(branch0, {\n            exp: ifCondition,\n            block: branch2\n          });\n  \n          if (hasElse) {\n            branch0.else = true;\n          } else if (elseIfCondition) {\n            branch0.elseif = elseIfCondition;\n          }\n  \n          return branch0\n        }\n      }\n    }\n  \n    function cloneASTElement (el) {\n      return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n    }\n  \n    var model$1 = {\n      preTransformNode: preTransformNode\n    };\n  \n    var modules$1 = [\n      klass$1,\n      style$1,\n      model$1\n    ];\n  \n    /*  */\n  \n    function text (el, dir) {\n      if (dir.value) {\n        addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n      }\n    }\n  \n    /*  */\n  \n    function html (el, dir) {\n      if (dir.value) {\n        addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n      }\n    }\n  \n    var directives$1 = {\n      model: model,\n      text: text,\n      html: html\n    };\n  \n    /*  */\n  \n    var baseOptions = {\n      expectHTML: true,\n      modules: modules$1,\n      directives: directives$1,\n      isPreTag: isPreTag,\n      isUnaryTag: isUnaryTag,\n      mustUseProp: mustUseProp,\n      canBeLeftOpenTag: canBeLeftOpenTag,\n      isReservedTag: isReservedTag,\n      getTagNamespace: getTagNamespace,\n      staticKeys: genStaticKeys(modules$1)\n    };\n  \n    /*  */\n  \n    var isStaticKey;\n    var isPlatformReservedTag;\n  \n    var genStaticKeysCached = cached(genStaticKeys$1);\n  \n    /**\n     * Goal of the optimizer: walk the generated template AST tree\n     * and detect sub-trees that are purely static, i.e. parts of\n     * the DOM that never needs to change.\n     *\n     * Once we detect these sub-trees, we can:\n     *\n     * 1. Hoist them into constants, so that we no longer need to\n     *    create fresh nodes for them on each re-render;\n     * 2. Completely skip them in the patching process.\n     */\n    function optimize (root, options) {\n      if (!root) { return }\n      isStaticKey = genStaticKeysCached(options.staticKeys || '');\n      isPlatformReservedTag = options.isReservedTag || no;\n      // first pass: mark all non-static nodes.\n      markStatic$1(root);\n      // second pass: mark static roots.\n      markStaticRoots(root, false);\n    }\n  \n    function genStaticKeys$1 (keys) {\n      return makeMap(\n        'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n        (keys ? ',' + keys : '')\n      )\n    }\n  \n    function markStatic$1 (node) {\n      node.static = isStatic(node);\n      if (node.type === 1) {\n        // do not make component slot content static. this avoids\n        // 1. components not able to mutate slot nodes\n        // 2. static slot content fails for hot-reloading\n        if (\n          !isPlatformReservedTag(node.tag) &&\n          node.tag !== 'slot' &&\n          node.attrsMap['inline-template'] == null\n        ) {\n          return\n        }\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          var child = node.children[i];\n          markStatic$1(child);\n          if (!child.static) {\n            node.static = false;\n          }\n        }\n        if (node.ifConditions) {\n          for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n            var block = node.ifConditions[i$1].block;\n            markStatic$1(block);\n            if (!block.static) {\n              node.static = false;\n            }\n          }\n        }\n      }\n    }\n  \n    function markStaticRoots (node, isInFor) {\n      if (node.type === 1) {\n        if (node.static || node.once) {\n          node.staticInFor = isInFor;\n        }\n        // For a node to qualify as a static root, it should have children that\n        // are not just static text. Otherwise the cost of hoisting out will\n        // outweigh the benefits and it's better off to just always render it fresh.\n        if (node.static && node.children.length && !(\n          node.children.length === 1 &&\n          node.children[0].type === 3\n        )) {\n          node.staticRoot = true;\n          return\n        } else {\n          node.staticRoot = false;\n        }\n        if (node.children) {\n          for (var i = 0, l = node.children.length; i < l; i++) {\n            markStaticRoots(node.children[i], isInFor || !!node.for);\n          }\n        }\n        if (node.ifConditions) {\n          for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n            markStaticRoots(node.ifConditions[i$1].block, isInFor);\n          }\n        }\n      }\n    }\n  \n    function isStatic (node) {\n      if (node.type === 2) { // expression\n        return false\n      }\n      if (node.type === 3) { // text\n        return true\n      }\n      return !!(node.pre || (\n        !node.hasBindings && // no dynamic bindings\n        !node.if && !node.for && // not v-if or v-for or v-else\n        !isBuiltInTag(node.tag) && // not a built-in\n        isPlatformReservedTag(node.tag) && // not a component\n        !isDirectChildOfTemplateFor(node) &&\n        Object.keys(node).every(isStaticKey)\n      ))\n    }\n  \n    function isDirectChildOfTemplateFor (node) {\n      while (node.parent) {\n        node = node.parent;\n        if (node.tag !== 'template') {\n          return false\n        }\n        if (node.for) {\n          return true\n        }\n      }\n      return false\n    }\n  \n    /*  */\n  \n    var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\n    var fnInvokeRE = /\\([^)]*?\\);*$/;\n    var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n  \n    // KeyboardEvent.keyCode aliases\n    var keyCodes = {\n      esc: 27,\n      tab: 9,\n      enter: 13,\n      space: 32,\n      up: 38,\n      left: 37,\n      right: 39,\n      down: 40,\n      'delete': [8, 46]\n    };\n  \n    // KeyboardEvent.key aliases\n    var keyNames = {\n      // #7880: IE11 and Edge use `Esc` for Escape key name.\n      esc: ['Esc', 'Escape'],\n      tab: 'Tab',\n      enter: 'Enter',\n      // #9112: IE11 uses `Spacebar` for Space key name.\n      space: [' ', 'Spacebar'],\n      // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n      up: ['Up', 'ArrowUp'],\n      left: ['Left', 'ArrowLeft'],\n      right: ['Right', 'ArrowRight'],\n      down: ['Down', 'ArrowDown'],\n      // #9112: IE11 uses `Del` for Delete key name.\n      'delete': ['Backspace', 'Delete', 'Del']\n    };\n  \n    // #4868: modifiers that prevent the execution of the listener\n    // need to explicitly return null so that we can determine whether to remove\n    // the listener for .once\n    var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n  \n    var modifierCode = {\n      stop: '$event.stopPropagation();',\n      prevent: '$event.preventDefault();',\n      self: genGuard(\"$event.target !== $event.currentTarget\"),\n      ctrl: genGuard(\"!$event.ctrlKey\"),\n      shift: genGuard(\"!$event.shiftKey\"),\n      alt: genGuard(\"!$event.altKey\"),\n      meta: genGuard(\"!$event.metaKey\"),\n      left: genGuard(\"'button' in $event && $event.button !== 0\"),\n      middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n      right: genGuard(\"'button' in $event && $event.button !== 2\")\n    };\n  \n    function genHandlers (\n      events,\n      isNative\n    ) {\n      var prefix = isNative ? 'nativeOn:' : 'on:';\n      var staticHandlers = \"\";\n      var dynamicHandlers = \"\";\n      for (var name in events) {\n        var handlerCode = genHandler(events[name]);\n        if (events[name] && events[name].dynamic) {\n          dynamicHandlers += name + \",\" + handlerCode + \",\";\n        } else {\n          staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n        }\n      }\n      staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n      if (dynamicHandlers) {\n        return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n      } else {\n        return prefix + staticHandlers\n      }\n    }\n  \n    function genHandler (handler) {\n      if (!handler) {\n        return 'function(){}'\n      }\n  \n      if (Array.isArray(handler)) {\n        return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n      }\n  \n      var isMethodPath = simplePathRE.test(handler.value);\n      var isFunctionExpression = fnExpRE.test(handler.value);\n      var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n  \n      if (!handler.modifiers) {\n        if (isMethodPath || isFunctionExpression) {\n          return handler.value\n        }\n        return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n      } else {\n        var code = '';\n        var genModifierCode = '';\n        var keys = [];\n        for (var key in handler.modifiers) {\n          if (modifierCode[key]) {\n            genModifierCode += modifierCode[key];\n            // left/right\n            if (keyCodes[key]) {\n              keys.push(key);\n            }\n          } else if (key === 'exact') {\n            var modifiers = (handler.modifiers);\n            genModifierCode += genGuard(\n              ['ctrl', 'shift', 'alt', 'meta']\n                .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n                .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n                .join('||')\n            );\n          } else {\n            keys.push(key);\n          }\n        }\n        if (keys.length) {\n          code += genKeyFilter(keys);\n        }\n        // Make sure modifiers like prevent and stop get executed after key filtering\n        if (genModifierCode) {\n          code += genModifierCode;\n        }\n        var handlerCode = isMethodPath\n          ? (\"return \" + (handler.value) + \".apply(null, arguments)\")\n          : isFunctionExpression\n            ? (\"return (\" + (handler.value) + \").apply(null, arguments)\")\n            : isFunctionInvocation\n              ? (\"return \" + (handler.value))\n              : handler.value;\n        return (\"function($event){\" + code + handlerCode + \"}\")\n      }\n    }\n  \n    function genKeyFilter (keys) {\n      return (\n        // make sure the key filters only apply to KeyboardEvents\n        // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n        // key events that do not have keyCode property...\n        \"if(!$event.type.indexOf('key')&&\" +\n        (keys.map(genFilterCode).join('&&')) + \")return null;\"\n      )\n    }\n  \n    function genFilterCode (key) {\n      var keyVal = parseInt(key, 10);\n      if (keyVal) {\n        return (\"$event.keyCode!==\" + keyVal)\n      }\n      var keyCode = keyCodes[key];\n      var keyName = keyNames[key];\n      return (\n        \"_k($event.keyCode,\" +\n        (JSON.stringify(key)) + \",\" +\n        (JSON.stringify(keyCode)) + \",\" +\n        \"$event.key,\" +\n        \"\" + (JSON.stringify(keyName)) +\n        \")\"\n      )\n    }\n  \n    /*  */\n  \n    function on (el, dir) {\n      if (dir.modifiers) {\n        warn(\"v-on without argument does not support modifiers.\");\n      }\n      el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n    }\n  \n    /*  */\n  \n    function bind$1 (el, dir) {\n      el.wrapData = function (code) {\n        return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n      };\n    }\n  \n    /*  */\n  \n    var baseDirectives = {\n      on: on,\n      bind: bind$1,\n      cloak: noop\n    };\n  \n    /*  */\n  \n  \n  \n  \n  \n    var CodegenState = function CodegenState (options) {\n      this.options = options;\n      this.warn = options.warn || baseWarn;\n      this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n      this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n      this.directives = extend(extend({}, baseDirectives), options.directives);\n      var isReservedTag = options.isReservedTag || no;\n      this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n      this.onceId = 0;\n      this.staticRenderFns = [];\n      this.pre = false;\n    };\n  \n  \n  \n    function generate (\n      ast,\n      options\n    ) {\n      var state = new CodegenState(options);\n      // fix #11483, Root level <script> tags should not be rendered.\n      var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c(\"div\")';\n      return {\n        render: (\"with(this){return \" + code + \"}\"),\n        staticRenderFns: state.staticRenderFns\n      }\n    }\n  \n    function genElement (el, state) {\n      if (el.parent) {\n        el.pre = el.pre || el.parent.pre;\n      }\n  \n      if (el.staticRoot && !el.staticProcessed) {\n        return genStatic(el, state)\n      } else if (el.once && !el.onceProcessed) {\n        return genOnce(el, state)\n      } else if (el.for && !el.forProcessed) {\n        return genFor(el, state)\n      } else if (el.if && !el.ifProcessed) {\n        return genIf(el, state)\n      } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n        return genChildren(el, state) || 'void 0'\n      } else if (el.tag === 'slot') {\n        return genSlot(el, state)\n      } else {\n        // component or element\n        var code;\n        if (el.component) {\n          code = genComponent(el.component, el, state);\n        } else {\n          var data;\n          if (!el.plain || (el.pre && state.maybeComponent(el))) {\n            data = genData$2(el, state);\n          }\n  \n          var children = el.inlineTemplate ? null : genChildren(el, state, true);\n          code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n        }\n        // module transforms\n        for (var i = 0; i < state.transforms.length; i++) {\n          code = state.transforms[i](el, code);\n        }\n        return code\n      }\n    }\n  \n    // hoist static sub-trees out\n    function genStatic (el, state) {\n      el.staticProcessed = true;\n      // Some elements (templates) need to behave differently inside of a v-pre\n      // node.  All pre nodes are static roots, so we can use this as a location to\n      // wrap a state change and reset it upon exiting the pre node.\n      var originalPreState = state.pre;\n      if (el.pre) {\n        state.pre = el.pre;\n      }\n      state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n      state.pre = originalPreState;\n      return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n    }\n  \n    // v-once\n    function genOnce (el, state) {\n      el.onceProcessed = true;\n      if (el.if && !el.ifProcessed) {\n        return genIf(el, state)\n      } else if (el.staticInFor) {\n        var key = '';\n        var parent = el.parent;\n        while (parent) {\n          if (parent.for) {\n            key = parent.key;\n            break\n          }\n          parent = parent.parent;\n        }\n        if (!key) {\n          state.warn(\n            \"v-once can only be used inside v-for that is keyed. \",\n            el.rawAttrsMap['v-once']\n          );\n          return genElement(el, state)\n        }\n        return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n      } else {\n        return genStatic(el, state)\n      }\n    }\n  \n    function genIf (\n      el,\n      state,\n      altGen,\n      altEmpty\n    ) {\n      el.ifProcessed = true; // avoid recursion\n      return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n    }\n  \n    function genIfConditions (\n      conditions,\n      state,\n      altGen,\n      altEmpty\n    ) {\n      if (!conditions.length) {\n        return altEmpty || '_e()'\n      }\n  \n      var condition = conditions.shift();\n      if (condition.exp) {\n        return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n      } else {\n        return (\"\" + (genTernaryExp(condition.block)))\n      }\n  \n      // v-if with v-once should generate code like (a)?_m(0):_m(1)\n      function genTernaryExp (el) {\n        return altGen\n          ? altGen(el, state)\n          : el.once\n            ? genOnce(el, state)\n            : genElement(el, state)\n      }\n    }\n  \n    function genFor (\n      el,\n      state,\n      altGen,\n      altHelper\n    ) {\n      var exp = el.for;\n      var alias = el.alias;\n      var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n      var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  \n      if (state.maybeComponent(el) &&\n        el.tag !== 'slot' &&\n        el.tag !== 'template' &&\n        !el.key\n      ) {\n        state.warn(\n          \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n          \"v-for should have explicit keys. \" +\n          \"See https://vuejs.org/guide/list.html#key for more info.\",\n          el.rawAttrsMap['v-for'],\n          true /* tip */\n        );\n      }\n  \n      el.forProcessed = true; // avoid recursion\n      return (altHelper || '_l') + \"((\" + exp + \"),\" +\n        \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n          \"return \" + ((altGen || genElement)(el, state)) +\n        '})'\n    }\n  \n    function genData$2 (el, state) {\n      var data = '{';\n  \n      // directives first.\n      // directives may mutate the el's other properties before they are generated.\n      var dirs = genDirectives(el, state);\n      if (dirs) { data += dirs + ','; }\n  \n      // key\n      if (el.key) {\n        data += \"key:\" + (el.key) + \",\";\n      }\n      // ref\n      if (el.ref) {\n        data += \"ref:\" + (el.ref) + \",\";\n      }\n      if (el.refInFor) {\n        data += \"refInFor:true,\";\n      }\n      // pre\n      if (el.pre) {\n        data += \"pre:true,\";\n      }\n      // record original tag name for components using \"is\" attribute\n      if (el.component) {\n        data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n      }\n      // module data generation functions\n      for (var i = 0; i < state.dataGenFns.length; i++) {\n        data += state.dataGenFns[i](el);\n      }\n      // attributes\n      if (el.attrs) {\n        data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n      }\n      // DOM props\n      if (el.props) {\n        data += \"domProps:\" + (genProps(el.props)) + \",\";\n      }\n      // event handlers\n      if (el.events) {\n        data += (genHandlers(el.events, false)) + \",\";\n      }\n      if (el.nativeEvents) {\n        data += (genHandlers(el.nativeEvents, true)) + \",\";\n      }\n      // slot target\n      // only for non-scoped slots\n      if (el.slotTarget && !el.slotScope) {\n        data += \"slot:\" + (el.slotTarget) + \",\";\n      }\n      // scoped slots\n      if (el.scopedSlots) {\n        data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n      }\n      // component v-model\n      if (el.model) {\n        data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n      }\n      // inline-template\n      if (el.inlineTemplate) {\n        var inlineTemplate = genInlineTemplate(el, state);\n        if (inlineTemplate) {\n          data += inlineTemplate + \",\";\n        }\n      }\n      data = data.replace(/,$/, '') + '}';\n      // v-bind dynamic argument wrap\n      // v-bind with dynamic arguments must be applied using the same v-bind object\n      // merge helper so that class/style/mustUseProp attrs are handled correctly.\n      if (el.dynamicAttrs) {\n        data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n      }\n      // v-bind data wrap\n      if (el.wrapData) {\n        data = el.wrapData(data);\n      }\n      // v-on data wrap\n      if (el.wrapListeners) {\n        data = el.wrapListeners(data);\n      }\n      return data\n    }\n  \n    function genDirectives (el, state) {\n      var dirs = el.directives;\n      if (!dirs) { return }\n      var res = 'directives:[';\n      var hasRuntime = false;\n      var i, l, dir, needRuntime;\n      for (i = 0, l = dirs.length; i < l; i++) {\n        dir = dirs[i];\n        needRuntime = true;\n        var gen = state.directives[dir.name];\n        if (gen) {\n          // compile-time directive that manipulates AST.\n          // returns true if it also needs a runtime counterpart.\n          needRuntime = !!gen(el, dir, state.warn);\n        }\n        if (needRuntime) {\n          hasRuntime = true;\n          res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n        }\n      }\n      if (hasRuntime) {\n        return res.slice(0, -1) + ']'\n      }\n    }\n  \n    function genInlineTemplate (el, state) {\n      var ast = el.children[0];\n      if (el.children.length !== 1 || ast.type !== 1) {\n        state.warn(\n          'Inline-template components must have exactly one child element.',\n          { start: el.start }\n        );\n      }\n      if (ast && ast.type === 1) {\n        var inlineRenderFns = generate(ast, state.options);\n        return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n      }\n    }\n  \n    function genScopedSlots (\n      el,\n      slots,\n      state\n    ) {\n      // by default scoped slots are considered \"stable\", this allows child\n      // components with only scoped slots to skip forced updates from parent.\n      // but in some cases we have to bail-out of this optimization\n      // for example if the slot contains dynamic names, has v-if or v-for on them...\n      var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n        var slot = slots[key];\n        return (\n          slot.slotTargetDynamic ||\n          slot.if ||\n          slot.for ||\n          containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n        )\n      });\n  \n      // #9534: if a component with scoped slots is inside a conditional branch,\n      // it's possible for the same component to be reused but with different\n      // compiled slot content. To avoid that, we generate a unique key based on\n      // the generated code of all the slot contents.\n      var needsKey = !!el.if;\n  \n      // OR when it is inside another scoped slot or v-for (the reactivity may be\n      // disconnected due to the intermediate scope variable)\n      // #9438, #9506\n      // TODO: this can be further optimized by properly analyzing in-scope bindings\n      // and skip force updating ones that do not actually use scope variables.\n      if (!needsForceUpdate) {\n        var parent = el.parent;\n        while (parent) {\n          if (\n            (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n            parent.for\n          ) {\n            needsForceUpdate = true;\n            break\n          }\n          if (parent.if) {\n            needsKey = true;\n          }\n          parent = parent.parent;\n        }\n      }\n  \n      var generatedSlots = Object.keys(slots)\n        .map(function (key) { return genScopedSlot(slots[key], state); })\n        .join(',');\n  \n      return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n    }\n  \n    function hash(str) {\n      var hash = 5381;\n      var i = str.length;\n      while(i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n      }\n      return hash >>> 0\n    }\n  \n    function containsSlotChild (el) {\n      if (el.type === 1) {\n        if (el.tag === 'slot') {\n          return true\n        }\n        return el.children.some(containsSlotChild)\n      }\n      return false\n    }\n  \n    function genScopedSlot (\n      el,\n      state\n    ) {\n      var isLegacySyntax = el.attrsMap['slot-scope'];\n      if (el.if && !el.ifProcessed && !isLegacySyntax) {\n        return genIf(el, state, genScopedSlot, \"null\")\n      }\n      if (el.for && !el.forProcessed) {\n        return genFor(el, state, genScopedSlot)\n      }\n      var slotScope = el.slotScope === emptySlotScopeToken\n        ? \"\"\n        : String(el.slotScope);\n      var fn = \"function(\" + slotScope + \"){\" +\n        \"return \" + (el.tag === 'template'\n          ? el.if && isLegacySyntax\n            ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n            : genChildren(el, state) || 'undefined'\n          : genElement(el, state)) + \"}\";\n      // reverse proxy v-slot without scope on this.$slots\n      var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n      return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n    }\n  \n    function genChildren (\n      el,\n      state,\n      checkSkip,\n      altGenElement,\n      altGenNode\n    ) {\n      var children = el.children;\n      if (children.length) {\n        var el$1 = children[0];\n        // optimize single v-for\n        if (children.length === 1 &&\n          el$1.for &&\n          el$1.tag !== 'template' &&\n          el$1.tag !== 'slot'\n        ) {\n          var normalizationType = checkSkip\n            ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n            : \"\";\n          return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n        }\n        var normalizationType$1 = checkSkip\n          ? getNormalizationType(children, state.maybeComponent)\n          : 0;\n        var gen = altGenNode || genNode;\n        return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n      }\n    }\n  \n    // determine the normalization needed for the children array.\n    // 0: no normalization needed\n    // 1: simple normalization needed (possible 1-level deep nested array)\n    // 2: full normalization needed\n    function getNormalizationType (\n      children,\n      maybeComponent\n    ) {\n      var res = 0;\n      for (var i = 0; i < children.length; i++) {\n        var el = children[i];\n        if (el.type !== 1) {\n          continue\n        }\n        if (needsNormalization(el) ||\n            (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n          res = 2;\n          break\n        }\n        if (maybeComponent(el) ||\n            (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n          res = 1;\n        }\n      }\n      return res\n    }\n  \n    function needsNormalization (el) {\n      return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n    }\n  \n    function genNode (node, state) {\n      if (node.type === 1) {\n        return genElement(node, state)\n      } else if (node.type === 3 && node.isComment) {\n        return genComment(node)\n      } else {\n        return genText(node)\n      }\n    }\n  \n    function genText (text) {\n      return (\"_v(\" + (text.type === 2\n        ? text.expression // no need for () because already wrapped in _s()\n        : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n    }\n  \n    function genComment (comment) {\n      return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n    }\n  \n    function genSlot (el, state) {\n      var slotName = el.slotName || '\"default\"';\n      var children = genChildren(el, state);\n      var res = \"_t(\" + slotName + (children ? (\",function(){return \" + children + \"}\") : '');\n      var attrs = el.attrs || el.dynamicAttrs\n        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n            // slot props are camelized\n            name: camelize(attr.name),\n            value: attr.value,\n            dynamic: attr.dynamic\n          }); }))\n        : null;\n      var bind$$1 = el.attrsMap['v-bind'];\n      if ((attrs || bind$$1) && !children) {\n        res += \",null\";\n      }\n      if (attrs) {\n        res += \",\" + attrs;\n      }\n      if (bind$$1) {\n        res += (attrs ? '' : ',null') + \",\" + bind$$1;\n      }\n      return res + ')'\n    }\n  \n    // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n    function genComponent (\n      componentName,\n      el,\n      state\n    ) {\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n    }\n  \n    function genProps (props) {\n      var staticProps = \"\";\n      var dynamicProps = \"\";\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var value = transformSpecialNewlines(prop.value);\n        if (prop.dynamic) {\n          dynamicProps += (prop.name) + \",\" + value + \",\";\n        } else {\n          staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n        }\n      }\n      staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n      if (dynamicProps) {\n        return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n      } else {\n        return staticProps\n      }\n    }\n  \n    // #3895, #4268\n    function transformSpecialNewlines (text) {\n      return text\n        .replace(/\\u2028/g, '\\\\u2028')\n        .replace(/\\u2029/g, '\\\\u2029')\n    }\n  \n    /*  */\n  \n  \n  \n    // these keywords should not appear inside expressions, but operators like\n    // typeof, instanceof and in are allowed\n    var prohibitedKeywordRE = new RegExp('\\\\b' + (\n      'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n      'super,throw,while,yield,delete,export,import,return,switch,default,' +\n      'extends,finally,continue,debugger,function,arguments'\n    ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n  \n    // these unary operators should not be used as property/method names\n    var unaryOperatorsRE = new RegExp('\\\\b' + (\n      'delete,typeof,void'\n    ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n  \n    // strip strings in expressions\n    var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n  \n    // detect problematic expressions in a template\n    function detectErrors (ast, warn) {\n      if (ast) {\n        checkNode(ast, warn);\n      }\n    }\n  \n    function checkNode (node, warn) {\n      if (node.type === 1) {\n        for (var name in node.attrsMap) {\n          if (dirRE.test(name)) {\n            var value = node.attrsMap[name];\n            if (value) {\n              var range = node.rawAttrsMap[name];\n              if (name === 'v-for') {\n                checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n              } else if (name === 'v-slot' || name[0] === '#') {\n                checkFunctionParameterExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n              } else if (onRE.test(name)) {\n                checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n              } else {\n                checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n              }\n            }\n          }\n        }\n        if (node.children) {\n          for (var i = 0; i < node.children.length; i++) {\n            checkNode(node.children[i], warn);\n          }\n        }\n      } else if (node.type === 2) {\n        checkExpression(node.expression, node.text, warn, node);\n      }\n    }\n  \n    function checkEvent (exp, text, warn, range) {\n      var stripped = exp.replace(stripStringRE, '');\n      var keywordMatch = stripped.match(unaryOperatorsRE);\n      if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n        warn(\n          \"avoid using JavaScript unary operator as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n          range\n        );\n      }\n      checkExpression(exp, text, warn, range);\n    }\n  \n    function checkFor (node, text, warn, range) {\n      checkExpression(node.for || '', text, warn, range);\n      checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n      checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n      checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n    }\n  \n    function checkIdentifier (\n      ident,\n      type,\n      text,\n      warn,\n      range\n    ) {\n      if (typeof ident === 'string') {\n        try {\n          new Function((\"var \" + ident + \"=_\"));\n        } catch (e) {\n          warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n        }\n      }\n    }\n  \n    function checkExpression (exp, text, warn, range) {\n      try {\n        new Function((\"return \" + exp));\n      } catch (e) {\n        var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n        if (keywordMatch) {\n          warn(\n            \"avoid using JavaScript keyword as property name: \" +\n            \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n            range\n          );\n        } else {\n          warn(\n            \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n            \"    \" + exp + \"\\n\\n\" +\n            \"  Raw expression: \" + (text.trim()) + \"\\n\",\n            range\n          );\n        }\n      }\n    }\n  \n    function checkFunctionParameterExpression (exp, text, warn, range) {\n      try {\n        new Function(exp, '');\n      } catch (e) {\n        warn(\n          \"invalid function parameter expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  \n    /*  */\n  \n    var range = 2;\n  \n    function generateCodeFrame (\n      source,\n      start,\n      end\n    ) {\n      if ( start === void 0 ) start = 0;\n      if ( end === void 0 ) end = source.length;\n  \n      var lines = source.split(/\\r?\\n/);\n      var count = 0;\n      var res = [];\n      for (var i = 0; i < lines.length; i++) {\n        count += lines[i].length + 1;\n        if (count >= start) {\n          for (var j = i - range; j <= i + range || end > count; j++) {\n            if (j < 0 || j >= lines.length) { continue }\n            res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n            var lineLength = lines[j].length;\n            if (j === i) {\n              // push underline\n              var pad = start - (count - lineLength) + 1;\n              var length = end > count ? lineLength - pad : end - start;\n              res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n            } else if (j > i) {\n              if (end > count) {\n                var length$1 = Math.min(end - count, lineLength);\n                res.push(\"   |  \" + repeat$1(\"^\", length$1));\n              }\n              count += lineLength + 1;\n            }\n          }\n          break\n        }\n      }\n      return res.join('\\n')\n    }\n  \n    function repeat$1 (str, n) {\n      var result = '';\n      if (n > 0) {\n        while (true) { // eslint-disable-line\n          if (n & 1) { result += str; }\n          n >>>= 1;\n          if (n <= 0) { break }\n          str += str;\n        }\n      }\n      return result\n    }\n  \n    /*  */\n  \n  \n  \n    function createFunction (code, errors) {\n      try {\n        return new Function(code)\n      } catch (err) {\n        errors.push({ err: err, code: code });\n        return noop\n      }\n    }\n  \n    function createCompileToFunctionFn (compile) {\n      var cache = Object.create(null);\n  \n      return function compileToFunctions (\n        template,\n        options,\n        vm\n      ) {\n        options = extend({}, options);\n        var warn$$1 = options.warn || warn;\n        delete options.warn;\n  \n        /* istanbul ignore if */\n        {\n          // detect possible CSP restriction\n          try {\n            new Function('return 1');\n          } catch (e) {\n            if (e.toString().match(/unsafe-eval|CSP/)) {\n              warn$$1(\n                'It seems you are using the standalone build of Vue.js in an ' +\n                'environment with Content Security Policy that prohibits unsafe-eval. ' +\n                'The template compiler cannot work in this environment. Consider ' +\n                'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n                'templates into render functions.'\n              );\n            }\n          }\n        }\n  \n        // check cache\n        var key = options.delimiters\n          ? String(options.delimiters) + template\n          : template;\n        if (cache[key]) {\n          return cache[key]\n        }\n  \n        // compile\n        var compiled = compile(template, options);\n  \n        // check compilation errors/tips\n        {\n          if (compiled.errors && compiled.errors.length) {\n            if (options.outputSourceRange) {\n              compiled.errors.forEach(function (e) {\n                warn$$1(\n                  \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                  generateCodeFrame(template, e.start, e.end),\n                  vm\n                );\n              });\n            } else {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n                compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n                vm\n              );\n            }\n          }\n          if (compiled.tips && compiled.tips.length) {\n            if (options.outputSourceRange) {\n              compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n            } else {\n              compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n            }\n          }\n        }\n  \n        // turn code into functions\n        var res = {};\n        var fnGenErrors = [];\n        res.render = createFunction(compiled.render, fnGenErrors);\n        res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n          return createFunction(code, fnGenErrors)\n        });\n  \n        // check function generation errors.\n        // this should only happen if there is a bug in the compiler itself.\n        // mostly for codegen development use\n        /* istanbul ignore if */\n        {\n          if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n            warn$$1(\n              \"Failed to generate render function:\\n\\n\" +\n              fnGenErrors.map(function (ref) {\n                var err = ref.err;\n                var code = ref.code;\n  \n                return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n            }).join('\\n'),\n              vm\n            );\n          }\n        }\n  \n        return (cache[key] = res)\n      }\n    }\n  \n    /*  */\n  \n    function createCompilerCreator (baseCompile) {\n      return function createCompiler (baseOptions) {\n        function compile (\n          template,\n          options\n        ) {\n          var finalOptions = Object.create(baseOptions);\n          var errors = [];\n          var tips = [];\n  \n          var warn = function (msg, range, tip) {\n            (tip ? tips : errors).push(msg);\n          };\n  \n          if (options) {\n            if (options.outputSourceRange) {\n              // $flow-disable-line\n              var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n  \n              warn = function (msg, range, tip) {\n                var data = { msg: msg };\n                if (range) {\n                  if (range.start != null) {\n                    data.start = range.start + leadingSpaceLength;\n                  }\n                  if (range.end != null) {\n                    data.end = range.end + leadingSpaceLength;\n                  }\n                }\n                (tip ? tips : errors).push(data);\n              };\n            }\n            // merge custom modules\n            if (options.modules) {\n              finalOptions.modules =\n                (baseOptions.modules || []).concat(options.modules);\n            }\n            // merge custom directives\n            if (options.directives) {\n              finalOptions.directives = extend(\n                Object.create(baseOptions.directives || null),\n                options.directives\n              );\n            }\n            // copy other options\n            for (var key in options) {\n              if (key !== 'modules' && key !== 'directives') {\n                finalOptions[key] = options[key];\n              }\n            }\n          }\n  \n          finalOptions.warn = warn;\n  \n          var compiled = baseCompile(template.trim(), finalOptions);\n          {\n            detectErrors(compiled.ast, warn);\n          }\n          compiled.errors = errors;\n          compiled.tips = tips;\n          return compiled\n        }\n  \n        return {\n          compile: compile,\n          compileToFunctions: createCompileToFunctionFn(compile)\n        }\n      }\n    }\n  \n    /*  */\n  \n    // `createCompilerCreator` allows creating compilers that use alternative\n    // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n    // Here we just export a default compiler using the default parts.\n    var createCompiler = createCompilerCreator(function baseCompile (\n      template,\n      options\n    ) {\n      var ast = parse(template.trim(), options);\n      if (options.optimize !== false) {\n        optimize(ast, options);\n      }\n      var code = generate(ast, options);\n      return {\n        ast: ast,\n        render: code.render,\n        staticRenderFns: code.staticRenderFns\n      }\n    });\n  \n    /*  */\n  \n    var ref$1 = createCompiler(baseOptions);\n    var compile = ref$1.compile;\n    var compileToFunctions = ref$1.compileToFunctions;\n  \n    /*  */\n  \n    // check whether current browser encodes a char inside attribute values\n    var div;\n    function getShouldDecode (href) {\n      div = div || document.createElement('div');\n      div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n      return div.innerHTML.indexOf('&#10;') > 0\n    }\n  \n    // #3663: IE encodes newlines inside attribute values while other browsers don't\n    var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n    // #6828: chrome encodes content in a[href]\n    var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  \n    /*  */\n  \n    var idToTemplate = cached(function (id) {\n      var el = query(id);\n      return el && el.innerHTML\n    });\n  \n    var mount = Vue.prototype.$mount;\n    Vue.prototype.$mount = function (\n      el,\n      hydrating\n    ) {\n      el = el && query(el);\n  \n      /* istanbul ignore if */\n      if (el === document.body || el === document.documentElement) {\n        warn(\n          \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n        );\n        return this\n      }\n  \n      var options = this.$options;\n      // resolve template/el and convert to render function\n      if (!options.render) {\n        var template = options.template;\n        if (template) {\n          if (typeof template === 'string') {\n            if (template.charAt(0) === '#') {\n              template = idToTemplate(template);\n              /* istanbul ignore if */\n              if (!template) {\n                warn(\n                  (\"Template element not found or is empty: \" + (options.template)),\n                  this\n                );\n              }\n            }\n          } else if (template.nodeType) {\n            template = template.innerHTML;\n          } else {\n            {\n              warn('invalid template option:' + template, this);\n            }\n            return this\n          }\n        } else if (el) {\n          template = getOuterHTML(el);\n        }\n        if (template) {\n          /* istanbul ignore if */\n          if (config.performance && mark) {\n            mark('compile');\n          }\n  \n          var ref = compileToFunctions(template, {\n            outputSourceRange: \"development\" !== 'production',\n            shouldDecodeNewlines: shouldDecodeNewlines,\n            shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n            delimiters: options.delimiters,\n            comments: options.comments\n          }, this);\n          var render = ref.render;\n          var staticRenderFns = ref.staticRenderFns;\n          options.render = render;\n          options.staticRenderFns = staticRenderFns;\n  \n          /* istanbul ignore if */\n          if (config.performance && mark) {\n            mark('compile end');\n            measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n          }\n        }\n      }\n      return mount.call(this, el, hydrating)\n    };\n  \n    /**\n     * Get outerHTML of elements, taking care\n     * of SVG elements in IE as well.\n     */\n    function getOuterHTML (el) {\n      if (el.outerHTML) {\n        return el.outerHTML\n      } else {\n        var container = document.createElement('div');\n        container.appendChild(el.cloneNode(true));\n        return container.innerHTML\n      }\n    }\n  \n    Vue.compile = compileToFunctions;\n\n    return Vue;\n  \n  });\n  \n\n//Included:lib/003.simplest-db-v1.0.3.part.js\n/*lib:simplest-db@1.0.3 + modifications*/\n(function (root, factory) {\n    const scope = (typeof window !== 'undefined') ? window : global;\n    if(\"SimplestDB\" in scope) return scope.SimplestDB;\n    const output = factory();\n    if(typeof module === 'object' && typeof module.exports === 'object')\n        module.exports = output;\n    if(typeof define === 'function' && define.amd)\n        define([], factory);\n    if(typeof exports === 'object')\n        exports[\"SimplestDB\"] = output;\n    scope[\"SimplestDB\"] = output;\n})(this, function() {\n\n    class SimplestDB {\n\n        static create(...args) {\n            return new this(...args);\n        }\n\n        static getFS() {\n            if(this.$fs) {\n                return this.$fs;\n            }\n            this.$fs = new SimplestDB({\n                schema: \"system\",\n                tables: {\n                    \"fs\": {\n                        columns: {\n                            \"path\": { is_type: \"string\" },\n                            \"contents\": { is_type: \"string\" },\n                            \"metadata\": { is_type: \"object\" },\n                        }\n                    }\n                }\n            });\n            return this.$fs;\n        }\n\n        static getCache() {\n            if(this.$cache) {\n                return this.$cache;\n            }\n            this.$cache = new SimplestDB({\n                schema: \"system\",\n                tables: {\n                    \"cache\": {\n                        columns: {\n                            \"key\": { is_type: \"string\" },\n                            \"value\": { is_type: \"string\" },\n                        }\n                    }\n                }\n            });\n            return this.$cache;\n        }\n\n        constructor(schema = {}, noValidate = false) {\n            if(typeof schema !== \"object\") throw new Error(\"Required «schema» to be an object, found «\" + typeof(schema) + \"» [0301]\");\n            if(typeof schema.schema !== \"string\") schema.schema = \"system\";\n            if(!(\"attributes\" in schema)) {Object.assign(schema, {attributes:{}})}\n            if(!(\"tables\" in schema)) {Object.assign(schema, {tables:{}})}\n            this.schema = this.validateSchema(schema);\n            this.noValidate = noValidate;\n            this.baseDir = (typeof schema.baseDir === \"string\" ? schema.baseDir.replace(/^\\/+/g, \"\").replace(/\\/+$/g, \"\") : \"./sdb_modules\") + \"/\";\n            if(typeof global === \"object\") {\n                const fs = require(\"fs\");\n                const hasBaseDir = fs.existsSync(this.baseDir) && fs.lstatSync(this.baseDir).isDirectory();\n                if(!hasBaseDir) {\n                    fs.mkdirSync(this.baseDir);\n                }\n            }\n        }\n\n        validateTable(tableId) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required parameter table «\" + tableId + \"» to be a string, found «\" + typeof(tableId) + \"» [0101]\");\n            if(this.noValidate) return this.schema.tables[tableId];\n            if(!(tableId in this.schema.tables)) throw new Error(\"Required parameter table «\" + tableId + \"» to exist as table in schema, only accepted: «\" + Object.keys(this.schema.tables).join(\"», «\") + \"» [0402]\");\n            return this.schema.tables[tableId];\n        }\n        \n        validateRow(tableId, value) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required parameter table «\" + tableId + \"» to be a string, found «\" + typeof(tableId) + \"» [0801]\");\n            if(this.noValidate) return this.schema.tables[tableId];\n            if(!(tableId in this.schema.tables)) throw new Error(\"Required parameter table «\" + tableId + \"» to exist as table in schema, only accepted: «\" + Object.keys(this.schema.tables).join(\"», «\") + \"» [0802]\");\n            return true;\n        }\n\n        validateSchema(schema) {\n            if(typeof schema !== \"object\") throw new Error(\"Required «schema» to be an object, found «\" + typeof(schema) + \"» [0301]\");\n            if(typeof schema.schema !== \"string\") throw new Error(\"Required «schema.schema» to be a string, found «\" + typeof(schema) + \"» [0302]\");\n            if(typeof schema.attributes === \"undefined\") schema.attributes = {};\n            if(typeof schema.attributes !== \"object\") throw new Error(\"Required «schema.attributes» to be an object, found «\" + typeof(attributes) + \"» [0303]\");\n            if(typeof schema.tables === \"undefined\") schema.tables = {};\n            if(typeof schema.tables !== \"object\") throw new Error(\"Required «schema.tables» to be an object, found «\" + typeof(tables) + \"» [0304]\");\n            const tableIds = Object.keys(schema.tables);\n            for(let indexTable = 0; indexTable < tableIds.length; indexTable++) {\n                const tableId = tableIds[indexTable];\n                if(typeof schema.tables[tableId] !== \"object\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"]» to be an object, found «\" + typeof(schema.tables[tableId]) + \"» [0305]\");\n                if(typeof schema.tables[tableId].attributes === \"undefined\") schema.tables[tableId].attributes = {};\n                if(typeof schema.tables[tableId].attributes !== \"object\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"].attributes» to be an object, found «\" + typeof(attributes) + \"» [0306]\");\n                if(typeof schema.tables[tableId].columns === \"undefined\") schema.tables[tableId].columns = {};\n                if(typeof schema.tables[tableId].columns !== \"object\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"].columns» to be an object, found «\" + typeof(columns) + \"» [0307]\");\n                const tableData = schema.tables[tableId];\n                const columnIds = Object.keys(tableData.columns);\n                for(let indexColumn = 0; indexColumn < columnIds.length; indexColumn++) {\n                    const columnId = columnIds[indexColumn];\n                    const columnData = tableData.columns[columnId];\n                    if(typeof columnData !== \"object\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"].columns[\" + JSON.stringify(columnId) + \"]»\")\n                    if(typeof columnData.attributes === \"undefined\") columnData.attributes = {};\n                    if(typeof columnData.attributes !== \"object\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"].columns[\" + JSON.stringify(columnId) + \"].attributes»\")\n                    if(typeof columnData.is_type !== \"string\") throw new Error(\"Required «schema.tables[\" + JSON.stringify(tableId) + \"].columns[\" + JSON.stringify(columnId) + \"].is_type»\")\n                }\n            }\n            return schema;\n        }\n\n        setSchema(schema) {\n            this.schema = this.validateSchema(schema);\n        }\n\n        consumeIdOf(tableId) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be an object, found «\" + typeof(tableId) + \"» [0901]\");\n            this.validateTable(tableId);\n            if(typeof window === \"object\") {\n                const storageId = \"SDB_STORAGE_FOR_\" + this.schema.schema;\n                if(!(storageId in localStorage)) {\n                    localStorage[storageId] = JSON.stringify({$KEYS:{[tableId]:1},[tableId]:{}});\n                    return 1;\n                }\n                const storageJson = localStorage[storageId];\n                const storageData = JSON.parse(storageJson);\n                const tableLastId = storageData.$KEYS[tableId]++;\n                localStorage[storageId] = JSON.stringify(storageData);\n                return tableLastId;\n            } else if(typeof global === \"object\") {\n                const storageId = this.baseDir + this.schema.schema + \".data.json\";\n                const fs = require(\"fs\");\n                if(!fs.existsSync(storageId)) {\n                    fs.writeFileSync(storageId, JSON.stringify({$KEYS:{[tableId]:1},[tableId]:{}}));\n                    return 1;\n                }\n                const storageJson = fs.readFileSync(storageId).toString();\n                const storageData = JSON.parse(storageJson);\n                const tableLastId = storageData.$KEYS[tableId]++;\n                fs.writeFileSync(storageId, JSON.stringify(storageData), \"utf8\");\n                return tableLastId;\n            }\n        }\n\n        getData(tableId) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be an object, found «\" + typeof(tableId) + \"» [0401]\");\n            this.validateTable(tableId);\n            if(typeof window === \"object\") {\n                const storageId = \"SDB_STORAGE_FOR_\" + this.schema.schema;\n                if(!(storageId in localStorage)) {\n                    localStorage[storageId] = JSON.stringify({$KEYS:{}});\n                }\n                const storageJson = localStorage[storageId];\n                const storageData = JSON.parse(storageJson);\n                if(!(tableId in storageData)) {\n                    return {};\n                    throw new Error(\"Required model «\" + tableId + \"» to exist in database and not only in schema «\" + this.schema.schema + \"» [0402]\");\n                }\n                return storageData[tableId];\n            } else if(typeof global === \"object\") {\n                const storageId = this.baseDir + this.schema.schema + \".data.json\";\n                const fs = require(\"fs\");\n                if(!fs.existsSync(storageId)) {\n                    fs.writeFileSync(storageId, JSON.stringify({$KEYS:{}}), \"utf8\");\n                }\n                const storageJson = fs.readFileSync(storageId).toString();\n                const storageData = JSON.parse(storageJson);\n                if(!(tableId in storageData)) {\n                    return {};\n                    throw new Error(\"Required model «\" + tableId + \"» to exist in database and not only in schema «\" + this.schema.schema + \"» [0403]\");\n                }\n                return Object.assign({}, storageData[tableId]);\n            }\n        }\n        \n        setData(tableId, modelId, data) {\n            if(typeof window === \"object\") {\n                if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [0501]\");\n                if(typeof modelId !== \"number\") throw new Error(\"Required «modelId» to be an number, found «\" + typeof(modelId) + \"» [0502]\");\n                if(typeof data === \"undefined\") {}\n                else if(typeof data !== \"object\") throw new Error(\"Required «data» to be an object, found «\" + typeof(data) + \"» [0503]\");\n                this.validateTable(tableId);\n                const storageId = \"SDB_STORAGE_FOR_\" + this.schema.schema;\n                if(!(storageId in localStorage)) {\n                    localStorage[storageId] = JSON.stringify({$KEYS:{}});\n                }\n                const storageJson = localStorage[storageId];\n                const storageData = JSON.parse(storageJson);\n                if(!(tableId in storageData)) {\n                    storageData[tableId] = {};\n                    storageData.$KEYS[tableId] = 1;\n                }\n                let operation = \"update\";\n                let selectedId = (modelId === 0) ? storageData.$KEYS[tableId]++ : modelId; \n                if(!(selectedId in storageData[tableId])) {\n                    if(modelId !== 0) {\n                        throw new Error(\"Required parameter modelId «\" + modelId + \"» to be 0 or to exist as id in table «\" + storageId + \":\" + tableId + \"» [0504]\")\n                    } else operation = \"insert\";\n                }\n                if(typeof data === \"undefined\") {\n                    delete storageData[tableId][selectedId];\n                } else {\n                    if(operation === \"insert\") {\n                        data.id = selectedId;\n                    }\n                    storageData[tableId][selectedId] = Object.assign({}, storageData[tableId][selectedId] || {}, data);\n                }\n                const json = JSON.stringify(storageData);\n                localStorage[storageId] = json;\n                return selectedId;\n            } else if(typeof global === \"object\") {\n                if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [1101]\");\n                if(typeof modelId !== \"number\") throw new Error(\"Required «modelId» to be an number, found «\" + typeof(modelId) + \"» [1102]\");\n                if(typeof data === \"undefined\") {}\n                else if(typeof data !== \"object\") throw new Error(\"Required «data» to be an object, found «\" + typeof(data) + \"» [1103]\");\n                this.validateTable(tableId);\n                const fs = require(\"fs\");\n                const storageId = this.baseDir + this.schema.schema + \".data.json\";\n                if(!fs.existsSync(storageId)) {\n                    fs.writeFileSync(storageId, JSON.stringify({[tableId]:{},$KEYS:{[tableId]:1}}), \"utf8\");\n                }\n                const storageJson0 = fs.readFileSync(storageId).toString();\n                const storageData = JSON.parse(storageJson0);\n                if(!(tableId in storageData)) {\n                    storageData[tableId] = {};\n                    storageData.$KEYS[tableId] = 1;\n                }\n                let operation = \"update\";\n                let selectedId = modelId === 0 ? storageData.$KEYS[tableId]++ : modelId; \n                if(!(selectedId in storageData[tableId])) {\n                    if(modelId !== 0) {\n                        throw new Error(\"Required id «\" + modelId + \"» to be 0 (insert) or to exist as id in table «\" + storageId + \":\" + tableId + \"#\" + modelId + \"» [1104]\")\n                    } else operation = \"insert\";\n                }\n                if(typeof data === \"undefined\") {\n                    delete storageData[tableId][selectedId];\n                } else {\n                    if(operation === \"insert\") {\n                        data.id = selectedId;\n                    }\n                    storageData[tableId][selectedId] = Object.assign({}, storageData[tableId][selectedId] || {}, data);\n                }\n                const json = JSON.stringify(storageData);\n                fs.writeFileSync(storageId, json, \"utf8\");\n                return selectedId;\n            }\n        }\n\n        select(tableId, filter) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [0601]\");\n            this.validateTable(tableId);\n            const data = this.getData(tableId);\n            if(typeof filter === \"function\") {\n                return Object.values(data).filter(filter).reduce((output, item) => {\n                    try {\n                        output[item.id] = item;\n                        return output;\n                    } catch (error) {\n                        return false;\n                    }\n                }, {});\n            } else if(typeof filter === \"undefined\") {\n                return data;\n            } else {\n                throw new Error(\"Required «filter» to be a valid, found «\" + typeof(filter) + \"» type [0602]\");\n            }\n        }\n\n        insert(tableId, value) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [0701]\");\n            if(typeof value !== \"object\") throw new Error(\"Required «value» to be an object, found «\" + typeof(value) + \"» [0702]\");\n            this.validateRow(tableId, value);\n            return this.setData(tableId, 0, value);\n        }\n\n        update(tableId, instanceId, value) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [1201]\");\n            if(typeof instanceId !== \"number\") throw new Error(\"Required «instanceId» to be an number, found «\" + typeof(instanceId) + \"» [1202]\");\n            if(typeof value !== \"object\") throw new Error(\"Required «value» to be an object, found «\" + typeof(value) + \"» [1203]\");\n            this.validateRow(tableId, value);\n            return this.setData(tableId, instanceId, value);\n        }\n\n        delete(tableId, instanceId) {\n            if(typeof tableId !== \"string\") throw new Error(\"Required «tableId» to be a string, found «\" + typeof(tableId) + \"» [1401]\");\n            if(typeof instanceId !== \"number\") throw new Error(\"Required «instanceId» to be an number, found «\" + typeof(instanceId) + \"» [1402]\");\n            this.validateTable(tableId);\n            return this.setData(tableId, instanceId, undefined);\n        }\n    }\n  \n    SimplestDB.default = SimplestDB;\n\n    return SimplestDB;\n\n}, this);\n\n//Included:lib/004.ejs.part.js\n(function (factory) {\n  // Only navigators:\n  if (typeof window === 'undefined') return;\n  // General boilerplate:\n  if (typeof window !== \"undefined\") {\n    if (\"i18next\" in window) return window.i18next;\n  }\n  if (typeof global !== \"undefined\") {\n    if (\"i18next\" in global) return global.i18next;\n  }\n  const output = factory();\n  if (typeof module === 'object' && typeof module.exports === 'object') module.exports = output;\n  if (typeof define === 'function' && define.amd) define([], factory);\n  if (typeof exports === 'object') exports[\"i18next\"] = output;\n  if (typeof window !== \"undefined\") {\n    if (typeof window !== 'undefined') window.i18next = output;\n  }\n  if (typeof global !== \"undefined\") {\n    if (typeof global !== 'undefined') global.i18next = output;\n  }\n  return output;\n})(function () {\n  var define, module, exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = \"function\" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error(\"Cannot find module '\" + i + \"'\"); throw a.code = \"MODULE_NOT_FOUND\", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({\n    1: [function (require, module, exports) {\n      /*\n       * EJS Embedded JavaScript templates (v3.1.6)\n       * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n       *\n       * Licensed under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License.\n       * You may obtain a copy of the License at\n       *\n       *         http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software\n       * distributed under the License is distributed on an \"AS IS\" BASIS,\n       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n       * See the License for the specific language governing permissions and\n       * limitations under the License.\n       *\n      */\n\n      'use strict';\n\n      /**\n       * @file Embedded JavaScript templating engine. {@link http://ejs.co}\n       * @author Matthew Eernisse <mde@fleegix.org>\n       * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n       * @project EJS\n       * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n       */\n\n      /**\n       * EJS internal functions.\n       *\n       * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n       * the sake of organization all the private functions re grouped into this\n       * module.\n       *\n       * @module ejs-internal\n       * @private\n       */\n\n      /**\n       * Embedded JavaScript templating engine.\n       *\n       * @module ejs\n       * @public\n       */\n\n      var fs = require('fs');\n      var path = require('path');\n      var utils = require('./utils');\n\n      var scopeOptionWarned = false;\n      /** @type {string} */\n      var _VERSION_STRING = require('../package.json').version;\n      var _DEFAULT_OPEN_DELIMITER = '<';\n      var _DEFAULT_CLOSE_DELIMITER = '>';\n      var _DEFAULT_DELIMITER = '%';\n      var _DEFAULT_LOCALS_NAME = 'locals';\n      var _NAME = 'ejs';\n      var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\n      var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',\n        'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];\n      // We don't allow 'cache' option to be passed in the data obj for\n      // the normal `render` call, but this is where Express 2 & 3 put it\n      // so we make an exception for `renderFile`\n      var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');\n      var _BOM = /^\\uFEFF/;\n\n      /**\n       * EJS template function cache. This can be a LRU object from lru-cache NPM\n       * module. By default, it is {@link module:utils.cache}, a simple in-process\n       * cache that grows continuously.\n       *\n       * @type {Cache}\n       */\n\n      exports.cache = utils.cache;\n\n      /**\n       * Custom file loader. Useful for template preprocessing or restricting access\n       * to a certain part of the filesystem.\n       *\n       * @type {fileLoader}\n       */\n\n      exports.fileLoader = fs.readFileSync;\n\n      /**\n       * Name of the object containing the locals.\n       *\n       * This variable is overridden by {@link Options}`.localsName` if it is not\n       * `undefined`.\n       *\n       * @type {String}\n       * @public\n       */\n\n      exports.localsName = _DEFAULT_LOCALS_NAME;\n\n      /**\n       * Promise implementation -- defaults to the native implementation if available\n       * This is mostly just for testability\n       *\n       * @type {PromiseConstructorLike}\n       * @public\n       */\n\n      exports.promiseImpl = (new Function('return this;'))().Promise;\n\n      /**\n       * Get the path to the included file from the parent file path and the\n       * specified path.\n       *\n       * @param {String}  name     specified path\n       * @param {String}  filename parent file path\n       * @param {Boolean} [isDir=false] whether the parent file path is a directory\n       * @return {String}\n       */\n      exports.resolveInclude = function (name, filename, isDir) {\n        var dirname = path.dirname;\n        var extname = path.extname;\n        var resolve = path.resolve;\n        var includePath = resolve(isDir ? filename : dirname(filename), name);\n        var ext = extname(name);\n        if (!ext) {\n          includePath += '.ejs';\n        }\n        return includePath;\n      };\n\n      /**\n       * Try to resolve file path on multiple directories\n       *\n       * @param  {String}        name  specified path\n       * @param  {Array<String>} paths list of possible parent directory paths\n       * @return {String}\n       */\n      function resolvePaths(name, paths) {\n        var filePath;\n        if (paths.some(function (v) {\n          filePath = exports.resolveInclude(name, v, true);\n          return fs.existsSync(filePath);\n        })) {\n          return filePath;\n        }\n      }\n\n      /**\n       * Get the path to the included file by Options\n       *\n       * @param  {String}  path    specified path\n       * @param  {Options} options compilation options\n       * @return {String}\n       */\n      function getIncludePath(path, options) {\n        var includePath;\n        var filePath;\n        var views = options.views;\n        var match = /^[A-Za-z]+:\\\\|^\\//.exec(path);\n\n        // Abs path\n        if (match && match.length) {\n          path = path.replace(/^\\/*/, '');\n          if (Array.isArray(options.root)) {\n            includePath = resolvePaths(path, options.root);\n          } else {\n            includePath = exports.resolveInclude(path, options.root || '/', true);\n          }\n        }\n        // Relative paths\n        else {\n          // Look relative to a passed filename first\n          if (options.filename) {\n            filePath = exports.resolveInclude(path, options.filename);\n            if (fs.existsSync(filePath)) {\n              includePath = filePath;\n            }\n          }\n          // Then look in any views directories\n          if (!includePath && Array.isArray(views)) {\n            includePath = resolvePaths(path, views);\n          }\n          if (!includePath && typeof options.includer !== 'function') {\n            throw new Error('Could not find the include file \"' +\n              options.escapeFunction(path) + '\"');\n          }\n        }\n        return includePath;\n      }\n\n      /**\n       * Get the template from a string or a file, either compiled on-the-fly or\n       * read from cache (if enabled), and cache the template if needed.\n       *\n       * If `template` is not set, the file specified in `options.filename` will be\n       * read.\n       *\n       * If `options.cache` is true, this function reads the file from\n       * `options.filename` so it must be set prior to calling this function.\n       *\n       * @memberof module:ejs-internal\n       * @param {Options} options   compilation options\n       * @param {String} [template] template source\n       * @return {(TemplateFunction|ClientFunction)}\n       * Depending on the value of `options.client`, either type might be returned.\n       * @static\n       */\n\n      function handleCache(options, template) {\n        var func;\n        var filename = options.filename;\n        var hasTemplate = arguments.length > 1;\n\n        if (options.cache) {\n          if (!filename) {\n            throw new Error('cache option requires a filename');\n          }\n          func = exports.cache.get(filename);\n          if (func) {\n            return func;\n          }\n          if (!hasTemplate) {\n            template = fileLoader(filename).toString().replace(_BOM, '');\n          }\n        }\n        else if (!hasTemplate) {\n          // istanbul ignore if: should not happen at all\n          if (!filename) {\n            throw new Error('Internal EJS error: no file name or template '\n              + 'provided');\n          }\n          template = fileLoader(filename).toString().replace(_BOM, '');\n        }\n        func = exports.compile(template, options);\n        if (options.cache) {\n          exports.cache.set(filename, func);\n        }\n        return func;\n      }\n\n      /**\n       * Try calling handleCache with the given options and data and call the\n       * callback with the result. If an error occurs, call the callback with\n       * the error. Used by renderFile().\n       *\n       * @memberof module:ejs-internal\n       * @param {Options} options    compilation options\n       * @param {Object} data        template data\n       * @param {RenderFileCallback} cb callback\n       * @static\n       */\n\n      function tryHandleCache(options, data, cb) {\n        var result;\n        if (!cb) {\n          if (typeof exports.promiseImpl == 'function') {\n            return new exports.promiseImpl(function (resolve, reject) {\n              try {\n                result = handleCache(options)(data);\n                resolve(result);\n              }\n              catch (err) {\n                reject(err);\n              }\n            });\n          }\n          else {\n            throw new Error('Please provide a callback function');\n          }\n        }\n        else {\n          try {\n            result = handleCache(options)(data);\n          }\n          catch (err) {\n            return cb(err);\n          }\n\n          cb(null, result);\n        }\n      }\n\n      /**\n       * fileLoader is independent\n       *\n       * @param {String} filePath ejs file path.\n       * @return {String} The contents of the specified file.\n       * @static\n       */\n\n      function fileLoader(filePath) {\n        return exports.fileLoader(filePath);\n      }\n\n      /**\n       * Get the template function.\n       *\n       * If `options.cache` is `true`, then the template is cached.\n       *\n       * @memberof module:ejs-internal\n       * @param {String}  path    path for the specified file\n       * @param {Options} options compilation options\n       * @return {(TemplateFunction|ClientFunction)}\n       * Depending on the value of `options.client`, either type might be returned\n       * @static\n       */\n\n      function includeFile(path, options) {\n        var opts = utils.shallowCopy({}, options);\n        opts.filename = getIncludePath(path, opts);\n        if (typeof options.includer === 'function') {\n          var includerResult = options.includer(path, opts.filename);\n          if (includerResult) {\n            if (includerResult.filename) {\n              opts.filename = includerResult.filename;\n            }\n            if (includerResult.template) {\n              return handleCache(opts, includerResult.template);\n            }\n          }\n        }\n        return handleCache(opts);\n      }\n\n      /**\n       * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n       * `lineno`.\n       *\n       * @implements {RethrowCallback}\n       * @memberof module:ejs-internal\n       * @param {Error}  err      Error object\n       * @param {String} str      EJS source\n       * @param {String} flnm     file name of the EJS file\n       * @param {Number} lineno   line number of the error\n       * @param {EscapeCallback} esc\n       * @static\n       */\n\n      function rethrow(err, str, flnm, lineno, esc) {\n        var lines = str.split('\\n');\n        var start = Math.max(lineno - 3, 0);\n        var end = Math.min(lines.length, lineno + 3);\n        var filename = esc(flnm);\n        // Error context\n        var context = lines.slice(start, end).map(function (line, i) {\n          var curr = i + start + 1;\n          return (curr == lineno ? ' >> ' : '    ')\n            + curr\n            + '| '\n            + line;\n        }).join('\\n');\n\n        // Alter exception message\n        err.path = filename;\n        err.message = (filename || 'ejs') + ':'\n          + lineno + '\\n'\n          + context + '\\n\\n'\n          + err.message;\n\n        throw err;\n      }\n\n      function stripSemi(str) {\n        return str.replace(/;(\\s*$)/, '$1');\n      }\n\n      /**\n       * Compile the given `str` of ejs into a template function.\n       *\n       * @param {String}  template EJS template\n       *\n       * @param {Options} [opts] compilation options\n       *\n       * @return {(TemplateFunction|ClientFunction)}\n       * Depending on the value of `opts.client`, either type might be returned.\n       * Note that the return type of the function also depends on the value of `opts.async`.\n       * @public\n       */\n\n      exports.compile = function compile(template, opts) {\n        var templ;\n\n        // v1 compat\n        // 'scope' is 'context'\n        // FIXME: Remove this in a future version\n        if (opts && opts.scope) {\n          if (!scopeOptionWarned) {\n            console.warn('`scope` option is deprecated and will be removed in EJS 3');\n            scopeOptionWarned = true;\n          }\n          if (!opts.context) {\n            opts.context = opts.scope;\n          }\n          delete opts.scope;\n        }\n        templ = new Template(template, opts);\n        return templ.compile();\n      };\n\n      /**\n       * Render the given `template` of ejs.\n       *\n       * If you would like to include options but not data, you need to explicitly\n       * call this function with `data` being an empty object or `null`.\n       *\n       * @param {String}   template EJS template\n       * @param {Object}  [data={}] template data\n       * @param {Options} [opts={}] compilation and rendering options\n       * @return {(String|Promise<String>)}\n       * Return value type depends on `opts.async`.\n       * @public\n       */\n\n      exports.render = function (template, d, o) {\n        var data = d || {};\n        var opts = o || {};\n\n        // No options object -- if there are optiony names\n        // in the data, copy them to options\n        if (arguments.length == 2) {\n          utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);\n        }\n\n        return handleCache(opts, template)(data);\n      };\n\n      /**\n       * Render an EJS file at the given `path` and callback `cb(err, str)`.\n       *\n       * If you would like to include options but not data, you need to explicitly\n       * call this function with `data` being an empty object or `null`.\n       *\n       * @param {String}             path     path to the EJS file\n       * @param {Object}            [data={}] template data\n       * @param {Options}           [opts={}] compilation and rendering options\n       * @param {RenderFileCallback} cb callback\n       * @public\n       */\n\n      exports.renderFile = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var filename = args.shift();\n        var cb;\n        var opts = { filename: filename };\n        var data;\n        var viewOpts;\n\n        // Do we have a callback?\n        if (typeof arguments[arguments.length - 1] == 'function') {\n          cb = args.pop();\n        }\n        // Do we have data/opts?\n        if (args.length) {\n          // Should always have data obj\n          data = args.shift();\n          // Normal passed opts (data obj + opts obj)\n          if (args.length) {\n            // Use shallowCopy so we don't pollute passed in opts obj with new vals\n            utils.shallowCopy(opts, args.pop());\n          }\n          // Special casing for Express (settings + opts-in-data)\n          else {\n            // Express 3 and 4\n            if (data.settings) {\n              // Pull a few things from known locations\n              if (data.settings.views) {\n                opts.views = data.settings.views;\n              }\n              if (data.settings['view cache']) {\n                opts.cache = true;\n              }\n              // Undocumented after Express 2, but still usable, esp. for\n              // items that are unsafe to be passed along with data, like `root`\n              viewOpts = data.settings['view options'];\n              if (viewOpts) {\n                utils.shallowCopy(opts, viewOpts);\n              }\n            }\n            // Express 2 and lower, values set in app.locals, or people who just\n            // want to pass options in their data. NOTE: These values will override\n            // anything previously set in settings  or settings['view options']\n            utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n          }\n          opts.filename = filename;\n        }\n        else {\n          data = {};\n        }\n\n        return tryHandleCache(opts, data, cb);\n      };\n\n      /**\n       * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n       * @public\n       */\n\n      /**\n       * EJS template class\n       * @public\n       */\n      exports.Template = Template;\n\n      exports.clearCache = function () {\n        exports.cache.reset();\n      };\n\n      function Template(text, opts) {\n        opts = opts || {};\n        var options = {};\n        this.templateText = text;\n        /** @type {string | null} */\n        this.mode = null;\n        this.truncate = false;\n        this.currentLine = 1;\n        this.source = '';\n        options.client = opts.client || false;\n        options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;\n        options.compileDebug = opts.compileDebug !== false;\n        options.debug = !!opts.debug;\n        options.filename = opts.filename;\n        options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;\n        options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;\n        options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n        options.strict = opts.strict || false;\n        options.context = opts.context;\n        options.cache = opts.cache || false;\n        options.rmWhitespace = opts.rmWhitespace;\n        options.root = opts.root;\n        options.includer = opts.includer;\n        options.outputFunctionName = opts.outputFunctionName;\n        options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n        options.views = opts.views;\n        options.async = opts.async;\n        options.destructuredLocals = opts.destructuredLocals;\n        options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;\n\n        if (options.strict) {\n          options._with = false;\n        }\n        else {\n          options._with = typeof opts._with != 'undefined' ? opts._with : true;\n        }\n\n        this.opts = options;\n\n        this.regex = this.createRegex();\n      }\n\n      Template.modes = {\n        EVAL: 'eval',\n        ESCAPED: 'escaped',\n        RAW: 'raw',\n        COMMENT: 'comment',\n        LITERAL: 'literal'\n      };\n\n      Template.prototype = {\n        createRegex: function () {\n          var str = _REGEX_STRING;\n          var delim = utils.escapeRegExpChars(this.opts.delimiter);\n          var open = utils.escapeRegExpChars(this.opts.openDelimiter);\n          var close = utils.escapeRegExpChars(this.opts.closeDelimiter);\n          str = str.replace(/%/g, delim)\n            .replace(/</g, open)\n            .replace(/>/g, close);\n          return new RegExp(str);\n        },\n\n        compile: function () {\n          /** @type {string} */\n          var src;\n          /** @type {ClientFunction} */\n          var fn;\n          var opts = this.opts;\n          var prepended = '';\n          var appended = '';\n          /** @type {EscapeCallback} */\n          var escapeFn = opts.escapeFunction;\n          /** @type {FunctionConstructor} */\n          var ctor;\n          /** @type {string} */\n          var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';\n\n          if (!this.source) {\n            this.generateSource();\n            prepended +=\n              '  var __output = \"\";\\n' +\n              '  function __append(s) { if (s !== undefined && s !== null) __output += s }\\n';\n            if (opts.outputFunctionName) {\n              prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n            }\n            if (opts.destructuredLocals && opts.destructuredLocals.length) {\n              var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\\n';\n              for (var i = 0; i < opts.destructuredLocals.length; i++) {\n                var name = opts.destructuredLocals[i];\n                if (i > 0) {\n                  destructuring += ',\\n  ';\n                }\n                destructuring += name + ' = __locals.' + name;\n              }\n              prepended += destructuring + ';\\n';\n            }\n            if (opts._with !== false) {\n              prepended += '  with (' + opts.localsName + ' || {}) {' + '\\n';\n              appended += '  }' + '\\n';\n            }\n            appended += '  return __output;' + '\\n';\n            this.source = prepended + this.source + appended;\n          }\n\n          if (opts.compileDebug) {\n            src = 'var __line = 1' + '\\n'\n              + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n              + '  , __filename = ' + sanitizedFilename + ';' + '\\n'\n              + 'try {' + '\\n'\n              + this.source\n              + '} catch (e) {' + '\\n'\n              + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n'\n              + '}' + '\\n';\n          }\n          else {\n            src = this.source;\n          }\n\n          if (opts.client) {\n            src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n            if (opts.compileDebug) {\n              src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n            }\n          }\n\n          if (opts.strict) {\n            src = '\"use strict\";\\n' + src;\n          }\n          if (opts.debug) {\n            console.log(src);\n          }\n          if (opts.compileDebug && opts.filename) {\n            src = src + '\\n'\n              + '//# sourceURL=' + sanitizedFilename + '\\n';\n          }\n\n          try {\n            if (opts.async) {\n              // Have to use generated function for this, since in envs without support,\n              // it breaks in parsing\n              try {\n                ctor = (new Function('return (async function(){}).constructor;'))();\n              }\n              catch (e) {\n                if (e instanceof SyntaxError) {\n                  throw new Error('This environment does not support async/await');\n                }\n                else {\n                  throw e;\n                }\n              }\n            }\n            else {\n              ctor = Function;\n            }\n            fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);\n          }\n          catch (e) {\n            // istanbul ignore else\n            if (e instanceof SyntaxError) {\n              if (opts.filename) {\n                e.message += ' in ' + opts.filename;\n              }\n              e.message += ' while compiling ejs\\n\\n';\n              e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n              e.message += 'https://github.com/RyanZim/EJS-Lint';\n              if (!opts.async) {\n                e.message += '\\n';\n                e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';\n              }\n            }\n            throw e;\n          }\n\n          // Return a callable function which will execute the function\n          // created by the source-code, with the passed data as locals\n          // Adds a local `include` function which allows full recursive include\n          var returnedFn = opts.client ? fn : function anonymous(data) {\n            var include = function (path, includeData) {\n              var d = utils.shallowCopy({}, data);\n              if (includeData) {\n                d = utils.shallowCopy(d, includeData);\n              }\n              return includeFile(path, opts)(d);\n            };\n            return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]);\n          };\n          if (opts.filename && typeof Object.defineProperty === 'function') {\n            var filename = opts.filename;\n            var basename = path.basename(filename, path.extname(filename));\n            try {\n              Object.defineProperty(returnedFn, 'name', {\n                value: basename,\n                writable: false,\n                enumerable: false,\n                configurable: true\n              });\n            } catch (e) {/* ignore */ }\n          }\n          return returnedFn;\n        },\n\n        generateSource: function () {\n          var opts = this.opts;\n\n          if (opts.rmWhitespace) {\n            // Have to use two separate replace here as `^` and `$` operators don't\n            // work well with `\\r` and empty lines don't work well with the `m` flag.\n            this.templateText =\n              this.templateText.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '');\n          }\n\n          // Slurp spaces and tabs before <%_ and after _%>\n          this.templateText =\n            this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n          var self = this;\n          var matches = this.parseTemplateText();\n          var d = this.opts.delimiter;\n          var o = this.opts.openDelimiter;\n          var c = this.opts.closeDelimiter;\n\n          if (matches && matches.length) {\n            matches.forEach(function (line, index) {\n              var closing;\n              // If this is an opening tag, check for closing tags\n              // FIXME: May end up with some false positives here\n              // Better to store modes as k/v with openDelimiter + delimiter as key\n              // Then this can simply check against the map\n              if (line.indexOf(o + d) === 0        // If it is a tag\n                && line.indexOf(o + d + d) !== 0) { // and is not escaped\n                closing = matches[index + 2];\n                if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {\n                  throw new Error('Could not find matching close tag for \"' + line + '\".');\n                }\n              }\n              self.scanLine(line);\n            });\n          }\n\n        },\n\n        parseTemplateText: function () {\n          var str = this.templateText;\n          var pat = this.regex;\n          var result = pat.exec(str);\n          var arr = [];\n          var firstPos;\n\n          while (result) {\n            firstPos = result.index;\n\n            if (firstPos !== 0) {\n              arr.push(str.substring(0, firstPos));\n              str = str.slice(firstPos);\n            }\n\n            arr.push(result[0]);\n            str = str.slice(result[0].length);\n            result = pat.exec(str);\n          }\n\n          if (str) {\n            arr.push(str);\n          }\n\n          return arr;\n        },\n\n        _addOutput: function (line) {\n          if (this.truncate) {\n            // Only replace single leading linebreak in the line after\n            // -%> tag -- this is the single, trailing linebreak\n            // after the tag that the truncation mode replaces\n            // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n            // combo first in the regex-or\n            line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n            this.truncate = false;\n          }\n          if (!line) {\n            return line;\n          }\n\n          // Preserve literal slashes\n          line = line.replace(/\\\\/g, '\\\\\\\\');\n\n          // Convert linebreaks\n          line = line.replace(/\\n/g, '\\\\n');\n          line = line.replace(/\\r/g, '\\\\r');\n\n          // Escape double-quotes\n          // - this will be the delimiter during execution\n          line = line.replace(/\"/g, '\\\\\"');\n          this.source += '    ; __append(\"' + line + '\")' + '\\n';\n        },\n\n        scanLine: function (line) {\n          var self = this;\n          var d = this.opts.delimiter;\n          var o = this.opts.openDelimiter;\n          var c = this.opts.closeDelimiter;\n          var newLineCount = 0;\n\n          newLineCount = (line.split('\\n').length - 1);\n\n          switch (line) {\n            case o + d:\n            case o + d + '_':\n              this.mode = Template.modes.EVAL;\n              break;\n            case o + d + '=':\n              this.mode = Template.modes.ESCAPED;\n              break;\n            case o + d + '-':\n              this.mode = Template.modes.RAW;\n              break;\n            case o + d + '#':\n              this.mode = Template.modes.COMMENT;\n              break;\n            case o + d + d:\n              this.mode = Template.modes.LITERAL;\n              this.source += '    ; __append(\"' + line.replace(o + d + d, o + d) + '\")' + '\\n';\n              break;\n            case d + d + c:\n              this.mode = Template.modes.LITERAL;\n              this.source += '    ; __append(\"' + line.replace(d + d + c, d + c) + '\")' + '\\n';\n              break;\n            case d + c:\n            case '-' + d + c:\n            case '_' + d + c:\n              if (this.mode == Template.modes.LITERAL) {\n                this._addOutput(line);\n              }\n\n              this.mode = null;\n              this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n              break;\n            default:\n              // In script mode, depends on type of tag\n              if (this.mode) {\n                // If '//' is found without a line break, add a line break.\n                switch (this.mode) {\n                  case Template.modes.EVAL:\n                  case Template.modes.ESCAPED:\n                  case Template.modes.RAW:\n                    if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n                      line += '\\n';\n                    }\n                }\n                switch (this.mode) {\n                  // Just executing code\n                  case Template.modes.EVAL:\n                    this.source += '    ; ' + line + '\\n';\n                    break;\n                  // Exec, esc, and output\n                  case Template.modes.ESCAPED:\n                    this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\\n';\n                    break;\n                  // Exec and output\n                  case Template.modes.RAW:\n                    this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n                    break;\n                  case Template.modes.COMMENT:\n                    // Do nothing\n                    break;\n                  // Literal <%% mode, append as raw output\n                  case Template.modes.LITERAL:\n                    this._addOutput(line);\n                    break;\n                }\n              }\n              // In string mode, just add the output\n              else {\n                this._addOutput(line);\n              }\n          }\n\n          if (self.opts.compileDebug && newLineCount) {\n            this.currentLine += newLineCount;\n            this.source += '    ; __line = ' + this.currentLine + '\\n';\n          }\n        }\n      };\n\n      /**\n       * Escape characters reserved in XML.\n       *\n       * This is simply an export of {@link module:utils.escapeXML}.\n       *\n       * If `markup` is `undefined` or `null`, the empty string is returned.\n       *\n       * @param {String} markup Input string\n       * @return {String} Escaped string\n       * @public\n       * @func\n       * */\n      exports.escapeXML = utils.escapeXML;\n\n      /**\n       * Express.js support.\n       *\n       * This is an alias for {@link module:ejs.renderFile}, in order to support\n       * Express.js out-of-the-box.\n       *\n       * @func\n       */\n\n      exports.__express = exports.renderFile;\n\n      /**\n       * Version of EJS.\n       *\n       * @readonly\n       * @type {String}\n       * @public\n       */\n\n      exports.VERSION = _VERSION_STRING;\n\n      /**\n       * Name for detection of EJS.\n       *\n       * @readonly\n       * @type {String}\n       * @public\n       */\n\n      exports.name = _NAME;\n\n      /* istanbul ignore if */\n      if (typeof window != 'undefined') {\n        window.ejs = exports;\n      }\n\n    }, { \"../package.json\": 6, \"./utils\": 2, \"fs\": 3, \"path\": 4 }], 2: [function (require, module, exports) {\n      /*\n       * EJS Embedded JavaScript templates\n       * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n       *\n       * Licensed under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License.\n       * You may obtain a copy of the License at\n       *\n       *         http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software\n       * distributed under the License is distributed on an \"AS IS\" BASIS,\n       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n       * See the License for the specific language governing permissions and\n       * limitations under the License.\n       *\n      */\n\n      /**\n       * Private utility functions\n       * @module utils\n       * @private\n       */\n\n      'use strict';\n\n      var regExpChars = /[|\\\\{}()[\\]^$+*?.]/g;\n\n      /**\n       * Escape characters reserved in regular expressions.\n       *\n       * If `string` is `undefined` or `null`, the empty string is returned.\n       *\n       * @param {String} string Input string\n       * @return {String} Escaped string\n       * @static\n       * @private\n       */\n      exports.escapeRegExpChars = function (string) {\n        // istanbul ignore if\n        if (!string) {\n          return '';\n        }\n        return String(string).replace(regExpChars, '\\\\$&');\n      };\n\n      var _ENCODE_HTML_RULES = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&#34;',\n        \"'\": '&#39;'\n      };\n      var _MATCH_HTML = /[&<>'\"]/g;\n\n      function encode_char(c) {\n        return _ENCODE_HTML_RULES[c] || c;\n      }\n\n      /**\n       * Stringified version of constants used by {@link module:utils.escapeXML}.\n       *\n       * It is used in the process of generating {@link ClientFunction}s.\n       *\n       * @readonly\n       * @type {String}\n       */\n\n      var escapeFuncStr =\n        'var _ENCODE_HTML_RULES = {\\n'\n        + '      \"&\": \"&amp;\"\\n'\n        + '    , \"<\": \"&lt;\"\\n'\n        + '    , \">\": \"&gt;\"\\n'\n        + '    , \\'\"\\': \"&#34;\"\\n'\n        + '    , \"\\'\": \"&#39;\"\\n'\n        + '    }\\n'\n        + '  , _MATCH_HTML = /[&<>\\'\"]/g;\\n'\n        + 'function encode_char(c) {\\n'\n        + '  return _ENCODE_HTML_RULES[c] || c;\\n'\n        + '};\\n';\n\n      /**\n       * Escape characters reserved in XML.\n       *\n       * If `markup` is `undefined` or `null`, the empty string is returned.\n       *\n       * @implements {EscapeCallback}\n       * @param {String} markup Input string\n       * @return {String} Escaped string\n       * @static\n       * @private\n       */\n\n      exports.escapeXML = function (markup) {\n        return markup == undefined\n          ? ''\n          : String(markup)\n            .replace(_MATCH_HTML, encode_char);\n      };\n      exports.escapeXML.toString = function () {\n        return Function.prototype.toString.call(this) + ';\\n' + escapeFuncStr;\n      };\n\n      /**\n       * Naive copy of properties from one object to another.\n       * Does not recurse into non-scalar properties\n       * Does not check to see if the property has a value before copying\n       *\n       * @param  {Object} to   Destination object\n       * @param  {Object} from Source object\n       * @return {Object}      Destination object\n       * @static\n       * @private\n       */\n      exports.shallowCopy = function (to, from) {\n        from = from || {};\n        for (var p in from) {\n          to[p] = from[p];\n        }\n        return to;\n      };\n\n      /**\n       * Naive copy of a list of key names, from one object to another.\n       * Only copies property if it is actually defined\n       * Does not recurse into non-scalar properties\n       *\n       * @param  {Object} to   Destination object\n       * @param  {Object} from Source object\n       * @param  {Array} list List of properties to copy\n       * @return {Object}      Destination object\n       * @static\n       * @private\n       */\n      exports.shallowCopyFromList = function (to, from, list) {\n        for (var i = 0; i < list.length; i++) {\n          var p = list[i];\n          if (typeof from[p] != 'undefined') {\n            to[p] = from[p];\n          }\n        }\n        return to;\n      };\n\n      /**\n       * Simple in-process cache implementation. Does not implement limits of any\n       * sort.\n       *\n       * @implements {Cache}\n       * @static\n       * @private\n       */\n      exports.cache = {\n        _data: {},\n        set: function (key, val) {\n          this._data[key] = val;\n        },\n        get: function (key) {\n          return this._data[key];\n        },\n        remove: function (key) {\n          delete this._data[key];\n        },\n        reset: function () {\n          this._data = {};\n        }\n      };\n\n      /**\n       * Transforms hyphen case variable into camel case.\n       *\n       * @param {String} string Hyphen case string\n       * @return {String} Camel case string\n       * @static\n       * @private\n       */\n      exports.hyphenToCamel = function (str) {\n        return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });\n      };\n\n    }, {}], 3: [function (require, module, exports) {\n\n    }, {}], 4: [function (require, module, exports) {\n      (function (process) {\n        // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n        // backported and transplited with Babel, with backwards-compat fixes\n\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // resolves . and .. elements in a path array with directory names there\n        // must be no slashes, empty elements, or device names (c:\\) in the array\n        // (so also no leading and trailing slashes - it does not distinguish\n        // relative and absolute paths)\n        function normalizeArray(parts, allowAboveRoot) {\n          // if the path tries to go above the root, `up` ends up > 0\n          var up = 0;\n          for (var i = parts.length - 1; i >= 0; i--) {\n            var last = parts[i];\n            if (last === '.') {\n              parts.splice(i, 1);\n            } else if (last === '..') {\n              parts.splice(i, 1);\n              up++;\n            } else if (up) {\n              parts.splice(i, 1);\n              up--;\n            }\n          }\n\n          // if the path is allowed to go above the root, restore leading ..s\n          if (allowAboveRoot) {\n            for (; up--; up) {\n              parts.unshift('..');\n            }\n          }\n\n          return parts;\n        }\n\n        // path.resolve([from ...], to)\n        // posix version\n        exports.resolve = function () {\n          var resolvedPath = '',\n            resolvedAbsolute = false;\n\n          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            var path = (i >= 0) ? arguments[i] : process.cwd();\n\n            // Skip empty and invalid entries\n            if (typeof path !== 'string') {\n              throw new TypeError('Arguments to path.resolve must be strings');\n            } else if (!path) {\n              continue;\n            }\n\n            resolvedPath = path + '/' + resolvedPath;\n            resolvedAbsolute = path.charAt(0) === '/';\n          }\n\n          // At this point the path should be resolved to a full absolute path, but\n          // handle relative paths to be safe (might happen when process.cwd() fails)\n\n          // Normalize the path\n          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n            return !!p;\n          }), !resolvedAbsolute).join('/');\n\n          return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n        };\n\n        // path.normalize(path)\n        // posix version\n        exports.normalize = function (path) {\n          var isAbsolute = exports.isAbsolute(path),\n            trailingSlash = substr(path, -1) === '/';\n\n          // Normalize the path\n          path = normalizeArray(filter(path.split('/'), function (p) {\n            return !!p;\n          }), !isAbsolute).join('/');\n\n          if (!path && !isAbsolute) {\n            path = '.';\n          }\n          if (path && trailingSlash) {\n            path += '/';\n          }\n\n          return (isAbsolute ? '/' : '') + path;\n        };\n\n        // posix version\n        exports.isAbsolute = function (path) {\n          return path.charAt(0) === '/';\n        };\n\n        // posix version\n        exports.join = function () {\n          var paths = Array.prototype.slice.call(arguments, 0);\n          return exports.normalize(filter(paths, function (p, index) {\n            if (typeof p !== 'string') {\n              throw new TypeError('Arguments to path.join must be strings');\n            }\n            return p;\n          }).join('/'));\n        };\n\n\n        // path.relative(from, to)\n        // posix version\n        exports.relative = function (from, to) {\n          from = exports.resolve(from).substr(1);\n          to = exports.resolve(to).substr(1);\n\n          function trim(arr) {\n            var start = 0;\n            for (; start < arr.length; start++) {\n              if (arr[start] !== '') break;\n            }\n\n            var end = arr.length - 1;\n            for (; end >= 0; end--) {\n              if (arr[end] !== '') break;\n            }\n\n            if (start > end) return [];\n            return arr.slice(start, end - start + 1);\n          }\n\n          var fromParts = trim(from.split('/'));\n          var toParts = trim(to.split('/'));\n\n          var length = Math.min(fromParts.length, toParts.length);\n          var samePartsLength = length;\n          for (var i = 0; i < length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n              samePartsLength = i;\n              break;\n            }\n          }\n\n          var outputParts = [];\n          for (var i = samePartsLength; i < fromParts.length; i++) {\n            outputParts.push('..');\n          }\n\n          outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n          return outputParts.join('/');\n        };\n\n        exports.sep = '/';\n        exports.delimiter = ':';\n\n        exports.dirname = function (path) {\n          if (typeof path !== 'string') path = path + '';\n          if (path.length === 0) return '.';\n          var code = path.charCodeAt(0);\n          var hasRoot = code === 47 /*/*/;\n          var end = -1;\n          var matchedSlash = true;\n          for (var i = path.length - 1; i >= 1; --i) {\n            code = path.charCodeAt(i);\n            if (code === 47 /*/*/) {\n              if (!matchedSlash) {\n                end = i;\n                break;\n              }\n            } else {\n              // We saw the first non-path separator\n              matchedSlash = false;\n            }\n          }\n\n          if (end === -1) return hasRoot ? '/' : '.';\n          if (hasRoot && end === 1) {\n            // return '//';\n            // Backwards-compat fix:\n            return '/';\n          }\n          return path.slice(0, end);\n        };\n\n        function basename(path) {\n          if (typeof path !== 'string') path = path + '';\n\n          var start = 0;\n          var end = -1;\n          var matchedSlash = true;\n          var i;\n\n          for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === 47 /*/*/) {\n              // If we reached a path separator that was not part of a set of path\n              // separators at the end of the string, stop now\n              if (!matchedSlash) {\n                start = i + 1;\n                break;\n              }\n            } else if (end === -1) {\n              // We saw the first non-path separator, mark this as the end of our\n              // path component\n              matchedSlash = false;\n              end = i + 1;\n            }\n          }\n\n          if (end === -1) return '';\n          return path.slice(start, end);\n        }\n\n        // Uses a mixed approach for backwards-compatibility, as ext behavior changed\n        // in new Node.js versions, so only basename() above is backported here\n        exports.basename = function (path, ext) {\n          var f = basename(path);\n          if (ext && f.substr(-1 * ext.length) === ext) {\n            f = f.substr(0, f.length - ext.length);\n          }\n          return f;\n        };\n\n        exports.extname = function (path) {\n          if (typeof path !== 'string') path = path + '';\n          var startDot = -1;\n          var startPart = 0;\n          var end = -1;\n          var matchedSlash = true;\n          // Track the state of characters (if any) we see before our first dot and\n          // after any path separator we find\n          var preDotState = 0;\n          for (var i = path.length - 1; i >= 0; --i) {\n            var code = path.charCodeAt(i);\n            if (code === 47 /*/*/) {\n              // If we reached a path separator that was not part of a set of path\n              // separators at the end of the string, stop now\n              if (!matchedSlash) {\n                startPart = i + 1;\n                break;\n              }\n              continue;\n            }\n            if (end === -1) {\n              // We saw the first non-path separator, mark this as the end of our\n              // extension\n              matchedSlash = false;\n              end = i + 1;\n            }\n            if (code === 46 /*.*/) {\n              // If this is our first dot, mark it as the start of our extension\n              if (startDot === -1)\n                startDot = i;\n              else if (preDotState !== 1)\n                preDotState = 1;\n            } else if (startDot !== -1) {\n              // We saw a non-dot and non-path separator before our dot, so we should\n              // have a good chance at having a non-empty extension\n              preDotState = -1;\n            }\n          }\n\n          if (startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            return '';\n          }\n          return path.slice(startDot, end);\n        };\n\n        function filter(xs, f) {\n          if (xs.filter) return xs.filter(f);\n          var res = [];\n          for (var i = 0; i < xs.length; i++) {\n            if (f(xs[i], i, xs)) res.push(xs[i]);\n          }\n          return res;\n        }\n\n        // String.prototype.substr - negative index don't work in IE8\n        var substr = 'ab'.substr(-1) === 'b'\n          ? function (str, start, len) { return str.substr(start, len) }\n          : function (str, start, len) {\n            if (start < 0) start = str.length + start;\n            return str.substr(start, len);\n          }\n          ;\n\n      }).call(this, require('_process'))\n    }, { \"_process\": 5 }], 5: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {};\n\n      // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      }())\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        }\n        // if setTimeout wasn't available but was latter defined\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n\n\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        }\n        // if clearTimeout wasn't available but was latter defined\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n\n\n\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      // v8 likes predictible objects\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n      process.versions = {};\n\n      function noop() { }\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) { return [] }\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () { return '/' };\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n      process.umask = function () { return 0; };\n\n    }, {}], 6: [function (require, module, exports) {\n      module.exports = {\n        \"name\": \"ejs\",\n        \"description\": \"Embedded JavaScript templates\",\n        \"keywords\": [\n          \"template\",\n          \"engine\",\n          \"ejs\"\n        ],\n        \"version\": \"3.1.6\",\n        \"author\": \"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)\",\n        \"license\": \"Apache-2.0\",\n        \"bin\": {\n          \"ejs\": \"./bin/cli.js\"\n        },\n        \"main\": \"./lib/ejs.js\",\n        \"jsdelivr\": \"ejs.min.js\",\n        \"unpkg\": \"ejs.min.js\",\n        \"repository\": {\n          \"type\": \"git\",\n          \"url\": \"git://github.com/mde/ejs.git\"\n        },\n        \"bugs\": \"https://github.com/mde/ejs/issues\",\n        \"homepage\": \"https://github.com/mde/ejs\",\n        \"dependencies\": {\n          \"jake\": \"^10.6.1\"\n        },\n        \"devDependencies\": {\n          \"browserify\": \"^16.5.1\",\n          \"eslint\": \"^6.8.0\",\n          \"git-directory-deploy\": \"^1.5.1\",\n          \"jsdoc\": \"^3.6.4\",\n          \"lru-cache\": \"^4.0.1\",\n          \"mocha\": \"^7.1.1\",\n          \"uglify-js\": \"^3.3.16\"\n        },\n        \"engines\": {\n          \"node\": \">=0.10.0\"\n        },\n        \"scripts\": {\n          \"test\": \"mocha\"\n        }\n      }\n\n    }, {}]\n  }, {}, [1])(1)\n});\n\n\n//Included:lib/006.castelog.part.js\n\n\n//Included:lib/009.vue-router-v3.5.1.part.js\n/*!\n  * vue-router v3.5.1\n  * (c) 2021 Evan You\n  * @license MIT\n  */\n(function (factory) {\n    // Only navigators:\n    if (typeof window === 'undefined') return;\n    // General boilerplate:\n    if (typeof window !== \"undefined\") {\n        if (\"VueRouter\" in window) return window.VueRouter;\n    }\n    if (typeof global !== \"undefined\") {\n        if (\"VueRouter\" in global) return global.VueRouter;\n    }\n    const output = factory();\n    if (typeof module === 'object' && typeof module.exports === 'object') module.exports = output;\n    if (typeof define === 'function' && define.amd) define([], factory);\n    if (typeof exports === 'object') exports[\"VueRouter\"] = output;\n    if (typeof window !== \"undefined\") {\n        if (typeof window !== 'undefined') window.VueRouter = output;\n    }\n    if (typeof global !== \"undefined\") {\n        if (typeof global !== 'undefined') global.VueRouter = output;\n    }\n    return output;\n}(function () {\n    'use strict';\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error((\"[vue-router] \" + message))\n        }\n    }\n\n    function warn(condition, message) {\n        if (!condition) {\n            typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n        }\n    }\n\n    function extend(a, b) {\n        for (var key in b) {\n            a[key] = b[key];\n        }\n        return a\n    }\n\n    /*  */\n\n    var encodeReserveRE = /[!'()*]/g;\n    var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\n    var commaRE = /%2C/g;\n\n    // fixed encodeURIComponent which is more conformant to RFC3986:\n    // - escapes [!'()*]\n    // - preserve commas\n    var encode = function (str) {\n        return encodeURIComponent(str)\n            .replace(encodeReserveRE, encodeReserveReplacer)\n            .replace(commaRE, ',');\n    };\n\n    function decode(str) {\n        try {\n            return decodeURIComponent(str)\n        } catch (err) {\n            {\n                warn(false, (\"Error decoding \\\"\" + str + \"\\\". Leaving it intact.\"));\n            }\n        }\n        return str\n    }\n\n    function resolveQuery(\n        query,\n        extraQuery,\n        _parseQuery\n    ) {\n        if (extraQuery === void 0) extraQuery = {};\n\n        var parse = _parseQuery || parseQuery;\n        var parsedQuery;\n        try {\n            parsedQuery = parse(query || '');\n        } catch (e) {\n            warn(false, e.message);\n            parsedQuery = {};\n        }\n        for (var key in extraQuery) {\n            var value = extraQuery[key];\n            parsedQuery[key] = Array.isArray(value)\n                ? value.map(castQueryParamValue)\n                : castQueryParamValue(value);\n        }\n        return parsedQuery\n    }\n\n    var castQueryParamValue = function (value) { return (value == null || typeof value === 'object' ? value : String(value)); };\n\n    function parseQuery(query) {\n        var res = {};\n\n        query = query.trim().replace(/^(\\?|#|&)/, '');\n\n        if (!query) {\n            return res\n        }\n\n        query.split('&').forEach(function (param) {\n            var parts = param.replace(/\\+/g, ' ').split('=');\n            var key = decode(parts.shift());\n            var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n            if (res[key] === undefined) {\n                res[key] = val;\n            } else if (Array.isArray(res[key])) {\n                res[key].push(val);\n            } else {\n                res[key] = [res[key], val];\n            }\n        });\n\n        return res\n    }\n\n    function stringifyQuery(obj) {\n        var res = obj\n            ? Object.keys(obj)\n                .map(function (key) {\n                    var val = obj[key];\n\n                    if (val === undefined) {\n                        return ''\n                    }\n\n                    if (val === null) {\n                        return encode(key)\n                    }\n\n                    if (Array.isArray(val)) {\n                        var result = [];\n                        val.forEach(function (val2) {\n                            if (val2 === undefined) {\n                                return\n                            }\n                            if (val2 === null) {\n                                result.push(encode(key));\n                            } else {\n                                result.push(encode(key) + '=' + encode(val2));\n                            }\n                        });\n                        return result.join('&')\n                    }\n\n                    return encode(key) + '=' + encode(val)\n                })\n                .filter(function (x) { return x.length > 0; })\n                .join('&')\n            : null;\n        return res ? (\"?\" + res) : ''\n    }\n\n    /*  */\n\n    var trailingSlashRE = /\\/?$/;\n\n    function createRoute(\n        record,\n        location,\n        redirectedFrom,\n        router\n    ) {\n        var stringifyQuery = router && router.options.stringifyQuery;\n\n        var query = location.query || {};\n        try {\n            query = clone(query);\n        } catch (e) { }\n\n        var route = {\n            name: location.name || (record && record.name),\n            meta: (record && record.meta) || {},\n            path: location.path || '/',\n            hash: location.hash || '',\n            query: query,\n            params: location.params || {},\n            fullPath: getFullPath(location, stringifyQuery),\n            matched: record ? formatMatch(record) : []\n        };\n        if (redirectedFrom) {\n            route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);\n        }\n        return Object.freeze(route)\n    }\n\n    function clone(value) {\n        if (Array.isArray(value)) {\n            return value.map(clone)\n        } else if (value && typeof value === 'object') {\n            var res = {};\n            for (var key in value) {\n                res[key] = clone(value[key]);\n            }\n            return res\n        } else {\n            return value\n        }\n    }\n\n    // the starting route that represents the initial state\n    var START = createRoute(null, {\n        path: '/'\n    });\n\n    function formatMatch(record) {\n        var res = [];\n        while (record) {\n            res.unshift(record);\n            record = record.parent;\n        }\n        return res\n    }\n\n    function getFullPath(\n        ref,\n        _stringifyQuery\n    ) {\n        var path = ref.path;\n        var query = ref.query; if (query === void 0) query = {};\n        var hash = ref.hash; if (hash === void 0) hash = '';\n\n        var stringify = _stringifyQuery || stringifyQuery;\n        return (path || '/') + stringify(query) + hash\n    }\n\n    function isSameRoute(a, b, onlyPath) {\n        if (b === START) {\n            return a === b\n        } else if (!b) {\n            return false\n        } else if (a.path && b.path) {\n            return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && (onlyPath ||\n                a.hash === b.hash &&\n                isObjectEqual(a.query, b.query))\n        } else if (a.name && b.name) {\n            return (\n                a.name === b.name &&\n                (onlyPath || (\n                    a.hash === b.hash &&\n                    isObjectEqual(a.query, b.query) &&\n                    isObjectEqual(a.params, b.params))\n                )\n            )\n        } else {\n            return false\n        }\n    }\n\n    function isObjectEqual(a, b) {\n        if (a === void 0) a = {};\n        if (b === void 0) b = {};\n\n        // handle null value #1566\n        if (!a || !b) { return a === b }\n        var aKeys = Object.keys(a).sort();\n        var bKeys = Object.keys(b).sort();\n        if (aKeys.length !== bKeys.length) {\n            return false\n        }\n        return aKeys.every(function (key, i) {\n            var aVal = a[key];\n            var bKey = bKeys[i];\n            if (bKey !== key) { return false }\n            var bVal = b[key];\n            // query values can be null and undefined\n            if (aVal == null || bVal == null) { return aVal === bVal }\n            // check nested equality\n            if (typeof aVal === 'object' && typeof bVal === 'object') {\n                return isObjectEqual(aVal, bVal)\n            }\n            return String(aVal) === String(bVal)\n        })\n    }\n\n    function isIncludedRoute(current, target) {\n        return (\n            current.path.replace(trailingSlashRE, '/').indexOf(\n                target.path.replace(trailingSlashRE, '/')\n            ) === 0 &&\n            (!target.hash || current.hash === target.hash) &&\n            queryIncludes(current.query, target.query)\n        )\n    }\n\n    function queryIncludes(current, target) {\n        for (var key in target) {\n            if (!(key in current)) {\n                return false\n            }\n        }\n        return true\n    }\n\n    function handleRouteEntered(route) {\n        for (var i = 0; i < route.matched.length; i++) {\n            var record = route.matched[i];\n            for (var name in record.instances) {\n                var instance = record.instances[name];\n                var cbs = record.enteredCbs[name];\n                if (!instance || !cbs) { continue }\n                delete record.enteredCbs[name];\n                for (var i$1 = 0; i$1 < cbs.length; i$1++) {\n                    if (!instance._isBeingDestroyed) { cbs[i$1](instance); }\n                }\n            }\n        }\n    }\n\n    var View = {\n        name: 'RouterView',\n        functional: true,\n        props: {\n            name: {\n                type: String,\n                default: 'default'\n            }\n        },\n        render: function render(_, ref) {\n            var props = ref.props;\n            var children = ref.children;\n            var parent = ref.parent;\n            var data = ref.data;\n\n            // used by devtools to display a router-view badge\n            data.routerView = true;\n\n            // directly use parent context's createElement() function\n            // so that components rendered by router-view can resolve named slots\n            var h = parent.$createElement;\n            var name = props.name;\n            var route = parent.$route;\n            var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n            // determine current view depth, also check to see if the tree\n            // has been toggled inactive but kept-alive.\n            var depth = 0;\n            var inactive = false;\n            while (parent && parent._routerRoot !== parent) {\n                var vnodeData = parent.$vnode ? parent.$vnode.data : {};\n                if (vnodeData.routerView) {\n                    depth++;\n                }\n                if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {\n                    inactive = true;\n                }\n                parent = parent.$parent;\n            }\n            data.routerViewDepth = depth;\n\n            // render previous view if the tree is inactive and kept-alive\n            if (inactive) {\n                var cachedData = cache[name];\n                var cachedComponent = cachedData && cachedData.component;\n                if (cachedComponent) {\n                    // #2301\n                    // pass props\n                    if (cachedData.configProps) {\n                        fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);\n                    }\n                    return h(cachedComponent, data, children)\n                } else {\n                    // render previous empty view\n                    return h()\n                }\n            }\n\n            var matched = route.matched[depth];\n            var component = matched && matched.components[name];\n\n            // render empty node if no matched route or no config component\n            if (!matched || !component) {\n                cache[name] = null;\n                return h()\n            }\n\n            // cache component\n            cache[name] = { component: component };\n\n            // attach instance registration hook\n            // this will be called in the instance's injected lifecycle hooks\n            data.registerRouteInstance = function (vm, val) {\n                // val could be undefined for unregistration\n                var current = matched.instances[name];\n                if (\n                    (val && current !== vm) ||\n                    (!val && current === vm)\n                ) {\n                    matched.instances[name] = val;\n                }\n            }\n\n                // also register instance in prepatch hook\n                // in case the same component instance is reused across different routes\n                ; (data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n                    matched.instances[name] = vnode.componentInstance;\n                };\n\n            // register instance in init hook\n            // in case kept-alive component be actived when routes changed\n            data.hook.init = function (vnode) {\n                if (vnode.data.keepAlive &&\n                    vnode.componentInstance &&\n                    vnode.componentInstance !== matched.instances[name]\n                ) {\n                    matched.instances[name] = vnode.componentInstance;\n                }\n\n                // if the route transition has already been confirmed then we weren't\n                // able to call the cbs during confirmation as the component was not\n                // registered yet, so we call it here.\n                handleRouteEntered(route);\n            };\n\n            var configProps = matched.props && matched.props[name];\n            // save route and configProps in cache\n            if (configProps) {\n                extend(cache[name], {\n                    route: route,\n                    configProps: configProps\n                });\n                fillPropsinData(component, data, route, configProps);\n            }\n\n            return h(component, data, children)\n        }\n    };\n\n    function fillPropsinData(component, data, route, configProps) {\n        // resolve props\n        var propsToPass = data.props = resolveProps(route, configProps);\n        if (propsToPass) {\n            // clone to prevent mutation\n            propsToPass = data.props = extend({}, propsToPass);\n            // pass non-declared props as attrs\n            var attrs = data.attrs = data.attrs || {};\n            for (var key in propsToPass) {\n                if (!component.props || !(key in component.props)) {\n                    attrs[key] = propsToPass[key];\n                    delete propsToPass[key];\n                }\n            }\n        }\n    }\n\n    function resolveProps(route, config) {\n        switch (typeof config) {\n            case 'undefined':\n                return\n            case 'object':\n                return config\n            case 'function':\n                return config(route)\n            case 'boolean':\n                return config ? route.params : undefined\n            default:\n                {\n                    warn(\n                        false,\n                        \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n                        \"expecting an object, function or boolean.\"\n                    );\n                }\n        }\n    }\n\n    /*  */\n\n    function resolvePath(\n        relative,\n        base,\n        append\n    ) {\n        var firstChar = relative.charAt(0);\n        if (firstChar === '/') {\n            return relative\n        }\n\n        if (firstChar === '?' || firstChar === '#') {\n            return base + relative\n        }\n\n        var stack = base.split('/');\n\n        // remove trailing segment if:\n        // - not appending\n        // - appending to trailing slash (last segment is empty)\n        if (!append || !stack[stack.length - 1]) {\n            stack.pop();\n        }\n\n        // resolve relative path\n        var segments = relative.replace(/^\\//, '').split('/');\n        for (var i = 0; i < segments.length; i++) {\n            var segment = segments[i];\n            if (segment === '..') {\n                stack.pop();\n            } else if (segment !== '.') {\n                stack.push(segment);\n            }\n        }\n\n        // ensure leading slash\n        if (stack[0] !== '') {\n            stack.unshift('');\n        }\n\n        return stack.join('/')\n    }\n\n    function parsePath(path) {\n        var hash = '';\n        var query = '';\n\n        var hashIndex = path.indexOf('#');\n        if (hashIndex >= 0) {\n            hash = path.slice(hashIndex);\n            path = path.slice(0, hashIndex);\n        }\n\n        var queryIndex = path.indexOf('?');\n        if (queryIndex >= 0) {\n            query = path.slice(queryIndex + 1);\n            path = path.slice(0, queryIndex);\n        }\n\n        return {\n            path: path,\n            query: query,\n            hash: hash\n        }\n    }\n\n    function cleanPath(path) {\n        return path.replace(/\\/\\//g, '/')\n    }\n\n    var isarray = Array.isArray || function (arr) {\n        return Object.prototype.toString.call(arr) == '[object Array]';\n    };\n\n    /**\n     * Expose `pathToRegexp`.\n     */\n    var pathToRegexp_1 = pathToRegexp;\n    var parse_1 = parse;\n    var compile_1 = compile;\n    var tokensToFunction_1 = tokensToFunction;\n    var tokensToRegExp_1 = tokensToRegExp;\n\n    /**\n     * The main path matching regexp utility.\n     *\n     * @type {RegExp}\n     */\n    var PATH_REGEXP = new RegExp([\n        // Match escaped characters that would otherwise appear in future matches.\n        // This allows the user to escape special characters that won't transform.\n        '(\\\\\\\\.)',\n        // Match Express-style parameters and un-named parameters with a prefix\n        // and optional suffixes. Matches appear as:\n        //\n        // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n        // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n        // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n        '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n    ].join('|'), 'g');\n\n    /**\n     * Parse a string for the raw tokens.\n     *\n     * @param  {string}  str\n     * @param  {Object=} options\n     * @return {!Array}\n     */\n    function parse(str, options) {\n        var tokens = [];\n        var key = 0;\n        var index = 0;\n        var path = '';\n        var defaultDelimiter = options && options.delimiter || '/';\n        var res;\n\n        while ((res = PATH_REGEXP.exec(str)) != null) {\n            var m = res[0];\n            var escaped = res[1];\n            var offset = res.index;\n            path += str.slice(index, offset);\n            index = offset + m.length;\n\n            // Ignore already escaped sequences.\n            if (escaped) {\n                path += escaped[1];\n                continue\n            }\n\n            var next = str[index];\n            var prefix = res[2];\n            var name = res[3];\n            var capture = res[4];\n            var group = res[5];\n            var modifier = res[6];\n            var asterisk = res[7];\n\n            // Push the current path onto the tokens.\n            if (path) {\n                tokens.push(path);\n                path = '';\n            }\n\n            var partial = prefix != null && next != null && next !== prefix;\n            var repeat = modifier === '+' || modifier === '*';\n            var optional = modifier === '?' || modifier === '*';\n            var delimiter = res[2] || defaultDelimiter;\n            var pattern = capture || group;\n\n            tokens.push({\n                name: name || key++,\n                prefix: prefix || '',\n                delimiter: delimiter,\n                optional: optional,\n                repeat: repeat,\n                partial: partial,\n                asterisk: !!asterisk,\n                pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n            });\n        }\n\n        // Match any characters still remaining.\n        if (index < str.length) {\n            path += str.substr(index);\n        }\n\n        // If the path exists, push it onto the end.\n        if (path) {\n            tokens.push(path);\n        }\n\n        return tokens\n    }\n\n    /**\n     * Compile a string to a template function for the path.\n     *\n     * @param  {string}             str\n     * @param  {Object=}            options\n     * @return {!function(Object=, Object=)}\n     */\n    function compile(str, options) {\n        return tokensToFunction(parse(str, options), options)\n    }\n\n    /**\n     * Prettier encoding of URI path segments.\n     *\n     * @param  {string}\n     * @return {string}\n     */\n    function encodeURIComponentPretty(str) {\n        return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n            return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n        })\n    }\n\n    /**\n     * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n     *\n     * @param  {string}\n     * @return {string}\n     */\n    function encodeAsterisk(str) {\n        return encodeURI(str).replace(/[?#]/g, function (c) {\n            return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n        })\n    }\n\n    /**\n     * Expose a method for transforming tokens into the path function.\n     */\n    function tokensToFunction(tokens, options) {\n        // Compile all the tokens into regexps.\n        var matches = new Array(tokens.length);\n\n        // Compile all the patterns before compilation.\n        for (var i = 0; i < tokens.length; i++) {\n            if (typeof tokens[i] === 'object') {\n                matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n            }\n        }\n\n        return function (obj, opts) {\n            var path = '';\n            var data = obj || {};\n            var options = opts || {};\n            var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n            for (var i = 0; i < tokens.length; i++) {\n                var token = tokens[i];\n\n                if (typeof token === 'string') {\n                    path += token;\n\n                    continue\n                }\n\n                var value = data[token.name];\n                var segment;\n\n                if (value == null) {\n                    if (token.optional) {\n                        // Prepend partial segment prefixes.\n                        if (token.partial) {\n                            path += token.prefix;\n                        }\n\n                        continue\n                    } else {\n                        throw new TypeError('Expected \"' + token.name + '\" to be defined')\n                    }\n                }\n\n                if (isarray(value)) {\n                    if (!token.repeat) {\n                        throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n                    }\n\n                    if (value.length === 0) {\n                        if (token.optional) {\n                            continue\n                        } else {\n                            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n                        }\n                    }\n\n                    for (var j = 0; j < value.length; j++) {\n                        segment = encode(value[j]);\n\n                        if (!matches[i].test(segment)) {\n                            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n                        }\n\n                        path += (j === 0 ? token.prefix : token.delimiter) + segment;\n                    }\n\n                    continue\n                }\n\n                segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n                if (!matches[i].test(segment)) {\n                    throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n                }\n\n                path += token.prefix + segment;\n            }\n\n            return path\n        }\n    }\n\n    /**\n     * Escape a regular expression string.\n     *\n     * @param  {string} str\n     * @return {string}\n     */\n    function escapeString(str) {\n        return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n    }\n\n    /**\n     * Escape the capturing group by escaping special characters and meaning.\n     *\n     * @param  {string} group\n     * @return {string}\n     */\n    function escapeGroup(group) {\n        return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n    }\n\n    /**\n     * Attach the keys as a property of the regexp.\n     *\n     * @param  {!RegExp} re\n     * @param  {Array}   keys\n     * @return {!RegExp}\n     */\n    function attachKeys(re, keys) {\n        re.keys = keys;\n        return re\n    }\n\n    /**\n     * Get the flags for a regexp from the options.\n     *\n     * @param  {Object} options\n     * @return {string}\n     */\n    function flags(options) {\n        return options && options.sensitive ? '' : 'i'\n    }\n\n    /**\n     * Pull out keys from a regexp.\n     *\n     * @param  {!RegExp} path\n     * @param  {!Array}  keys\n     * @return {!RegExp}\n     */\n    function regexpToRegexp(path, keys) {\n        // Use a negative lookahead to match only capturing groups.\n        var groups = path.source.match(/\\((?!\\?)/g);\n\n        if (groups) {\n            for (var i = 0; i < groups.length; i++) {\n                keys.push({\n                    name: i,\n                    prefix: null,\n                    delimiter: null,\n                    optional: false,\n                    repeat: false,\n                    partial: false,\n                    asterisk: false,\n                    pattern: null\n                });\n            }\n        }\n\n        return attachKeys(path, keys)\n    }\n\n    /**\n     * Transform an array into a regexp.\n     *\n     * @param  {!Array}  path\n     * @param  {Array}   keys\n     * @param  {!Object} options\n     * @return {!RegExp}\n     */\n    function arrayToRegexp(path, keys, options) {\n        var parts = [];\n\n        for (var i = 0; i < path.length; i++) {\n            parts.push(pathToRegexp(path[i], keys, options).source);\n        }\n\n        var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n        return attachKeys(regexp, keys)\n    }\n\n    /**\n     * Create a path regexp from string input.\n     *\n     * @param  {string}  path\n     * @param  {!Array}  keys\n     * @param  {!Object} options\n     * @return {!RegExp}\n     */\n    function stringToRegexp(path, keys, options) {\n        return tokensToRegExp(parse(path, options), keys, options)\n    }\n\n    /**\n     * Expose a function for taking tokens and returning a RegExp.\n     *\n     * @param  {!Array}          tokens\n     * @param  {(Array|Object)=} keys\n     * @param  {Object=}         options\n     * @return {!RegExp}\n     */\n    function tokensToRegExp(tokens, keys, options) {\n        if (!isarray(keys)) {\n            options = /** @type {!Object} */ (keys || options);\n            keys = [];\n        }\n\n        options = options || {};\n\n        var strict = options.strict;\n        var end = options.end !== false;\n        var route = '';\n\n        // Iterate over the tokens and create our regexp string.\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n\n            if (typeof token === 'string') {\n                route += escapeString(token);\n            } else {\n                var prefix = escapeString(token.prefix);\n                var capture = '(?:' + token.pattern + ')';\n\n                keys.push(token);\n\n                if (token.repeat) {\n                    capture += '(?:' + prefix + capture + ')*';\n                }\n\n                if (token.optional) {\n                    if (!token.partial) {\n                        capture = '(?:' + prefix + '(' + capture + '))?';\n                    } else {\n                        capture = prefix + '(' + capture + ')?';\n                    }\n                } else {\n                    capture = prefix + '(' + capture + ')';\n                }\n\n                route += capture;\n            }\n        }\n\n        var delimiter = escapeString(options.delimiter || '/');\n        var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n        // In non-strict mode we allow a slash at the end of match. If the path to\n        // match already ends with a slash, we remove it for consistency. The slash\n        // is valid at the end of a path match, not in the middle. This is important\n        // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n        if (!strict) {\n            route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n        }\n\n        if (end) {\n            route += '$';\n        } else {\n            // In non-ending mode, we need the capturing groups to match as much as\n            // possible by using a positive lookahead to the end or next path segment.\n            route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n        }\n\n        return attachKeys(new RegExp('^' + route, flags(options)), keys)\n    }\n\n    /**\n     * Normalize the given path string, returning a regular expression.\n     *\n     * An empty array can be passed in for the keys, which will hold the\n     * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n     *\n     * @param  {(string|RegExp|Array)} path\n     * @param  {(Array|Object)=}       keys\n     * @param  {Object=}               options\n     * @return {!RegExp}\n     */\n    function pathToRegexp(path, keys, options) {\n        if (!isarray(keys)) {\n            options = /** @type {!Object} */ (keys || options);\n            keys = [];\n        }\n\n        options = options || {};\n\n        if (path instanceof RegExp) {\n            return regexpToRegexp(path, /** @type {!Array} */(keys))\n        }\n\n        if (isarray(path)) {\n            return arrayToRegexp(/** @type {!Array} */(path), /** @type {!Array} */(keys), options)\n        }\n\n        return stringToRegexp(/** @type {string} */(path), /** @type {!Array} */(keys), options)\n    }\n    pathToRegexp_1.parse = parse_1;\n    pathToRegexp_1.compile = compile_1;\n    pathToRegexp_1.tokensToFunction = tokensToFunction_1;\n    pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n    /*  */\n\n    // $flow-disable-line\n    var regexpCompileCache = Object.create(null);\n\n    function fillParams(\n        path,\n        params,\n        routeMsg\n    ) {\n        params = params || {};\n        try {\n            var filler =\n                regexpCompileCache[path] ||\n                (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n\n            // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}\n            // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string\n            if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }\n\n            return filler(params, { pretty: true })\n        } catch (e) {\n            {\n                // Fix #3072 no warn if `pathMatch` is string\n                warn(typeof params.pathMatch === 'string', (\"missing param for \" + routeMsg + \": \" + (e.message)));\n            }\n            return ''\n        } finally {\n            // delete the 0 if it was added\n            delete params[0];\n        }\n    }\n\n    /*  */\n\n    function normalizeLocation(\n        raw,\n        current,\n        append,\n        router\n    ) {\n        var next = typeof raw === 'string' ? { path: raw } : raw;\n        // named target\n        if (next._normalized) {\n            return next\n        } else if (next.name) {\n            next = extend({}, raw);\n            var params = next.params;\n            if (params && typeof params === 'object') {\n                next.params = extend({}, params);\n            }\n            return next\n        }\n\n        // relative params\n        if (!next.path && next.params && current) {\n            next = extend({}, next);\n            next._normalized = true;\n            var params$1 = extend(extend({}, current.params), next.params);\n            if (current.name) {\n                next.name = current.name;\n                next.params = params$1;\n            } else if (current.matched.length) {\n                var rawPath = current.matched[current.matched.length - 1].path;\n                next.path = fillParams(rawPath, params$1, (\"path \" + (current.path)));\n            } else {\n                warn(false, \"relative params navigation requires a current route.\");\n            }\n            return next\n        }\n\n        var parsedPath = parsePath(next.path || '');\n        var basePath = (current && current.path) || '/';\n        var path = parsedPath.path\n            ? resolvePath(parsedPath.path, basePath, append || next.append)\n            : basePath;\n\n        var query = resolveQuery(\n            parsedPath.query,\n            next.query,\n            router && router.options.parseQuery\n        );\n\n        var hash = next.hash || parsedPath.hash;\n        if (hash && hash.charAt(0) !== '#') {\n            hash = \"#\" + hash;\n        }\n\n        return {\n            _normalized: true,\n            path: path,\n            query: query,\n            hash: hash\n        }\n    }\n\n    /*  */\n\n    // work around weird flow bug\n    var toTypes = [String, Object];\n    var eventTypes = [String, Array];\n\n    var noop = function () { };\n\n    var warnedCustomSlot;\n    var warnedTagProp;\n    var warnedEventProp;\n\n    var Link = {\n        name: 'RouterLink',\n        props: {\n            to: {\n                type: toTypes,\n                required: true\n            },\n            tag: {\n                type: String,\n                default: 'a'\n            },\n            custom: Boolean,\n            exact: Boolean,\n            exactPath: Boolean,\n            append: Boolean,\n            replace: Boolean,\n            activeClass: String,\n            exactActiveClass: String,\n            ariaCurrentValue: {\n                type: String,\n                default: 'page'\n            },\n            event: {\n                type: eventTypes,\n                default: 'click'\n            }\n        },\n        render: function render(h) {\n            var this$1 = this;\n\n            var router = this.$router;\n            var current = this.$route;\n            var ref = router.resolve(\n                this.to,\n                current,\n                this.append\n            );\n            var location = ref.location;\n            var route = ref.route;\n            var href = ref.href;\n\n            var classes = {};\n            var globalActiveClass = router.options.linkActiveClass;\n            var globalExactActiveClass = router.options.linkExactActiveClass;\n            // Support global empty active class\n            var activeClassFallback =\n                globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n            var exactActiveClassFallback =\n                globalExactActiveClass == null\n                    ? 'router-link-exact-active'\n                    : globalExactActiveClass;\n            var activeClass =\n                this.activeClass == null ? activeClassFallback : this.activeClass;\n            var exactActiveClass =\n                this.exactActiveClass == null\n                    ? exactActiveClassFallback\n                    : this.exactActiveClass;\n\n            var compareTarget = route.redirectedFrom\n                ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)\n                : route;\n\n            classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);\n            classes[activeClass] = this.exact || this.exactPath\n                ? classes[exactActiveClass]\n                : isIncludedRoute(current, compareTarget);\n\n            var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;\n\n            var handler = function (e) {\n                if (guardEvent(e)) {\n                    if (this$1.replace) {\n                        router.replace(location, noop);\n                    } else {\n                        router.push(location, noop);\n                    }\n                }\n            };\n\n            var on = { click: guardEvent };\n            if (Array.isArray(this.event)) {\n                this.event.forEach(function (e) {\n                    on[e] = handler;\n                });\n            } else {\n                on[this.event] = handler;\n            }\n\n            var data = { class: classes };\n\n            var scopedSlot =\n                !this.$scopedSlots.$hasNormal &&\n                this.$scopedSlots.default &&\n                this.$scopedSlots.default({\n                    href: href,\n                    route: route,\n                    navigate: handler,\n                    isActive: classes[activeClass],\n                    isExactActive: classes[exactActiveClass]\n                });\n\n            if (scopedSlot) {\n                if (!this.custom) {\n                    !warnedCustomSlot && warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an <a> element. Use the custom prop to remove this warning:\\n<router-link v-slot=\"{ navigate, href }\" custom></router-link>\\n');\n                    warnedCustomSlot = true;\n                }\n                if (scopedSlot.length === 1) {\n                    return scopedSlot[0]\n                } else if (scopedSlot.length > 1 || !scopedSlot.length) {\n                    {\n                        warn(\n                            false,\n                            (\"<router-link> with to=\\\"\" + (this.to) + \"\\\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.\")\n                        );\n                    }\n                    return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)\n                }\n            }\n\n            {\n                if ('tag' in this.$options.propsData && !warnedTagProp) {\n                    warn(\n                        false,\n                        \"<router-link>'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n                    );\n                    warnedTagProp = true;\n                }\n                if ('event' in this.$options.propsData && !warnedEventProp) {\n                    warn(\n                        false,\n                        \"<router-link>'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n                    );\n                    warnedEventProp = true;\n                }\n            }\n\n            if (this.tag === 'a') {\n                data.on = on;\n                data.attrs = { href: href, 'aria-current': ariaCurrentValue };\n            } else {\n                // find the first <a> child and apply listener and href\n                var a = findAnchor(this.$slots.default);\n                if (a) {\n                    // in case the <a> is a static node\n                    a.isStatic = false;\n                    var aData = (a.data = extend({}, a.data));\n                    aData.on = aData.on || {};\n                    // transform existing events in both objects into arrays so we can push later\n                    for (var event in aData.on) {\n                        var handler$1 = aData.on[event];\n                        if (event in on) {\n                            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];\n                        }\n                    }\n                    // append new listeners for router-link\n                    for (var event$1 in on) {\n                        if (event$1 in aData.on) {\n                            // on[event] is always a function\n                            aData.on[event$1].push(on[event$1]);\n                        } else {\n                            aData.on[event$1] = handler;\n                        }\n                    }\n\n                    var aAttrs = (a.data.attrs = extend({}, a.data.attrs));\n                    aAttrs.href = href;\n                    aAttrs['aria-current'] = ariaCurrentValue;\n                } else {\n                    // doesn't have <a> child, apply listener to self\n                    data.on = on;\n                }\n            }\n\n            return h(this.tag, data, this.$slots.default)\n        }\n    };\n\n    function guardEvent(e) {\n        // don't redirect with control keys\n        if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n        // don't redirect when preventDefault called\n        if (e.defaultPrevented) { return }\n        // don't redirect on right click\n        if (e.button !== undefined && e.button !== 0) { return }\n        // don't redirect if `target=\"_blank\"`\n        if (e.currentTarget && e.currentTarget.getAttribute) {\n            var target = e.currentTarget.getAttribute('target');\n            if (/\\b_blank\\b/i.test(target)) { return }\n        }\n        // this may be a Weex event which doesn't have this method\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n        return true\n    }\n\n    function findAnchor(children) {\n        if (children) {\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.tag === 'a') {\n                    return child\n                }\n                if (child.children && (child = findAnchor(child.children))) {\n                    return child\n                }\n            }\n        }\n    }\n\n    var _Vue;\n\n    function install(Vue) {\n        if (install.installed && _Vue === Vue) { return }\n        install.installed = true;\n\n        _Vue = Vue;\n\n        var isDef = function (v) { return v !== undefined; };\n\n        var registerInstance = function (vm, callVal) {\n            var i = vm.$options._parentVnode;\n            if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n                i(vm, callVal);\n            }\n        };\n\n        Vue.mixin({\n            beforeCreate: function beforeCreate() {\n                if (isDef(this.$options.router)) {\n                    this._routerRoot = this;\n                    this._router = this.$options.router;\n                    this._router.init(this);\n                    Vue.util.defineReactive(this, '_route', this._router.history.current);\n                } else {\n                    this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n                }\n                registerInstance(this, this);\n            },\n            destroyed: function destroyed() {\n                registerInstance(this);\n            }\n        });\n\n        Object.defineProperty(Vue.prototype, '$router', {\n            get: function get() { return this._routerRoot._router }\n        });\n\n        Object.defineProperty(Vue.prototype, '$route', {\n            get: function get() { return this._routerRoot._route }\n        });\n\n        Vue.component('RouterView', View);\n        Vue.component('RouterLink', Link);\n\n        var strats = Vue.config.optionMergeStrategies;\n        // use the same hook merging strategy for route hooks\n        strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n    }\n\n    /*  */\n\n    var inBrowser = typeof window !== 'undefined';\n\n    /*  */\n\n    function createRouteMap(\n        routes,\n        oldPathList,\n        oldPathMap,\n        oldNameMap,\n        parentRoute\n    ) {\n        // the path list is used to control path matching priority\n        var pathList = oldPathList || [];\n        // $flow-disable-line\n        var pathMap = oldPathMap || Object.create(null);\n        // $flow-disable-line\n        var nameMap = oldNameMap || Object.create(null);\n\n        routes.forEach(function (route) {\n            addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);\n        });\n\n        // ensure wildcard routes are always at the end\n        for (var i = 0, l = pathList.length; i < l; i++) {\n            if (pathList[i] === '*') {\n                pathList.push(pathList.splice(i, 1)[0]);\n                l--;\n                i--;\n            }\n        }\n\n        {\n            // warn if routes do not include leading slashes\n            var found = pathList\n                // check for missing leading slash\n                .filter(function (path) { return path && path.charAt(0) !== '*' && path.charAt(0) !== '/'; });\n\n            if (found.length > 0) {\n                var pathNames = found.map(function (path) { return (\"- \" + path); }).join('\\n');\n                warn(false, (\"Non-nested routes must include a leading slash character. Fix the following routes: \\n\" + pathNames));\n            }\n        }\n\n        return {\n            pathList: pathList,\n            pathMap: pathMap,\n            nameMap: nameMap\n        }\n    }\n\n    function addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        route,\n        parent,\n        matchAs\n    ) {\n        var path = route.path;\n        var name = route.name;\n        {\n            assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n            assert(\n                typeof route.component !== 'string',\n                \"route config \\\"component\\\" for path: \" + (String(\n                    path || name\n                )) + \" cannot be a \" + \"string id. Use an actual component instead.\"\n            );\n\n            warn(\n                // eslint-disable-next-line no-control-regex\n                !/[^\\u0000-\\u007F]+/.test(path),\n                \"Route with path \\\"\" + path + \"\\\" contains unencoded characters, make sure \" +\n                \"your path is correctly encoded before passing it to the router. Use \" +\n                \"encodeURI to encode static segments of your path.\"\n            );\n        }\n\n        var pathToRegexpOptions =\n            route.pathToRegexpOptions || {};\n        var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n        if (typeof route.caseSensitive === 'boolean') {\n            pathToRegexpOptions.sensitive = route.caseSensitive;\n        }\n\n        var record = {\n            path: normalizedPath,\n            regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n            components: route.components || { default: route.component },\n            alias: route.alias\n                ? typeof route.alias === 'string'\n                    ? [route.alias]\n                    : route.alias\n                : [],\n            instances: {},\n            enteredCbs: {},\n            name: name,\n            parent: parent,\n            matchAs: matchAs,\n            redirect: route.redirect,\n            beforeEnter: route.beforeEnter,\n            meta: route.meta || {},\n            props:\n                route.props == null\n                    ? {}\n                    : route.components\n                        ? route.props\n                        : { default: route.props }\n        };\n\n        if (route.children) {\n            // Warn if route is named, does not redirect and has a default child route.\n            // If users navigate to this route by name, the default child will\n            // not be rendered (GH Issue #629)\n            {\n                if (\n                    route.name &&\n                    !route.redirect &&\n                    route.children.some(function (child) { return /^\\/?$/.test(child.path); })\n                ) {\n                    warn(\n                        false,\n                        \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n                        \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n                        \"the default child route will not be rendered. Remove the name from \" +\n                        \"this route and use the name of the default child route for named \" +\n                        \"links instead.\"\n                    );\n                }\n            }\n            route.children.forEach(function (child) {\n                var childMatchAs = matchAs\n                    ? cleanPath((matchAs + \"/\" + (child.path)))\n                    : undefined;\n                addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n            });\n        }\n\n        if (!pathMap[record.path]) {\n            pathList.push(record.path);\n            pathMap[record.path] = record;\n        }\n\n        if (route.alias !== undefined) {\n            var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n            for (var i = 0; i < aliases.length; ++i) {\n                var alias = aliases[i];\n                if (alias === path) {\n                    warn(\n                        false,\n                        (\"Found an alias with the same value as the path: \\\"\" + path + \"\\\". You have to remove that alias. It will be ignored in development.\")\n                    );\n                    // skip in dev to make it work\n                    continue\n                }\n\n                var aliasRoute = {\n                    path: alias,\n                    children: route.children\n                };\n                addRouteRecord(\n                    pathList,\n                    pathMap,\n                    nameMap,\n                    aliasRoute,\n                    parent,\n                    record.path || '/' // matchAs\n                );\n            }\n        }\n\n        if (name) {\n            if (!nameMap[name]) {\n                nameMap[name] = record;\n            } else if (!matchAs) {\n                warn(\n                    false,\n                    \"Duplicate named routes definition: \" +\n                    \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n                );\n            }\n        }\n    }\n\n    function compileRouteRegex(\n        path,\n        pathToRegexpOptions\n    ) {\n        var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n        {\n            var keys = Object.create(null);\n            regex.keys.forEach(function (key) {\n                warn(\n                    !keys[key.name],\n                    (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\")\n                );\n                keys[key.name] = true;\n            });\n        }\n        return regex\n    }\n\n    function normalizePath(\n        path,\n        parent,\n        strict\n    ) {\n        if (!strict) { path = path.replace(/\\/$/, ''); }\n        if (path[0] === '/') { return path }\n        if (parent == null) { return path }\n        return cleanPath(((parent.path) + \"/\" + path))\n    }\n\n    /*  */\n\n\n\n    function createMatcher(\n        routes,\n        router\n    ) {\n        var ref = createRouteMap(routes);\n        var pathList = ref.pathList;\n        var pathMap = ref.pathMap;\n        var nameMap = ref.nameMap;\n\n        function addRoutes(routes) {\n            createRouteMap(routes, pathList, pathMap, nameMap);\n        }\n\n        function addRoute(parentOrRoute, route) {\n            var parent = (typeof parentOrRoute !== 'object') ? nameMap[parentOrRoute] : undefined;\n            // $flow-disable-line\n            createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);\n\n            // add aliases of parent\n            if (parent) {\n                createRouteMap(\n                    // $flow-disable-line route is defined if parent is\n                    parent.alias.map(function (alias) { return ({ path: alias, children: [route] }); }),\n                    pathList,\n                    pathMap,\n                    nameMap,\n                    parent\n                );\n            }\n        }\n\n        function getRoutes() {\n            return pathList.map(function (path) { return pathMap[path]; })\n        }\n\n        function match(\n            raw,\n            currentRoute,\n            redirectedFrom\n        ) {\n            var location = normalizeLocation(raw, currentRoute, false, router);\n            var name = location.name;\n\n            if (name) {\n                var record = nameMap[name];\n                {\n                    warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n                }\n                if (!record) { return _createRoute(null, location) }\n                var paramNames = record.regex.keys\n                    .filter(function (key) { return !key.optional; })\n                    .map(function (key) { return key.name; });\n\n                if (typeof location.params !== 'object') {\n                    location.params = {};\n                }\n\n                if (currentRoute && typeof currentRoute.params === 'object') {\n                    for (var key in currentRoute.params) {\n                        if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n                            location.params[key] = currentRoute.params[key];\n                        }\n                    }\n                }\n\n                location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n                return _createRoute(record, location, redirectedFrom)\n            } else if (location.path) {\n                location.params = {};\n                for (var i = 0; i < pathList.length; i++) {\n                    var path = pathList[i];\n                    var record$1 = pathMap[path];\n                    if (matchRoute(record$1.regex, location.path, location.params)) {\n                        return _createRoute(record$1, location, redirectedFrom)\n                    }\n                }\n            }\n            // no match\n            return _createRoute(null, location)\n        }\n\n        function redirect(\n            record,\n            location\n        ) {\n            var originalRedirect = record.redirect;\n            var redirect = typeof originalRedirect === 'function'\n                ? originalRedirect(createRoute(record, location, null, router))\n                : originalRedirect;\n\n            if (typeof redirect === 'string') {\n                redirect = { path: redirect };\n            }\n\n            if (!redirect || typeof redirect !== 'object') {\n                {\n                    warn(\n                        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n                    );\n                }\n                return _createRoute(null, location)\n            }\n\n            var re = redirect;\n            var name = re.name;\n            var path = re.path;\n            var query = location.query;\n            var hash = location.hash;\n            var params = location.params;\n            query = re.hasOwnProperty('query') ? re.query : query;\n            hash = re.hasOwnProperty('hash') ? re.hash : hash;\n            params = re.hasOwnProperty('params') ? re.params : params;\n\n            if (name) {\n                // resolved named direct\n                var targetRecord = nameMap[name];\n                {\n                    assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n                }\n                return match({\n                    _normalized: true,\n                    name: name,\n                    query: query,\n                    hash: hash,\n                    params: params\n                }, undefined, location)\n            } else if (path) {\n                // 1. resolve relative redirect\n                var rawPath = resolveRecordPath(path, record);\n                // 2. resolve params\n                var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n                // 3. rematch with existing query and hash\n                return match({\n                    _normalized: true,\n                    path: resolvedPath,\n                    query: query,\n                    hash: hash\n                }, undefined, location)\n            } else {\n                {\n                    warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n                }\n                return _createRoute(null, location)\n            }\n        }\n\n        function alias(\n            record,\n            location,\n            matchAs\n        ) {\n            var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n            var aliasedMatch = match({\n                _normalized: true,\n                path: aliasedPath\n            });\n            if (aliasedMatch) {\n                var matched = aliasedMatch.matched;\n                var aliasedRecord = matched[matched.length - 1];\n                location.params = aliasedMatch.params;\n                return _createRoute(aliasedRecord, location)\n            }\n            return _createRoute(null, location)\n        }\n\n        function _createRoute(\n            record,\n            location,\n            redirectedFrom\n        ) {\n            if (record && record.redirect) {\n                return redirect(record, redirectedFrom || location)\n            }\n            if (record && record.matchAs) {\n                return alias(record, location, record.matchAs)\n            }\n            return createRoute(record, location, redirectedFrom, router)\n        }\n\n        return {\n            match: match,\n            addRoute: addRoute,\n            getRoutes: getRoutes,\n            addRoutes: addRoutes\n        }\n    }\n\n    function matchRoute(\n        regex,\n        path,\n        params\n    ) {\n        var m = path.match(regex);\n\n        if (!m) {\n            return false\n        } else if (!params) {\n            return true\n        }\n\n        for (var i = 1, len = m.length; i < len; ++i) {\n            var key = regex.keys[i - 1];\n            if (key) {\n                // Fix #1994: using * with props: true generates a param named 0\n                params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];\n            }\n        }\n\n        return true\n    }\n\n    function resolveRecordPath(path, record) {\n        return resolvePath(path, record.parent ? record.parent.path : '/', true)\n    }\n\n    /*  */\n\n    // use User Timing api (if present) for more accurate key precision\n    var Time =\n        inBrowser && window.performance && window.performance.now\n            ? window.performance\n            : Date;\n\n    function genStateKey() {\n        return Time.now().toFixed(3)\n    }\n\n    var _key = genStateKey();\n\n    function getStateKey() {\n        return _key\n    }\n\n    function setStateKey(key) {\n        return (_key = key)\n    }\n\n    /*  */\n\n    var positionStore = Object.create(null);\n\n    function setupScroll() {\n        // Prevent browser scroll behavior on History popstate\n        if ('scrollRestoration' in window.history) {\n            window.history.scrollRestoration = 'manual';\n        }\n        // Fix for #1585 for Firefox\n        // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n        // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with\n        // window.location.protocol + '//' + window.location.host\n        // location.host contains the port and location.hostname doesn't\n        var protocolAndPath = window.location.protocol + '//' + window.location.host;\n        var absolutePath = window.location.href.replace(protocolAndPath, '');\n        // preserve existing history state as it could be overriden by the user\n        var stateCopy = extend({}, window.history.state);\n        stateCopy.key = getStateKey();\n        window.history.replaceState(stateCopy, '', absolutePath);\n        window.addEventListener('popstate', handlePopState);\n        return function () {\n            window.removeEventListener('popstate', handlePopState);\n        }\n    }\n\n    function handleScroll(\n        router,\n        to,\n        from,\n        isPop\n    ) {\n        if (!router.app) {\n            return\n        }\n\n        var behavior = router.options.scrollBehavior;\n        if (!behavior) {\n            return\n        }\n\n        {\n            assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n        }\n\n        // wait until re-render finishes before scrolling\n        router.app.$nextTick(function () {\n            var position = getScrollPosition();\n            var shouldScroll = behavior.call(\n                router,\n                to,\n                from,\n                isPop ? position : null\n            );\n\n            if (!shouldScroll) {\n                return\n            }\n\n            if (typeof shouldScroll.then === 'function') {\n                shouldScroll\n                    .then(function (shouldScroll) {\n                        scrollToPosition((shouldScroll), position);\n                    })\n                    .catch(function (err) {\n                        {\n                            assert(false, err.toString());\n                        }\n                    });\n            } else {\n                scrollToPosition(shouldScroll, position);\n            }\n        });\n    }\n\n    function saveScrollPosition() {\n        var key = getStateKey();\n        if (key) {\n            positionStore[key] = {\n                x: window.pageXOffset,\n                y: window.pageYOffset\n            };\n        }\n    }\n\n    function handlePopState(e) {\n        saveScrollPosition();\n        if (e.state && e.state.key) {\n            setStateKey(e.state.key);\n        }\n    }\n\n    function getScrollPosition() {\n        var key = getStateKey();\n        if (key) {\n            return positionStore[key]\n        }\n    }\n\n    function getElementPosition(el, offset) {\n        var docEl = document.documentElement;\n        var docRect = docEl.getBoundingClientRect();\n        var elRect = el.getBoundingClientRect();\n        return {\n            x: elRect.left - docRect.left - offset.x,\n            y: elRect.top - docRect.top - offset.y\n        }\n    }\n\n    function isValidPosition(obj) {\n        return isNumber(obj.x) || isNumber(obj.y)\n    }\n\n    function normalizePosition(obj) {\n        return {\n            x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n            y: isNumber(obj.y) ? obj.y : window.pageYOffset\n        }\n    }\n\n    function normalizeOffset(obj) {\n        return {\n            x: isNumber(obj.x) ? obj.x : 0,\n            y: isNumber(obj.y) ? obj.y : 0\n        }\n    }\n\n    function isNumber(v) {\n        return typeof v === 'number'\n    }\n\n    var hashStartsWithNumberRE = /^#\\d/;\n\n    function scrollToPosition(shouldScroll, position) {\n        var isObject = typeof shouldScroll === 'object';\n        if (isObject && typeof shouldScroll.selector === 'string') {\n            // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]\n            // but at the same time, it doesn't make much sense to select an element with an id and an extra selector\n            var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line\n                ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line\n                : document.querySelector(shouldScroll.selector);\n\n            if (el) {\n                var offset =\n                    shouldScroll.offset && typeof shouldScroll.offset === 'object'\n                        ? shouldScroll.offset\n                        : {};\n                offset = normalizeOffset(offset);\n                position = getElementPosition(el, offset);\n            } else if (isValidPosition(shouldScroll)) {\n                position = normalizePosition(shouldScroll);\n            }\n        } else if (isObject && isValidPosition(shouldScroll)) {\n            position = normalizePosition(shouldScroll);\n        }\n\n        if (position) {\n            // $flow-disable-line\n            if ('scrollBehavior' in document.documentElement.style) {\n                window.scrollTo({\n                    left: position.x,\n                    top: position.y,\n                    // $flow-disable-line\n                    behavior: shouldScroll.behavior\n                });\n            } else {\n                window.scrollTo(position.x, position.y);\n            }\n        }\n    }\n\n    /*  */\n\n    var supportsPushState =\n        inBrowser &&\n        (function () {\n            var ua = window.navigator.userAgent;\n\n            if (\n                (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n                ua.indexOf('Mobile Safari') !== -1 &&\n                ua.indexOf('Chrome') === -1 &&\n                ua.indexOf('Windows Phone') === -1\n            ) {\n                return false\n            }\n\n            return window.history && typeof window.history.pushState === 'function'\n        })();\n\n    function pushState(url, replace) {\n        saveScrollPosition();\n        // try...catch the pushState call to get around Safari\n        // DOM Exception 18 where it limits to 100 pushState calls\n        var history = window.history;\n        try {\n            if (replace) {\n                // preserve existing history state as it could be overriden by the user\n                var stateCopy = extend({}, history.state);\n                stateCopy.key = getStateKey();\n                history.replaceState(stateCopy, '', url);\n            } else {\n                history.pushState({ key: setStateKey(genStateKey()) }, '', url);\n            }\n        } catch (e) {\n            window.location[replace ? 'replace' : 'assign'](url);\n        }\n    }\n\n    function replaceState(url) {\n        pushState(url, true);\n    }\n\n    /*  */\n\n    function runQueue(queue, fn, cb) {\n        var step = function (index) {\n            if (index >= queue.length) {\n                cb();\n            } else {\n                if (queue[index]) {\n                    fn(queue[index], function () {\n                        step(index + 1);\n                    });\n                } else {\n                    step(index + 1);\n                }\n            }\n        };\n        step(0);\n    }\n\n    // When changing thing, also edit router.d.ts\n    var NavigationFailureType = {\n        redirected: 2,\n        aborted: 4,\n        cancelled: 8,\n        duplicated: 16\n    };\n\n    function createNavigationRedirectedError(from, to) {\n        return createRouterError(\n            from,\n            to,\n            NavigationFailureType.redirected,\n            (\"Redirected when going from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (stringifyRoute(\n                to\n            )) + \"\\\" via a navigation guard.\")\n        )\n    }\n\n    function createNavigationDuplicatedError(from, to) {\n        var error = createRouterError(\n            from,\n            to,\n            NavigationFailureType.duplicated,\n            (\"Avoided redundant navigation to current location: \\\"\" + (from.fullPath) + \"\\\".\")\n        );\n        // backwards compatible with the first introduction of Errors\n        error.name = 'NavigationDuplicated';\n        return error\n    }\n\n    function createNavigationCancelledError(from, to) {\n        return createRouterError(\n            from,\n            to,\n            NavigationFailureType.cancelled,\n            (\"Navigation cancelled from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" with a new navigation.\")\n        )\n    }\n\n    function createNavigationAbortedError(from, to) {\n        return createRouterError(\n            from,\n            to,\n            NavigationFailureType.aborted,\n            (\"Navigation aborted from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" via a navigation guard.\")\n        )\n    }\n\n    function createRouterError(from, to, type, message) {\n        var error = new Error(message);\n        error._isRouter = true;\n        error.from = from;\n        error.to = to;\n        error.type = type;\n\n        return error\n    }\n\n    var propertiesToLog = ['params', 'query', 'hash'];\n\n    function stringifyRoute(to) {\n        if (typeof to === 'string') { return to }\n        if ('path' in to) { return to.path }\n        var location = {};\n        propertiesToLog.forEach(function (key) {\n            if (key in to) { location[key] = to[key]; }\n        });\n        return JSON.stringify(location, null, 2)\n    }\n\n    function isError(err) {\n        return Object.prototype.toString.call(err).indexOf('Error') > -1\n    }\n\n    function isNavigationFailure(err, errorType) {\n        return (\n            isError(err) &&\n            err._isRouter &&\n            (errorType == null || err.type === errorType)\n        )\n    }\n\n    /*  */\n\n    function resolveAsyncComponents(matched) {\n        return function (to, from, next) {\n            var hasAsync = false;\n            var pending = 0;\n            var error = null;\n\n            flatMapComponents(matched, function (def, _, match, key) {\n                // if it's a function and doesn't have cid attached,\n                // assume it's an async component resolve function.\n                // we are not using Vue's default async resolving mechanism because\n                // we want to halt the navigation until the incoming component has been\n                // resolved.\n                if (typeof def === 'function' && def.cid === undefined) {\n                    hasAsync = true;\n                    pending++;\n\n                    var resolve = once(function (resolvedDef) {\n                        if (isESModule(resolvedDef)) {\n                            resolvedDef = resolvedDef.default;\n                        }\n                        // save resolved on async factory in case it's used elsewhere\n                        def.resolved = typeof resolvedDef === 'function'\n                            ? resolvedDef\n                            : _Vue.extend(resolvedDef);\n                        match.components[key] = resolvedDef;\n                        pending--;\n                        if (pending <= 0) {\n                            next();\n                        }\n                    });\n\n                    var reject = once(function (reason) {\n                        var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n                        warn(false, msg);\n                        if (!error) {\n                            error = isError(reason)\n                                ? reason\n                                : new Error(msg);\n                            next(error);\n                        }\n                    });\n\n                    var res;\n                    try {\n                        res = def(resolve, reject);\n                    } catch (e) {\n                        reject(e);\n                    }\n                    if (res) {\n                        if (typeof res.then === 'function') {\n                            res.then(resolve, reject);\n                        } else {\n                            // new syntax in Vue 2.3\n                            var comp = res.component;\n                            if (comp && typeof comp.then === 'function') {\n                                comp.then(resolve, reject);\n                            }\n                        }\n                    }\n                }\n            });\n\n            if (!hasAsync) { next(); }\n        }\n    }\n\n    function flatMapComponents(\n        matched,\n        fn\n    ) {\n        return flatten(matched.map(function (m) {\n            return Object.keys(m.components).map(function (key) {\n                return fn(\n                    m.components[key],\n                    m.instances[key],\n                    m, key\n                );\n            })\n        }))\n    }\n\n    function flatten(arr) {\n        return Array.prototype.concat.apply([], arr)\n    }\n\n    var hasSymbol =\n        typeof Symbol === 'function' &&\n        typeof Symbol.toStringTag === 'symbol';\n\n    function isESModule(obj) {\n        return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\n    }\n\n    // in Webpack 2, require.ensure now also returns a Promise\n    // so the resolve/reject functions may get called an extra time\n    // if the user uses an arrow function shorthand that happens to\n    // return that Promise.\n    function once(fn) {\n        var called = false;\n        return function () {\n            var args = [], len = arguments.length;\n            while (len--) args[len] = arguments[len];\n\n            if (called) { return }\n            called = true;\n            return fn.apply(this, args)\n        }\n    }\n\n    /*  */\n\n    var History = function History(router, base) {\n        this.router = router;\n        this.base = normalizeBase(base);\n        // start with a route object that stands for \"nowhere\"\n        this.current = START;\n        this.pending = null;\n        this.ready = false;\n        this.readyCbs = [];\n        this.readyErrorCbs = [];\n        this.errorCbs = [];\n        this.listeners = [];\n    };\n\n    History.prototype.listen = function listen(cb) {\n        this.cb = cb;\n    };\n\n    History.prototype.onReady = function onReady(cb, errorCb) {\n        if (this.ready) {\n            cb();\n        } else {\n            this.readyCbs.push(cb);\n            if (errorCb) {\n                this.readyErrorCbs.push(errorCb);\n            }\n        }\n    };\n\n    History.prototype.onError = function onError(errorCb) {\n        this.errorCbs.push(errorCb);\n    };\n\n    History.prototype.transitionTo = function transitionTo(\n        location,\n        onComplete,\n        onAbort\n    ) {\n        var this$1 = this;\n\n        var route;\n        // catch redirect option https://github.com/vuejs/vue-router/issues/3201\n        try {\n            route = this.router.match(location, this.current);\n        } catch (e) {\n            this.errorCbs.forEach(function (cb) {\n                cb(e);\n            });\n            // Exception should still be thrown\n            throw e\n        }\n        var prev = this.current;\n        this.confirmTransition(\n            route,\n            function () {\n                this$1.updateRoute(route);\n                onComplete && onComplete(route);\n                this$1.ensureURL();\n                this$1.router.afterHooks.forEach(function (hook) {\n                    hook && hook(route, prev);\n                });\n\n                // fire ready cbs once\n                if (!this$1.ready) {\n                    this$1.ready = true;\n                    this$1.readyCbs.forEach(function (cb) {\n                        cb(route);\n                    });\n                }\n            },\n            function (err) {\n                if (onAbort) {\n                    onAbort(err);\n                }\n                if (err && !this$1.ready) {\n                    // Initial redirection should not mark the history as ready yet\n                    // because it's triggered by the redirection instead\n                    // https://github.com/vuejs/vue-router/issues/3225\n                    // https://github.com/vuejs/vue-router/issues/3331\n                    if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {\n                        this$1.ready = true;\n                        this$1.readyErrorCbs.forEach(function (cb) {\n                            cb(err);\n                        });\n                    }\n                }\n            }\n        );\n    };\n\n    History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n        var this$1 = this;\n\n        var current = this.current;\n        this.pending = route;\n        var abort = function (err) {\n            // changed after adding errors with\n            // https://github.com/vuejs/vue-router/pull/3047 before that change,\n            // redirect and aborted navigation would produce an err == null\n            if (!isNavigationFailure(err) && isError(err)) {\n                if (this$1.errorCbs.length) {\n                    this$1.errorCbs.forEach(function (cb) {\n                        cb(err);\n                    });\n                } else {\n                    warn(false, 'uncaught error during route navigation:');\n                    console.error(err);\n                }\n            }\n            onAbort && onAbort(err);\n        };\n        var lastRouteIndex = route.matched.length - 1;\n        var lastCurrentIndex = current.matched.length - 1;\n        if (\n            isSameRoute(route, current) &&\n            // in the case the route map has been dynamically appended to\n            lastRouteIndex === lastCurrentIndex &&\n            route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]\n        ) {\n            this.ensureURL();\n            return abort(createNavigationDuplicatedError(current, route))\n        }\n\n        var ref = resolveQueue(\n            this.current.matched,\n            route.matched\n        );\n        var updated = ref.updated;\n        var deactivated = ref.deactivated;\n        var activated = ref.activated;\n\n        var queue = [].concat(\n            // in-component leave guards\n            extractLeaveGuards(deactivated),\n            // global before hooks\n            this.router.beforeHooks,\n            // in-component update hooks\n            extractUpdateHooks(updated),\n            // in-config enter guards\n            activated.map(function (m) { return m.beforeEnter; }),\n            // async components\n            resolveAsyncComponents(activated)\n        );\n\n        var iterator = function (hook, next) {\n            if (this$1.pending !== route) {\n                return abort(createNavigationCancelledError(current, route))\n            }\n            try {\n                hook(route, current, function (to) {\n                    if (to === false) {\n                        // next(false) -> abort navigation, ensure current URL\n                        this$1.ensureURL(true);\n                        abort(createNavigationAbortedError(current, route));\n                    } else if (isError(to)) {\n                        this$1.ensureURL(true);\n                        abort(to);\n                    } else if (\n                        typeof to === 'string' ||\n                        (typeof to === 'object' &&\n                            (typeof to.path === 'string' || typeof to.name === 'string'))\n                    ) {\n                        // next('/') or next({ path: '/' }) -> redirect\n                        abort(createNavigationRedirectedError(current, route));\n                        if (typeof to === 'object' && to.replace) {\n                            this$1.replace(to);\n                        } else {\n                            this$1.push(to);\n                        }\n                    } else {\n                        // confirm transition and pass on the value\n                        next(to);\n                    }\n                });\n            } catch (e) {\n                abort(e);\n            }\n        };\n\n        runQueue(queue, iterator, function () {\n            // wait until async components are resolved before\n            // extracting in-component enter guards\n            var enterGuards = extractEnterGuards(activated);\n            var queue = enterGuards.concat(this$1.router.resolveHooks);\n            runQueue(queue, iterator, function () {\n                if (this$1.pending !== route) {\n                    return abort(createNavigationCancelledError(current, route))\n                }\n                this$1.pending = null;\n                onComplete(route);\n                if (this$1.router.app) {\n                    this$1.router.app.$nextTick(function () {\n                        handleRouteEntered(route);\n                    });\n                }\n            });\n        });\n    };\n\n    History.prototype.updateRoute = function updateRoute(route) {\n        this.current = route;\n        this.cb && this.cb(route);\n    };\n\n    History.prototype.setupListeners = function setupListeners() {\n        // Default implementation is empty\n    };\n\n    History.prototype.teardown = function teardown() {\n        // clean up event listeners\n        // https://github.com/vuejs/vue-router/issues/2341\n        this.listeners.forEach(function (cleanupListener) {\n            cleanupListener();\n        });\n        this.listeners = [];\n\n        // reset current history route\n        // https://github.com/vuejs/vue-router/issues/3294\n        this.current = START;\n        this.pending = null;\n    };\n\n    function normalizeBase(base) {\n        if (!base) {\n            if (inBrowser) {\n                // respect <base> tag\n                var baseEl = document.querySelector('base');\n                base = (baseEl && baseEl.getAttribute('href')) || '/';\n                // strip full URL origin\n                base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n            } else {\n                base = '/';\n            }\n        }\n        // make sure there's the starting slash\n        if (base.charAt(0) !== '/') {\n            base = '/' + base;\n        }\n        // remove trailing slash\n        return base.replace(/\\/$/, '')\n    }\n\n    function resolveQueue(\n        current,\n        next\n    ) {\n        var i;\n        var max = Math.max(current.length, next.length);\n        for (i = 0; i < max; i++) {\n            if (current[i] !== next[i]) {\n                break\n            }\n        }\n        return {\n            updated: next.slice(0, i),\n            activated: next.slice(i),\n            deactivated: current.slice(i)\n        }\n    }\n\n    function extractGuards(\n        records,\n        name,\n        bind,\n        reverse\n    ) {\n        var guards = flatMapComponents(records, function (def, instance, match, key) {\n            var guard = extractGuard(def, name);\n            if (guard) {\n                return Array.isArray(guard)\n                    ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n                    : bind(guard, instance, match, key)\n            }\n        });\n        return flatten(reverse ? guards.reverse() : guards)\n    }\n\n    function extractGuard(\n        def,\n        key\n    ) {\n        if (typeof def !== 'function') {\n            // extend now so that global mixins are applied.\n            def = _Vue.extend(def);\n        }\n        return def.options[key]\n    }\n\n    function extractLeaveGuards(deactivated) {\n        return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n    }\n\n    function extractUpdateHooks(updated) {\n        return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n    }\n\n    function bindGuard(guard, instance) {\n        if (instance) {\n            return function boundRouteGuard() {\n                return guard.apply(instance, arguments)\n            }\n        }\n    }\n\n    function extractEnterGuards(\n        activated\n    ) {\n        return extractGuards(\n            activated,\n            'beforeRouteEnter',\n            function (guard, _, match, key) {\n                return bindEnterGuard(guard, match, key)\n            }\n        )\n    }\n\n    function bindEnterGuard(\n        guard,\n        match,\n        key\n    ) {\n        return function routeEnterGuard(to, from, next) {\n            return guard(to, from, function (cb) {\n                if (typeof cb === 'function') {\n                    if (!match.enteredCbs[key]) {\n                        match.enteredCbs[key] = [];\n                    }\n                    match.enteredCbs[key].push(cb);\n                }\n                next(cb);\n            })\n        }\n    }\n\n    /*  */\n\n    var HTML5History = /*@__PURE__*/(function (History) {\n        function HTML5History(router, base) {\n            History.call(this, router, base);\n\n            this._startLocation = getLocation(this.base);\n        }\n\n        if (History) HTML5History.__proto__ = History;\n        HTML5History.prototype = Object.create(History && History.prototype);\n        HTML5History.prototype.constructor = HTML5History;\n\n        HTML5History.prototype.setupListeners = function setupListeners() {\n            var this$1 = this;\n\n            if (this.listeners.length > 0) {\n                return\n            }\n\n            var router = this.router;\n            var expectScroll = router.options.scrollBehavior;\n            var supportsScroll = supportsPushState && expectScroll;\n\n            if (supportsScroll) {\n                this.listeners.push(setupScroll());\n            }\n\n            var handleRoutingEvent = function () {\n                var current = this$1.current;\n\n                // Avoiding first `popstate` event dispatched in some browsers but first\n                // history route not updated since async guard at the same time.\n                var location = getLocation(this$1.base);\n                if (this$1.current === START && location === this$1._startLocation) {\n                    return\n                }\n\n                this$1.transitionTo(location, function (route) {\n                    if (supportsScroll) {\n                        handleScroll(router, route, current, true);\n                    }\n                });\n            };\n            window.addEventListener('popstate', handleRoutingEvent);\n            this.listeners.push(function () {\n                window.removeEventListener('popstate', handleRoutingEvent);\n            });\n        };\n\n        HTML5History.prototype.go = function go(n) {\n            window.history.go(n);\n        };\n\n        HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            var ref = this;\n            var fromRoute = ref.current;\n            this.transitionTo(location, function (route) {\n                pushState(cleanPath(this$1.base + route.fullPath));\n                handleScroll(this$1.router, route, fromRoute, false);\n                onComplete && onComplete(route);\n            }, onAbort);\n        };\n\n        HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            var ref = this;\n            var fromRoute = ref.current;\n            this.transitionTo(location, function (route) {\n                replaceState(cleanPath(this$1.base + route.fullPath));\n                handleScroll(this$1.router, route, fromRoute, false);\n                onComplete && onComplete(route);\n            }, onAbort);\n        };\n\n        HTML5History.prototype.ensureURL = function ensureURL(push) {\n            if (getLocation(this.base) !== this.current.fullPath) {\n                var current = cleanPath(this.base + this.current.fullPath);\n                push ? pushState(current) : replaceState(current);\n            }\n        };\n\n        HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n            return getLocation(this.base)\n        };\n\n        return HTML5History;\n    }(History));\n\n    function getLocation(base) {\n        var path = window.location.pathname;\n        if (base && path.toLowerCase().indexOf(base.toLowerCase()) === 0) {\n            path = path.slice(base.length);\n        }\n        return (path || '/') + window.location.search + window.location.hash\n    }\n\n    /*  */\n\n    var HashHistory = /*@__PURE__*/(function (History) {\n        function HashHistory(router, base, fallback) {\n            History.call(this, router, base);\n            // check history fallback deeplinking\n            if (fallback && checkFallback(this.base)) {\n                return\n            }\n            ensureSlash();\n        }\n\n        if (History) HashHistory.__proto__ = History;\n        HashHistory.prototype = Object.create(History && History.prototype);\n        HashHistory.prototype.constructor = HashHistory;\n\n        // this is delayed until the app mounts\n        // to avoid the hashchange listener being fired too early\n        HashHistory.prototype.setupListeners = function setupListeners() {\n            var this$1 = this;\n\n            if (this.listeners.length > 0) {\n                return\n            }\n\n            var router = this.router;\n            var expectScroll = router.options.scrollBehavior;\n            var supportsScroll = supportsPushState && expectScroll;\n\n            if (supportsScroll) {\n                this.listeners.push(setupScroll());\n            }\n\n            var handleRoutingEvent = function () {\n                var current = this$1.current;\n                if (!ensureSlash()) {\n                    return\n                }\n                this$1.transitionTo(getHash(), function (route) {\n                    if (supportsScroll) {\n                        handleScroll(this$1.router, route, current, true);\n                    }\n                    if (!supportsPushState) {\n                        replaceHash(route.fullPath);\n                    }\n                });\n            };\n            var eventType = supportsPushState ? 'popstate' : 'hashchange';\n            window.addEventListener(\n                eventType,\n                handleRoutingEvent\n            );\n            this.listeners.push(function () {\n                window.removeEventListener(eventType, handleRoutingEvent);\n            });\n        };\n\n        HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            var ref = this;\n            var fromRoute = ref.current;\n            this.transitionTo(\n                location,\n                function (route) {\n                    pushHash(route.fullPath);\n                    handleScroll(this$1.router, route, fromRoute, false);\n                    onComplete && onComplete(route);\n                },\n                onAbort\n            );\n        };\n\n        HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            var ref = this;\n            var fromRoute = ref.current;\n            this.transitionTo(\n                location,\n                function (route) {\n                    replaceHash(route.fullPath);\n                    handleScroll(this$1.router, route, fromRoute, false);\n                    onComplete && onComplete(route);\n                },\n                onAbort\n            );\n        };\n\n        HashHistory.prototype.go = function go(n) {\n            window.history.go(n);\n        };\n\n        HashHistory.prototype.ensureURL = function ensureURL(push) {\n            var current = this.current.fullPath;\n            if (getHash() !== current) {\n                push ? pushHash(current) : replaceHash(current);\n            }\n        };\n\n        HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n            return getHash()\n        };\n\n        return HashHistory;\n    }(History));\n\n    function checkFallback(base) {\n        var location = getLocation(base);\n        if (!/^\\/#/.test(location)) {\n            window.location.replace(cleanPath(base + '/#' + location));\n            return true\n        }\n    }\n\n    function ensureSlash() {\n        var path = getHash();\n        if (path.charAt(0) === '/') {\n            return true\n        }\n        replaceHash('/' + path);\n        return false\n    }\n\n    function getHash() {\n        // We can't use window.location.hash here because it's not\n        // consistent across browsers - Firefox will pre-decode it!\n        var href = window.location.href;\n        var index = href.indexOf('#');\n        // empty path\n        if (index < 0) { return '' }\n\n        href = href.slice(index + 1);\n\n        return href\n    }\n\n    function getUrl(path) {\n        var href = window.location.href;\n        var i = href.indexOf('#');\n        var base = i >= 0 ? href.slice(0, i) : href;\n        return (base + \"#\" + path)\n    }\n\n    function pushHash(path) {\n        if (supportsPushState) {\n            pushState(getUrl(path));\n        } else {\n            window.location.hash = path;\n        }\n    }\n\n    function replaceHash(path) {\n        if (supportsPushState) {\n            replaceState(getUrl(path));\n        } else {\n            window.location.replace(getUrl(path));\n        }\n    }\n\n    /*  */\n\n    var AbstractHistory = /*@__PURE__*/(function (History) {\n        function AbstractHistory(router, base) {\n            History.call(this, router, base);\n            this.stack = [];\n            this.index = -1;\n        }\n\n        if (History) AbstractHistory.__proto__ = History;\n        AbstractHistory.prototype = Object.create(History && History.prototype);\n        AbstractHistory.prototype.constructor = AbstractHistory;\n\n        AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            this.transitionTo(\n                location,\n                function (route) {\n                    this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n                    this$1.index++;\n                    onComplete && onComplete(route);\n                },\n                onAbort\n            );\n        };\n\n        AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n            var this$1 = this;\n\n            this.transitionTo(\n                location,\n                function (route) {\n                    this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n                    onComplete && onComplete(route);\n                },\n                onAbort\n            );\n        };\n\n        AbstractHistory.prototype.go = function go(n) {\n            var this$1 = this;\n\n            var targetIndex = this.index + n;\n            if (targetIndex < 0 || targetIndex >= this.stack.length) {\n                return\n            }\n            var route = this.stack[targetIndex];\n            this.confirmTransition(\n                route,\n                function () {\n                    var prev = this$1.current;\n                    this$1.index = targetIndex;\n                    this$1.updateRoute(route);\n                    this$1.router.afterHooks.forEach(function (hook) {\n                        hook && hook(route, prev);\n                    });\n                },\n                function (err) {\n                    if (isNavigationFailure(err, NavigationFailureType.duplicated)) {\n                        this$1.index = targetIndex;\n                    }\n                }\n            );\n        };\n\n        AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n            var current = this.stack[this.stack.length - 1];\n            return current ? current.fullPath : '/'\n        };\n\n        AbstractHistory.prototype.ensureURL = function ensureURL() {\n            // noop\n        };\n\n        return AbstractHistory;\n    }(History));\n\n    /*  */\n\n    var VueRouter = function VueRouter(options) {\n        if (options === void 0) options = {};\n\n        this.app = null;\n        this.apps = [];\n        this.options = options;\n        this.beforeHooks = [];\n        this.resolveHooks = [];\n        this.afterHooks = [];\n        this.matcher = createMatcher(options.routes || [], this);\n\n        var mode = options.mode || 'hash';\n        this.fallback =\n            mode === 'history' && !supportsPushState && options.fallback !== false;\n        if (this.fallback) {\n            mode = 'hash';\n        }\n        if (!inBrowser) {\n            mode = 'abstract';\n        }\n        this.mode = mode;\n\n        switch (mode) {\n            case 'history':\n                this.history = new HTML5History(this, options.base);\n                break\n            case 'hash':\n                this.history = new HashHistory(this, options.base, this.fallback);\n                break\n            case 'abstract':\n                this.history = new AbstractHistory(this, options.base);\n                break\n            default:\n                {\n                    assert(false, (\"invalid mode: \" + mode));\n                }\n        }\n    };\n\n    var prototypeAccessors = { currentRoute: { configurable: true } };\n\n    VueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n        return this.matcher.match(raw, current, redirectedFrom)\n    };\n\n    prototypeAccessors.currentRoute.get = function () {\n        return this.history && this.history.current\n    };\n\n    VueRouter.prototype.init = function init(app /* Vue component instance */) {\n        var this$1 = this;\n\n\n        assert(\n            install.installed,\n            \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n            \"before creating root instance.\"\n        );\n\n        this.apps.push(app);\n\n        // set up app destroyed handler\n        // https://github.com/vuejs/vue-router/issues/2639\n        app.$once('hook:destroyed', function () {\n            // clean out app from this.apps array once destroyed\n            var index = this$1.apps.indexOf(app);\n            if (index > -1) { this$1.apps.splice(index, 1); }\n            // ensure we still have a main app or null if no apps\n            // we do not release the router so it can be reused\n            if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }\n\n            if (!this$1.app) { this$1.history.teardown(); }\n        });\n\n        // main app previously initialized\n        // return as we don't need to set up new history listener\n        if (this.app) {\n            return\n        }\n\n        this.app = app;\n\n        var history = this.history;\n\n        if (history instanceof HTML5History || history instanceof HashHistory) {\n            var handleInitialScroll = function (routeOrError) {\n                var from = history.current;\n                var expectScroll = this$1.options.scrollBehavior;\n                var supportsScroll = supportsPushState && expectScroll;\n\n                if (supportsScroll && 'fullPath' in routeOrError) {\n                    handleScroll(this$1, routeOrError, from, false);\n                }\n            };\n            var setupListeners = function (routeOrError) {\n                history.setupListeners();\n                handleInitialScroll(routeOrError);\n            };\n            history.transitionTo(\n                history.getCurrentLocation(),\n                setupListeners,\n                setupListeners\n            );\n        }\n\n        history.listen(function (route) {\n            this$1.apps.forEach(function (app) {\n                app._route = route;\n            });\n        });\n    };\n\n    VueRouter.prototype.beforeEach = function beforeEach(fn) {\n        return registerHook(this.beforeHooks, fn)\n    };\n\n    VueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n        return registerHook(this.resolveHooks, fn)\n    };\n\n    VueRouter.prototype.afterEach = function afterEach(fn) {\n        return registerHook(this.afterHooks, fn)\n    };\n\n    VueRouter.prototype.onReady = function onReady(cb, errorCb) {\n        this.history.onReady(cb, errorCb);\n    };\n\n    VueRouter.prototype.onError = function onError(errorCb) {\n        this.history.onError(errorCb);\n    };\n\n    VueRouter.prototype.push = function push(location, onComplete, onAbort) {\n        var this$1 = this;\n\n        // $flow-disable-line\n        if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n            return new Promise(function (resolve, reject) {\n                this$1.history.push(location, resolve, reject);\n            })\n        } else {\n            this.history.push(location, onComplete, onAbort);\n        }\n    };\n\n    VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n        var this$1 = this;\n\n        // $flow-disable-line\n        if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n            return new Promise(function (resolve, reject) {\n                this$1.history.replace(location, resolve, reject);\n            })\n        } else {\n            this.history.replace(location, onComplete, onAbort);\n        }\n    };\n\n    VueRouter.prototype.go = function go(n) {\n        this.history.go(n);\n    };\n\n    VueRouter.prototype.back = function back() {\n        this.go(-1);\n    };\n\n    VueRouter.prototype.forward = function forward() {\n        this.go(1);\n    };\n\n    VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n        var route = to\n            ? to.matched\n                ? to\n                : this.resolve(to).route\n            : this.currentRoute;\n        if (!route) {\n            return []\n        }\n        return [].concat.apply(\n            [],\n            route.matched.map(function (m) {\n                return Object.keys(m.components).map(function (key) {\n                    return m.components[key]\n                })\n            })\n        )\n    };\n\n    VueRouter.prototype.resolve = function resolve(\n        to,\n        current,\n        append\n    ) {\n        current = current || this.history.current;\n        var location = normalizeLocation(to, current, append, this);\n        var route = this.match(location, current);\n        var fullPath = route.redirectedFrom || route.fullPath;\n        var base = this.history.base;\n        var href = createHref(base, fullPath, this.mode);\n        return {\n            location: location,\n            route: route,\n            href: href,\n            // for backwards compat\n            normalizedTo: location,\n            resolved: route\n        }\n    };\n\n    VueRouter.prototype.getRoutes = function getRoutes() {\n        return this.matcher.getRoutes()\n    };\n\n    VueRouter.prototype.addRoute = function addRoute(parentOrRoute, route) {\n        this.matcher.addRoute(parentOrRoute, route);\n        if (this.history.current !== START) {\n            this.history.transitionTo(this.history.getCurrentLocation());\n        }\n    };\n\n    VueRouter.prototype.addRoutes = function addRoutes(routes) {\n        {\n            warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');\n        }\n        this.matcher.addRoutes(routes);\n        if (this.history.current !== START) {\n            this.history.transitionTo(this.history.getCurrentLocation());\n        }\n    };\n\n    Object.defineProperties(VueRouter.prototype, prototypeAccessors);\n\n    function registerHook(list, fn) {\n        list.push(fn);\n        return function () {\n            var i = list.indexOf(fn);\n            if (i > -1) { list.splice(i, 1); }\n        }\n    }\n\n    function createHref(base, fullPath, mode) {\n        var path = mode === 'hash' ? '#' + fullPath : fullPath;\n        return base ? cleanPath(base + '/' + path) : path\n    }\n\n    VueRouter.install = install;\n    VueRouter.version = '3.5.1';\n    VueRouter.isNavigationFailure = isNavigationFailure;\n    VueRouter.NavigationFailureType = NavigationFailureType;\n    VueRouter.START_LOCATION = START;\n\n    if (inBrowser && window.Vue) {\n        window.Vue.use(VueRouter);\n    }\n\n    return VueRouter;\n\n}));\n\n\n//Included:lib/010.i18next-v21.8.0.js\n!function (factory) {\n    // Only navigators:\n    if(typeof window === 'undefined') return;\n    // General boilerplate:\n    if(typeof window !== \"undefined\") {\n        if (\"i18next\" in window) return window.i18next;\n    }\n    if(typeof global !== \"undefined\") {\n        if (\"i18next\" in global) return global.i18next;\n    }\n    const output = factory();\n    if (typeof module === 'object' && typeof module.exports === 'object') module.exports = output;\n    if (typeof define === 'function' && define.amd) define([], factory);\n    if (typeof exports === 'object') exports[\"i18next\"] = output;\n    if (typeof window !== \"undefined\") {\n        if (typeof window !== 'undefined') window.i18next = output;\n    }\n    if (typeof global !== \"undefined\") {\n        if (typeof global !== 'undefined') global.i18next = output;\n    }\n    return output;\n}(function () { \"use strict\"; function e(t) { return (e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e })(t) } function t(e, t) { if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\") } function n(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function r(e, t, r) { return t && n(e.prototype, t), r && n(e, r), Object.defineProperty(e, \"prototype\", { writable: !1 }), e } function o(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e } function i(e, t) { return (i = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function a(e, t) { if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, \"prototype\", { writable: !1 }), t && i(e, t) } function s(t, n) { if (n && (\"object\" === e(n) || \"function\" == typeof n)) return n; if (void 0 !== n) throw new TypeError(\"Derived constructors may only return object or undefined\"); return o(t) } function u(e) { return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function c(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function l(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function f(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? l(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } var p = { type: \"logger\", log: function (e) { this.output(\"log\", e) }, warn: function (e) { this.output(\"warn\", e) }, error: function (e) { this.output(\"error\", e) }, output: function (e, t) { console && console[e] && console[e].apply(console, t) } }, g = new (function () { function e(n) { var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t(this, e), this.init(n, r) } return r(e, [{ key: \"init\", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.prefix = t.prefix || \"i18next:\", this.logger = e || p, this.options = t, this.debug = t.debug } }, { key: \"setDebug\", value: function (e) { this.debug = e } }, { key: \"log\", value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, \"log\", \"\", !0) } }, { key: \"warn\", value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, \"warn\", \"\", !0) } }, { key: \"error\", value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, \"error\", \"\") } }, { key: \"deprecate\", value: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.forward(t, \"warn\", \"WARNING DEPRECATED: \", !0) } }, { key: \"forward\", value: function (e, t, n, r) { return r && !this.debug ? null : (\"string\" == typeof e[0] && (e[0] = \"\".concat(n).concat(this.prefix, \" \").concat(e[0])), this.logger[t](e)) } }, { key: \"create\", value: function (t) { return new e(this.logger, f(f({}, { prefix: \"\".concat(this.prefix, \":\").concat(t, \":\") }), this.options)) } }]), e }()), h = function () { function e() { t(this, e), this.observers = {} } return r(e, [{ key: \"on\", value: function (e, t) { var n = this; return e.split(\" \").forEach(function (e) { n.observers[e] = n.observers[e] || [], n.observers[e].push(t) }), this } }, { key: \"off\", value: function (e, t) { this.observers[e] && (t ? this.observers[e] = this.observers[e].filter(function (e) { return e !== t }) : delete this.observers[e]) } }, { key: \"emit\", value: function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; this.observers[e] && [].concat(this.observers[e]).forEach(function (e) { e.apply(void 0, n) }); this.observers[\"*\"] && [].concat(this.observers[\"*\"]).forEach(function (t) { t.apply(t, [e].concat(n)) }) } }]), e }(); function d() { var e, t, n = new Promise(function (n, r) { e = n, t = r }); return n.resolve = e, n.reject = t, n } function v(e) { return null == e ? \"\" : \"\" + e } function y(e, t, n) { function r(e) { return e && e.indexOf(\"###\") > -1 ? e.replace(/###/g, \".\") : e } function o() { return !e || \"string\" == typeof e } for (var i = \"string\" != typeof t ? [].concat(t) : t.split(\".\"); i.length > 1;) { if (o()) return {}; var a = r(i.shift()); !e[a] && n && (e[a] = new n), e = Object.prototype.hasOwnProperty.call(e, a) ? e[a] : {} } return o() ? {} : { obj: e, k: r(i.shift()) } } function m(e, t, n) { var r = y(e, t, Object); r.obj[r.k] = n } function b(e, t) { var n = y(e, t), r = n.obj, o = n.k; if (r) return r[o] } function O(e, t, n) { var r = b(e, n); return void 0 !== r ? r : b(t, n) } function k(e) { return e.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\") } var w = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\", \"/\": \"&#x2F;\" }; function x(e) { return \"string\" == typeof e ? e.replace(/[&<>\"'\\/]/g, function (e) { return w[e] }) : e } var S = \"undefined\" != typeof window && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf(\"MSIE\") > -1, j = [\" \", \",\", \"?\", \"!\", \";\"]; function P(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function L(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? P(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function R(e) { var t = function () { if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (\"function\" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (e) { return !1 } }(); return function () { var n, r = u(e); if (t) { var o = u(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return s(this, n) } } var N = function (e) { a(i, h); var n = R(i); function i(e) { var r, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { ns: [\"translation\"], defaultNS: \"translation\" }; return t(this, i), r = n.call(this), S && h.call(o(r)), r.data = e || {}, r.options = a, void 0 === r.options.keySeparator && (r.options.keySeparator = \".\"), void 0 === r.options.ignoreJSONStructure && (r.options.ignoreJSONStructure = !0), r } return r(i, [{ key: \"addNamespaces\", value: function (e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) } }, { key: \"removeNamespaces\", value: function (e) { var t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) } }, { key: \"getResource\", value: function (e, t, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, i = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure, a = [e, t]; n && \"string\" != typeof n && (a = a.concat(n)), n && \"string\" == typeof n && (a = a.concat(o ? n.split(o) : n)), e.indexOf(\".\") > -1 && (a = e.split(\".\")); var s = b(this.data, a); return s || !i || \"string\" != typeof n ? s : function e(t, n) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \".\"; if (t) { if (t[n]) return t[n]; for (var o = n.split(r), i = t, a = 0; a < o.length; ++a) { if (!i) return; if (\"string\" == typeof i[o[a]] && a + 1 < o.length) return; if (void 0 === i[o[a]]) { for (var s = 2, u = o.slice(a, a + s).join(r), c = i[u]; void 0 === c && o.length > a + s;)s++, c = i[u = o.slice(a, a + s).join(r)]; if (void 0 === c) return; if (n.endsWith(u)) { if (\"string\" == typeof c) return c; if (u && \"string\" == typeof c[u]) return c[u] } var l = o.slice(a + s).join(r); return l ? e(c, l, r) : void 0 } i = i[o[a]] } return i } }(this.data && this.data[e] && this.data[e][t], n, o) } }, { key: \"addResource\", value: function (e, t, n, r) { var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { silent: !1 }, i = this.options.keySeparator; void 0 === i && (i = \".\"); var a = [e, t]; n && (a = a.concat(i ? n.split(i) : n)), e.indexOf(\".\") > -1 && (r = t, t = (a = e.split(\".\"))[1]), this.addNamespaces(t), m(this.data, a, r), o.silent || this.emit(\"added\", e, t, n, r) } }, { key: \"addResources\", value: function (e, t, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { silent: !1 }; for (var o in n) \"string\" != typeof n[o] && \"[object Array]\" !== Object.prototype.toString.apply(n[o]) || this.addResource(e, t, o, n[o], { silent: !0 }); r.silent || this.emit(\"added\", e, t, n) } }, { key: \"addResourceBundle\", value: function (e, t, n, r, o) { var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : { silent: !1 }, a = [e, t]; e.indexOf(\".\") > -1 && (r = n, n = t, t = (a = e.split(\".\"))[1]), this.addNamespaces(t); var s = b(this.data, a) || {}; r ? function e(t, n, r) { for (var o in n) \"__proto__\" !== o && \"constructor\" !== o && (o in t ? \"string\" == typeof t[o] || t[o] instanceof String || \"string\" == typeof n[o] || n[o] instanceof String ? r && (t[o] = n[o]) : e(t[o], n[o], r) : t[o] = n[o]); return t }(s, n, o) : s = L(L({}, s), n), m(this.data, a, s), i.silent || this.emit(\"added\", e, t, n) } }, { key: \"removeResourceBundle\", value: function (e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit(\"removed\", e, t) } }, { key: \"hasResourceBundle\", value: function (e, t) { return void 0 !== this.getResource(e, t) } }, { key: \"getResourceBundle\", value: function (e, t) { return t || (t = this.options.defaultNS), \"v1\" === this.options.compatibilityAPI ? L(L({}, {}), this.getResource(e, t)) : this.getResource(e, t) } }, { key: \"getDataByLanguage\", value: function (e) { return this.data[e] } }, { key: \"hasLanguageSomeTranslations\", value: function (e) { var t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(function (e) { return t[e] && Object.keys(t[e]).length > 0 }) } }, { key: \"toJSON\", value: function () { return this.data } }]), i }(), C = { processors: {}, addPostProcessor: function (e) { this.processors[e.name] = e }, handle: function (e, t, n, r, o) { var i = this; return e.forEach(function (e) { i.processors[e] && (t = i.processors[e].process(t, n, r, o)) }), t } }; function E(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function D(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? E(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function F(e) { var t = function () { if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (\"function\" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (e) { return !1 } }(); return function () { var n, r = u(e); if (t) { var o = u(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return s(this, n) } } var I = {}, A = function (n) { a(s, h); var i = F(s); function s(e) { var n, r, a, u, c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return t(this, s), n = i.call(this), S && h.call(o(n)), r = [\"resourceStore\", \"languageUtils\", \"pluralResolver\", \"interpolator\", \"backendConnector\", \"i18nFormat\", \"utils\"], a = e, u = o(n), r.forEach(function (e) { a[e] && (u[e] = a[e]) }), n.options = c, void 0 === n.options.keySeparator && (n.options.keySeparator = \".\"), n.logger = g.create(\"translator\"), n } return r(s, [{ key: \"changeLanguage\", value: function (e) { e && (this.language = e) } }, { key: \"exists\", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { interpolation: {} }; if (null == e) return !1; var n = this.resolve(e, t); return n && void 0 !== n.res } }, { key: \"extractFromKey\", value: function (e, t) { var n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator; void 0 === n && (n = \":\"); var r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator, o = t.ns || this.options.defaultNS || [], i = n && e.indexOf(n) > -1, a = !(this.options.userDefinedKeySeparator || t.keySeparator || this.options.userDefinedNsSeparator || t.nsSeparator || function (e, t, n) { t = t || \"\", n = n || \"\"; var r = j.filter(function (e) { return t.indexOf(e) < 0 && n.indexOf(e) < 0 }); if (0 === r.length) return !0; var o = new RegExp(\"(\".concat(r.map(function (e) { return \"?\" === e ? \"\\\\?\" : e }).join(\"|\"), \")\")), i = !o.test(e); if (!i) { var a = e.indexOf(n); a > 0 && !o.test(e.substring(0, a)) && (i = !0) } return i }(e, n, r)); if (i && !a) { var s = e.match(this.interpolator.nestingRegexp); if (s && s.length > 0) return { key: e, namespaces: o }; var u = e.split(n); (n !== r || n === r && this.options.ns.indexOf(u[0]) > -1) && (o = u.shift()), e = u.join(r) } return \"string\" == typeof o && (o = [o]), { key: e, namespaces: o } } }, { key: \"translate\", value: function (t, n, r) { var o = this; if (\"object\" !== e(n) && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), n || (n = {}), null == t) return \"\"; Array.isArray(t) || (t = [String(t)]); var i = void 0 !== n.returnDetails ? n.returnDetails : this.options.returnDetails, a = void 0 !== n.keySeparator ? n.keySeparator : this.options.keySeparator, u = this.extractFromKey(t[t.length - 1], n), c = u.key, l = u.namespaces, f = l[l.length - 1], p = n.lng || this.language, g = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if (p && \"cimode\" === p.toLowerCase()) { if (g) { var h = n.nsSeparator || this.options.nsSeparator; return i ? (d.res = \"\".concat(f).concat(h).concat(c), d) : \"\".concat(f).concat(h).concat(c) } return i ? (d.res = c, d) : c } var d = this.resolve(t, n), v = d && d.res, y = d && d.usedKey || c, m = d && d.exactUsedKey || c, b = Object.prototype.toString.apply(v), O = void 0 !== n.joinArrays ? n.joinArrays : this.options.joinArrays, k = !this.i18nFormat || this.i18nFormat.handleAsObject; if (k && v && (\"string\" != typeof v && \"boolean\" != typeof v && \"number\" != typeof v) && [\"[object Number]\", \"[object Function]\", \"[object RegExp]\"].indexOf(b) < 0 && (\"string\" != typeof O || \"[object Array]\" !== b)) { if (!n.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\"); var w = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(y, v, D(D({}, n), {}, { ns: l })) : \"key '\".concat(c, \" (\").concat(this.language, \")' returned an object instead of string.\"); return i ? (d.res = w, d) : w } if (a) { var x = \"[object Array]\" === b, S = x ? [] : {}, j = x ? m : y; for (var P in v) if (Object.prototype.hasOwnProperty.call(v, P)) { var L = \"\".concat(j).concat(a).concat(P); S[P] = this.translate(L, D(D({}, n), { joinArrays: !1, ns: l })), S[P] === L && (S[P] = v[P]) } v = S } } else if (k && \"string\" == typeof O && \"[object Array]\" === b) (v = v.join(O)) && (v = this.extendTranslation(v, t, n, r)); else { var R = !1, N = !1, C = void 0 !== n.count && \"string\" != typeof n.count, E = s.hasDefaultValue(n), F = C ? this.pluralResolver.getSuffix(p, n.count, n) : \"\", I = n[\"defaultValue\".concat(F)] || n.defaultValue; !this.isValidLookup(v) && E && (R = !0, v = I), this.isValidLookup(v) || (N = !0, v = c); var A = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && N ? void 0 : v, V = E && I !== v && this.options.updateMissing; if (N || R || V) { if (this.logger.log(V ? \"updateKey\" : \"missingKey\", p, f, c, V ? I : v), a) { var T = this.resolve(c, D(D({}, n), {}, { keySeparator: !1 })); T && T.res && this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\") } var U = [], B = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language); if (\"fallback\" === this.options.saveMissingTo && B && B[0]) for (var K = 0; K < B.length; K++)U.push(B[K]); else \"all\" === this.options.saveMissingTo ? U = this.languageUtils.toResolveHierarchy(n.lng || this.language) : U.push(n.lng || this.language); var M = function (e, t, r) { var i = E && r !== v ? r : A; o.options.missingKeyHandler ? o.options.missingKeyHandler(e, f, t, i, V, n) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing(e, f, t, i, V, n), o.emit(\"missingKey\", e, f, t, v) }; this.options.saveMissing && (this.options.saveMissingPlurals && C ? U.forEach(function (e) { o.pluralResolver.getSuffixes(e, n).forEach(function (t) { M([e], c + t, n[\"defaultValue\".concat(t)] || I) }) }) : M(U, c, I)) } v = this.extendTranslation(v, t, n, d, r), N && v === c && this.options.appendNamespaceToMissingKey && (v = \"\".concat(f, \":\").concat(c)), (N || R) && this.options.parseMissingKeyHandler && (v = \"v1\" !== this.options.compatibilityAPI ? this.options.parseMissingKeyHandler(c, R ? v : void 0) : this.options.parseMissingKeyHandler(v)) } return i ? (d.res = v, d) : v } }, { key: \"extendTranslation\", value: function (e, t, n, r, o) { var i = this; if (this.i18nFormat && this.i18nFormat.parse) e = this.i18nFormat.parse(e, D(D({}, this.options.interpolation.defaultVariables), n), r.usedLng, r.usedNS, r.usedKey, { resolved: r }); else if (!n.skipInterpolation) { n.interpolation && this.interpolator.init(D(D({}, n), { interpolation: D(D({}, this.options.interpolation), n.interpolation) })); var a, s = \"string\" == typeof e && (n && n.interpolation && void 0 !== n.interpolation.skipOnVariables ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); if (s) { var u = e.match(this.interpolator.nestingRegexp); a = u && u.length } var c = n.replace && \"string\" != typeof n.replace ? n.replace : n; if (this.options.interpolation.defaultVariables && (c = D(D({}, this.options.interpolation.defaultVariables), c)), e = this.interpolator.interpolate(e, c, n.lng || this.language, n), s) { var l = e.match(this.interpolator.nestingRegexp); a < (l && l.length) && (n.nest = !1) } !1 !== n.nest && (e = this.interpolator.nest(e, function () { for (var e = arguments.length, r = new Array(e), a = 0; a < e; a++)r[a] = arguments[a]; return o && o[0] === r[0] && !n.context ? (i.logger.warn(\"It seems you are nesting recursively key: \".concat(r[0], \" in key: \").concat(t[0])), null) : i.translate.apply(i, r.concat([t])) }, n)), n.interpolation && this.interpolator.reset() } var f = n.postProcess || this.options.postProcess, p = \"string\" == typeof f ? [f] : f; return null != e && p && p.length && !1 !== n.applyPostProcessor && (e = C.handle(p, e, t, this.options && this.options.postProcessPassResolved ? D({ i18nResolved: r }, n) : n, this)), e } }, { key: \"resolve\", value: function (e) { var t, n, r, o, i, a = this, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return \"string\" == typeof e && (e = [e]), e.forEach(function (e) { if (!a.isValidLookup(t)) { var u = a.extractFromKey(e, s), c = u.key; n = c; var l = u.namespaces; a.options.fallbackNS && (l = l.concat(a.options.fallbackNS)); var f = void 0 !== s.count && \"string\" != typeof s.count, p = f && !s.ordinal && 0 === s.count && a.pluralResolver.shouldUseIntlApi(), g = void 0 !== s.context && (\"string\" == typeof s.context || \"number\" == typeof s.context) && \"\" !== s.context, h = s.lngs ? s.lngs : a.languageUtils.toResolveHierarchy(s.lng || a.language, s.fallbackLng); l.forEach(function (e) { a.isValidLookup(t) || (i = e, !I[\"\".concat(h[0], \"-\").concat(e)] && a.utils && a.utils.hasLoadedNamespace && !a.utils.hasLoadedNamespace(i) && (I[\"\".concat(h[0], \"-\").concat(e)] = !0, a.logger.warn('key \"'.concat(n, '\" for languages \"').concat(h.join(\", \"), '\" won\\'t get resolved as namespace \"').concat(i, '\" was not yet loaded'), \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\")), h.forEach(function (n) { if (!a.isValidLookup(t)) { o = n; var i, u = [c]; if (a.i18nFormat && a.i18nFormat.addLookupKeys) a.i18nFormat.addLookupKeys(u, c, n, e, s); else { var l; f && (l = a.pluralResolver.getSuffix(n, s.count, s)); if (f && (u.push(c + l), p && u.push(c + \"_zero\")), g) { var h = \"\".concat(c).concat(a.options.contextSeparator).concat(s.context); u.push(h), f && (u.push(h + l), p && u.push(h + \"_zero\")) } } for (; i = u.pop();)a.isValidLookup(t) || (r = i, t = a.getResource(n, e, i, s)) } })) }) } }), { res: t, usedKey: n, exactUsedKey: r, usedLng: o, usedNS: i } } }, { key: \"isValidLookup\", value: function (e) { return !(void 0 === e || !this.options.returnNull && null === e || !this.options.returnEmptyString && \"\" === e) } }, { key: \"getResource\", value: function (e, t, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r) } }], [{ key: \"hasDefaultValue\", value: function (e) { for (var t in e) if (Object.prototype.hasOwnProperty.call(e, t) && \"defaultValue\" === t.substring(0, \"defaultValue\".length) && void 0 !== e[t]) return !0; return !1 } }]), s }(); function V(e) { return e.charAt(0).toUpperCase() + e.slice(1) } var T = function () { function e(n) { t(this, e), this.options = n, this.supportedLngs = this.options.supportedLngs || !1, this.logger = g.create(\"languageUtils\") } return r(e, [{ key: \"getScriptPartFromCode\", value: function (e) { if (!e || e.indexOf(\"-\") < 0) return null; var t = e.split(\"-\"); return 2 === t.length ? null : (t.pop(), \"x\" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join(\"-\"))) } }, { key: \"getLanguagePartFromCode\", value: function (e) { if (!e || e.indexOf(\"-\") < 0) return e; var t = e.split(\"-\"); return this.formatLanguageCode(t[0]) } }, { key: \"formatLanguageCode\", value: function (e) { if (\"string\" == typeof e && e.indexOf(\"-\") > -1) { var t = [\"hans\", \"hant\", \"latn\", \"cyrl\", \"cans\", \"mong\", \"arab\"], n = e.split(\"-\"); return this.options.lowerCaseLng ? n = n.map(function (e) { return e.toLowerCase() }) : 2 === n.length ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = V(n[1].toLowerCase()))) : 3 === n.length && (n[0] = n[0].toLowerCase(), 2 === n[1].length && (n[1] = n[1].toUpperCase()), \"sgn\" !== n[0] && 2 === n[2].length && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = V(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = V(n[2].toLowerCase()))), n.join(\"-\") } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e } }, { key: \"isSupportedCode\", value: function (e) { return (\"languageOnly\" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 } }, { key: \"getBestMatchFromCodes\", value: function (e) { var t, n = this; return e ? (e.forEach(function (e) { if (!t) { var r = n.formatLanguageCode(e); n.options.supportedLngs && !n.isSupportedCode(r) || (t = r) } }), !t && this.options.supportedLngs && e.forEach(function (e) { if (!t) { var r = n.getLanguagePartFromCode(e); if (n.isSupportedCode(r)) return t = r; t = n.options.supportedLngs.find(function (e) { if (0 === e.indexOf(r)) return e }) } }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t) : null } }, { key: \"getFallbackCodes\", value: function (e, t) { if (!e) return []; if (\"function\" == typeof e && (e = e(t)), \"string\" == typeof e && (e = [e]), \"[object Array]\" === Object.prototype.toString.apply(e)) return e; if (!t) return e.default || []; var n = e[t]; return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [] } }, { key: \"toResolveHierarchy\", value: function (e, t) { var n = this, r = this.getFallbackCodes(t || this.options.fallbackLng || [], e), o = [], i = function (e) { e && (n.isSupportedCode(e) ? o.push(e) : n.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(e))) }; return \"string\" == typeof e && e.indexOf(\"-\") > -1 ? (\"languageOnly\" !== this.options.load && i(this.formatLanguageCode(e)), \"languageOnly\" !== this.options.load && \"currentOnly\" !== this.options.load && i(this.getScriptPartFromCode(e)), \"currentOnly\" !== this.options.load && i(this.getLanguagePartFromCode(e))) : \"string\" == typeof e && i(this.formatLanguageCode(e)), r.forEach(function (e) { o.indexOf(e) < 0 && i(n.formatLanguageCode(e)) }), o } }]), e }(), U = [{ lngs: [\"ach\", \"ak\", \"am\", \"arn\", \"br\", \"fil\", \"gun\", \"ln\", \"mfe\", \"mg\", \"mi\", \"oc\", \"pt\", \"pt-BR\", \"tg\", \"tl\", \"ti\", \"tr\", \"uz\", \"wa\"], nr: [1, 2], fc: 1 }, { lngs: [\"af\", \"an\", \"ast\", \"az\", \"bg\", \"bn\", \"ca\", \"da\", \"de\", \"dev\", \"el\", \"en\", \"eo\", \"es\", \"et\", \"eu\", \"fi\", \"fo\", \"fur\", \"fy\", \"gl\", \"gu\", \"ha\", \"hi\", \"hu\", \"hy\", \"ia\", \"it\", \"kk\", \"kn\", \"ku\", \"lb\", \"mai\", \"ml\", \"mn\", \"mr\", \"nah\", \"nap\", \"nb\", \"ne\", \"nl\", \"nn\", \"no\", \"nso\", \"pa\", \"pap\", \"pms\", \"ps\", \"pt-PT\", \"rm\", \"sco\", \"se\", \"si\", \"so\", \"son\", \"sq\", \"sv\", \"sw\", \"ta\", \"te\", \"tk\", \"ur\", \"yo\"], nr: [1, 2], fc: 2 }, { lngs: [\"ay\", \"bo\", \"cgg\", \"fa\", \"ht\", \"id\", \"ja\", \"jbo\", \"ka\", \"km\", \"ko\", \"ky\", \"lo\", \"ms\", \"sah\", \"su\", \"th\", \"tt\", \"ug\", \"vi\", \"wo\", \"zh\"], nr: [1], fc: 3 }, { lngs: [\"be\", \"bs\", \"cnr\", \"dz\", \"hr\", \"ru\", \"sr\", \"uk\"], nr: [1, 2, 5], fc: 4 }, { lngs: [\"ar\"], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: [\"cs\", \"sk\"], nr: [1, 2, 5], fc: 6 }, { lngs: [\"csb\", \"pl\"], nr: [1, 2, 5], fc: 7 }, { lngs: [\"cy\"], nr: [1, 2, 3, 8], fc: 8 }, { lngs: [\"fr\"], nr: [1, 2], fc: 9 }, { lngs: [\"ga\"], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: [\"gd\"], nr: [1, 2, 3, 20], fc: 11 }, { lngs: [\"is\"], nr: [1, 2], fc: 12 }, { lngs: [\"jv\"], nr: [0, 1], fc: 13 }, { lngs: [\"kw\"], nr: [1, 2, 3, 4], fc: 14 }, { lngs: [\"lt\"], nr: [1, 2, 10], fc: 15 }, { lngs: [\"lv\"], nr: [1, 2, 0], fc: 16 }, { lngs: [\"mk\"], nr: [1, 2], fc: 17 }, { lngs: [\"mnk\"], nr: [0, 1, 2], fc: 18 }, { lngs: [\"mt\"], nr: [1, 2, 11, 20], fc: 19 }, { lngs: [\"or\"], nr: [2, 1], fc: 2 }, { lngs: [\"ro\"], nr: [1, 2, 20], fc: 20 }, { lngs: [\"sl\"], nr: [5, 1, 2, 3], fc: 21 }, { lngs: [\"he\", \"iw\"], nr: [1, 2, 20, 21], fc: 22 }], B = { 1: function (e) { return Number(e > 1) }, 2: function (e) { return Number(1 != e) }, 3: function (e) { return 0 }, 4: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 5: function (e) { return Number(0 == e ? 0 : 1 == e ? 1 : 2 == e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5) }, 6: function (e) { return Number(1 == e ? 0 : e >= 2 && e <= 4 ? 1 : 2) }, 7: function (e) { return Number(1 == e ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 8: function (e) { return Number(1 == e ? 0 : 2 == e ? 1 : 8 != e && 11 != e ? 2 : 3) }, 9: function (e) { return Number(e >= 2) }, 10: function (e) { return Number(1 == e ? 0 : 2 == e ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4) }, 11: function (e) { return Number(1 == e || 11 == e ? 0 : 2 == e || 12 == e ? 1 : e > 2 && e < 20 ? 2 : 3) }, 12: function (e) { return Number(e % 10 != 1 || e % 100 == 11) }, 13: function (e) { return Number(0 !== e) }, 14: function (e) { return Number(1 == e ? 0 : 2 == e ? 1 : 3 == e ? 2 : 3) }, 15: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2) }, 16: function (e) { return Number(e % 10 == 1 && e % 100 != 11 ? 0 : 0 !== e ? 1 : 2) }, 17: function (e) { return Number(1 == e || e % 10 == 1 && e % 100 != 11 ? 0 : 1) }, 18: function (e) { return Number(0 == e ? 0 : 1 == e ? 1 : 2) }, 19: function (e) { return Number(1 == e ? 0 : 0 == e || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3) }, 20: function (e) { return Number(1 == e ? 0 : 0 == e || e % 100 > 0 && e % 100 < 20 ? 1 : 2) }, 21: function (e) { return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0) }, 22: function (e) { return Number(1 == e ? 0 : 2 == e ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3) } }, K = [\"v1\", \"v2\", \"v3\"], M = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }; var H = function () { function e(n) { var r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t(this, e), this.languageUtils = n, this.options = o, this.logger = g.create(\"pluralResolver\"), this.options.compatibilityJSON && \"v4\" !== this.options.compatibilityJSON || \"undefined\" != typeof Intl && Intl.PluralRules || (this.options.compatibilityJSON = \"v3\", this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\")), this.rules = (r = {}, U.forEach(function (e) { e.lngs.forEach(function (t) { r[t] = { numbers: e.nr, plurals: B[e.fc] } }) }), r) } return r(e, [{ key: \"addRule\", value: function (e, t) { this.rules[e] = t } }, { key: \"getRule\", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this.shouldUseIntlApi()) try { return new Intl.PluralRules(e, { type: t.ordinal ? \"ordinal\" : \"cardinal\" }) } catch (e) { return } return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)] } }, { key: \"needsPlural\", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = this.getRule(e, t); return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1 } }, { key: \"getPluralFormsOfKey\", value: function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return this.getSuffixes(e, n).map(function (e) { return \"\".concat(t).concat(e) }) } }, { key: \"getSuffixes\", value: function (e) { var t = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = this.getRule(e, n); return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort(function (e, t) { return M[e] - M[t] }).map(function (e) { return \"\".concat(t.options.prepend).concat(e) }) : r.numbers.map(function (r) { return t.getSuffix(e, r, n) }) : [] } }, { key: \"getSuffix\", value: function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = this.getRule(e, n); return r ? this.shouldUseIntlApi() ? \"\".concat(this.options.prepend).concat(r.select(t)) : this.getSuffixRetroCompatible(r, t) : (this.logger.warn(\"no plural rule found for: \".concat(e)), \"\") } }, { key: \"getSuffixRetroCompatible\", value: function (e, t) { var n = this, r = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t)), o = e.numbers[r]; this.options.simplifyPluralSuffix && 2 === e.numbers.length && 1 === e.numbers[0] && (2 === o ? o = \"plural\" : 1 === o && (o = \"\")); var i = function () { return n.options.prepend && o.toString() ? n.options.prepend + o.toString() : o.toString() }; return \"v1\" === this.options.compatibilityJSON ? 1 === o ? \"\" : \"number\" == typeof o ? \"_plural_\".concat(o.toString()) : i() : \"v2\" === this.options.compatibilityJSON ? i() : this.options.simplifyPluralSuffix && 2 === e.numbers.length && 1 === e.numbers[0] ? i() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString() } }, { key: \"shouldUseIntlApi\", value: function () { return !K.includes(this.options.compatibilityJSON) } }]), e }(); function z(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function J(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? z(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } var _ = function () { function e() { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t(this, e), this.logger = g.create(\"interpolator\"), this.options = n, this.format = n.interpolation && n.interpolation.format || function (e) { return e }, this.init(n) } return r(e, [{ key: \"init\", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e.interpolation || (e.interpolation = { escapeValue: !0 }); var t = e.interpolation; this.escape = void 0 !== t.escape ? t.escape : x, this.escapeValue = void 0 === t.escapeValue || t.escapeValue, this.useRawValueToEscape = void 0 !== t.useRawValueToEscape && t.useRawValueToEscape, this.prefix = t.prefix ? k(t.prefix) : t.prefixEscaped || \"{{\", this.suffix = t.suffix ? k(t.suffix) : t.suffixEscaped || \"}}\", this.formatSeparator = t.formatSeparator ? t.formatSeparator : t.formatSeparator || \",\", this.unescapePrefix = t.unescapeSuffix ? \"\" : t.unescapePrefix || \"-\", this.unescapeSuffix = this.unescapePrefix ? \"\" : t.unescapeSuffix || \"\", this.nestingPrefix = t.nestingPrefix ? k(t.nestingPrefix) : t.nestingPrefixEscaped || k(\"$t(\"), this.nestingSuffix = t.nestingSuffix ? k(t.nestingSuffix) : t.nestingSuffixEscaped || k(\")\"), this.nestingOptionsSeparator = t.nestingOptionsSeparator ? t.nestingOptionsSeparator : t.nestingOptionsSeparator || \",\", this.maxReplaces = t.maxReplaces ? t.maxReplaces : 1e3, this.alwaysFormat = void 0 !== t.alwaysFormat && t.alwaysFormat, this.resetRegExp() } }, { key: \"reset\", value: function () { this.options && this.init(this.options) } }, { key: \"resetRegExp\", value: function () { var e = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix); this.regexp = new RegExp(e, \"g\"); var t = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix); this.regexpUnescape = new RegExp(t, \"g\"); var n = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix); this.nestingRegexp = new RegExp(n, \"g\") } }, { key: \"interpolate\", value: function (e, t, n, r) { var o, i, a, s = this, u = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}; function c(e) { return e.replace(/\\$/g, \"$$$$\") } var l = function (e) { if (e.indexOf(s.formatSeparator) < 0) { var o = O(t, u, e); return s.alwaysFormat ? s.format(o, void 0, n, J(J(J({}, r), t), {}, { interpolationkey: e })) : o } var i = e.split(s.formatSeparator), a = i.shift().trim(), c = i.join(s.formatSeparator).trim(); return s.format(O(t, u, a), c, n, J(J(J({}, r), t), {}, { interpolationkey: a })) }; this.resetRegExp(); var f = r && r.missingInterpolationHandler || this.options.missingInterpolationHandler, p = r && r.interpolation && void 0 !== r.interpolation.skipOnVariables ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: function (e) { return c(e) } }, { regex: this.regexp, safeValue: function (e) { return s.escapeValue ? c(s.escape(e)) : c(e) } }].forEach(function (t) { for (a = 0; o = t.regex.exec(e);) { var n = o[1].trim(); if (void 0 === (i = l(n))) if (\"function\" == typeof f) { var u = f(e, o, r); i = \"string\" == typeof u ? u : \"\" } else if (r && r.hasOwnProperty(n)) i = \"\"; else { if (p) { i = o[0]; continue } s.logger.warn(\"missed to pass in variable \".concat(n, \" for interpolating \").concat(e)), i = \"\" } else \"string\" == typeof i || s.useRawValueToEscape || (i = v(i)); var c = t.safeValue(i); if (e = e.replace(o[0], c), p ? (t.regex.lastIndex += c.length, t.regex.lastIndex -= o[0].length) : t.regex.lastIndex = 0, ++a >= s.maxReplaces) break } }), e } }, { key: \"nest\", value: function (e, t) { var n, r, o = this, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a = J({}, i); function s(e, t) { var n = this.nestingOptionsSeparator; if (e.indexOf(n) < 0) return e; var r = e.split(new RegExp(\"\".concat(n, \"[ ]*{\"))), o = \"{\".concat(r[1]); e = r[0], o = (o = this.interpolate(o, a)).replace(/'/g, '\"'); try { a = JSON.parse(o), t && (a = J(J({}, t), a)) } catch (t) { return this.logger.warn(\"failed parsing options string in nesting for key \".concat(e), t), \"\".concat(e).concat(n).concat(o) } return delete a.defaultValue, e } for (a.applyPostProcessor = !1, delete a.defaultValue; n = this.nestingRegexp.exec(e);) { var u = [], c = !1; if (-1 !== n[0].indexOf(this.formatSeparator) && !/{.*}/.test(n[1])) { var l = n[1].split(this.formatSeparator).map(function (e) { return e.trim() }); n[1] = l.shift(), u = l, c = !0 } if ((r = t(s.call(this, n[1].trim(), a), a)) && n[0] === e && \"string\" != typeof r) return r; \"string\" != typeof r && (r = v(r)), r || (this.logger.warn(\"missed to resolve \".concat(n[1], \" for nesting \").concat(e)), r = \"\"), c && (r = u.reduce(function (e, t) { return o.format(e, t, i.lng, J(J({}, i), {}, { interpolationkey: n[1].trim() })) }, r.trim())), e = e.replace(n[0], r), this.regexp.lastIndex = 0 } return e } }]), e }(); function q(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function $(e) { return function (e) { if (Array.isArray(e)) return e }(e) || function (e) { if (\"undefined\" != typeof Symbol && null != e[Symbol.iterator] || null != e[\"@@iterator\"]) return Array.from(e) }(e) || function (e, t) { if (e) { if (\"string\" == typeof e) return q(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? q(e, t) : void 0 } }(e) || function () { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\") }() } function W(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function Y(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? W(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } var G = function () { function e() { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t(this, e), this.logger = g.create(\"formatter\"), this.options = n, this.formats = { number: function (e, t, n) { return new Intl.NumberFormat(t, n).format(e) }, currency: function (e, t, n) { return new Intl.NumberFormat(t, Y(Y({}, n), {}, { style: \"currency\" })).format(e) }, datetime: function (e, t, n) { return new Intl.DateTimeFormat(t, Y({}, n)).format(e) }, relativetime: function (e, t, n) { return new Intl.RelativeTimeFormat(t, Y({}, n)).format(e, n.range || \"day\") }, list: function (e, t, n) { return new Intl.ListFormat(t, Y({}, n)).format(e) } }, this.init(n) } return r(e, [{ key: \"init\", value: function (e) { var t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { interpolation: {} }).interpolation; this.formatSeparator = t.formatSeparator ? t.formatSeparator : t.formatSeparator || \",\" } }, { key: \"add\", value: function (e, t) { this.formats[e.toLowerCase().trim()] = t } }, { key: \"format\", value: function (e, t, n, r) { var o = this; return t.split(this.formatSeparator).reduce(function (e, t) { var i = function (e) { var t = e.toLowerCase().trim(), n = {}; if (e.indexOf(\"(\") > -1) { var r = e.split(\"(\"); t = r[0].toLowerCase().trim(); var o = r[1].substring(0, r[1].length - 1); \"currency\" === t && o.indexOf(\":\") < 0 ? n.currency || (n.currency = o.trim()) : \"relativetime\" === t && o.indexOf(\":\") < 0 ? n.range || (n.range = o.trim()) : o.split(\";\").forEach(function (e) { if (e) { var t = $(e.split(\":\")), r = t[0], o = t.slice(1).join(\":\"); n[r.trim()] || (n[r.trim()] = o.trim()), \"false\" === o.trim() && (n[r.trim()] = !1), \"true\" === o.trim() && (n[r.trim()] = !0), isNaN(o.trim()) || (n[r.trim()] = parseInt(o.trim(), 10)) } }) } return { formatName: t, formatOptions: n } }(t), a = i.formatName, s = i.formatOptions; if (o.formats[a]) { var u = e; try { var c = r && r.formatParams && r.formatParams[r.interpolationkey] || {}, l = c.locale || c.lng || r.locale || r.lng || n; u = o.formats[a](e, l, Y(Y(Y({}, s), r), c)) } catch (e) { o.logger.warn(e) } return u } return o.logger.warn(\"there was no format function for \".concat(a)), e }, e) } }]), e }(); function Q(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function X(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? Q(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function Z(e) { var t = function () { if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (\"function\" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (e) { return !1 } }(); return function () { var n, r = u(e); if (t) { var o = u(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return s(this, n) } } var ee = function (e) { a(i, h); var n = Z(i); function i(e, r, a) { var s, u = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return t(this, i), s = n.call(this), S && h.call(o(s)), s.backend = e, s.store = r, s.services = a, s.languageUtils = a.languageUtils, s.options = u, s.logger = g.create(\"backendConnector\"), s.waitingReads = [], s.maxParallelReads = u.maxParallelReads || 10, s.readingCalls = 0, s.state = {}, s.queue = [], s.backend && s.backend.init && s.backend.init(a, u.backend, u), s } return r(i, [{ key: \"queueLoad\", value: function (e, t, n, r) { var o = this, i = {}, a = {}, s = {}, u = {}; return e.forEach(function (e) { var r = !0; t.forEach(function (t) { var s = \"\".concat(e, \"|\").concat(t); !n.reload && o.store.hasResourceBundle(e, t) ? o.state[s] = 2 : o.state[s] < 0 || (1 === o.state[s] ? void 0 !== a[s] && (a[s] = !0) : (o.state[s] = 1, r = !1, a[s] = !0, i[s] = !0, u[t] = !0)) }), r || (s[e] = !0) }), (Object.keys(i).length || Object.keys(a).length) && this.queue.push({ pending: a, pendingCount: Object.keys(a).length, loaded: {}, errors: [], callback: r }), { toLoad: Object.keys(i), pending: Object.keys(a), toLoadLanguages: Object.keys(s), toLoadNamespaces: Object.keys(u) } } }, { key: \"loaded\", value: function (e, t, n) { var r = e.split(\"|\"), o = r[0], i = r[1]; t && this.emit(\"failedLoading\", o, i, t), n && this.store.addResourceBundle(o, i, n), this.state[e] = t ? -1 : 2; var a = {}; this.queue.forEach(function (n) { var r, s, u, c, l, f; r = n.loaded, s = i, c = y(r, [o], Object), l = c.obj, f = c.k, l[f] = l[f] || [], u && (l[f] = l[f].concat(s)), u || l[f].push(s), function (e, t) { delete e.pending[t], e.pendingCount-- }(n, e), t && n.errors.push(t), 0 !== n.pendingCount || n.done || (Object.keys(n.loaded).forEach(function (e) { a[e] || (a[e] = {}); var t = Object.keys(a[e]); t.length && t.forEach(function (n) { void 0 !== t[n] && (a[e][n] = !0) }) }), n.done = !0, n.errors.length ? n.callback(n.errors) : n.callback()) }), this.emit(\"loaded\", a), this.queue = this.queue.filter(function (e) { return !e.done }) } }, { key: \"read\", value: function (e, t, n) { var r = this, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 350, a = arguments.length > 5 ? arguments[5] : void 0; return e.length ? this.readingCalls >= this.maxParallelReads ? void this.waitingReads.push({ lng: e, ns: t, fcName: n, tried: o, wait: i, callback: a }) : (this.readingCalls++, this.backend[n](e, t, function (s, u) { if (s && u && o < 5) setTimeout(function () { r.read.call(r, e, t, n, o + 1, 2 * i, a) }, i); else { if (r.readingCalls--, r.waitingReads.length > 0) { var c = r.waitingReads.shift(); r.read(c.lng, c.ns, c.fcName, c.tried, c.wait, c.callback) } a(s, u) } })) : a(null, {}) } }, { key: \"prepareLoading\", value: function (e, t) { var n = this, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = arguments.length > 3 ? arguments[3] : void 0; if (!this.backend) return this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\"), o && o(); \"string\" == typeof e && (e = this.languageUtils.toResolveHierarchy(e)), \"string\" == typeof t && (t = [t]); var i = this.queueLoad(e, t, r, o); if (!i.toLoad.length) return i.pending.length || o(), null; i.toLoad.forEach(function (e) { n.loadOne(e) }) } }, { key: \"load\", value: function (e, t, n) { this.prepareLoading(e, t, {}, n) } }, { key: \"reload\", value: function (e, t, n) { this.prepareLoading(e, t, { reload: !0 }, n) } }, { key: \"loadOne\", value: function (e) { var t = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\", r = e.split(\"|\"), o = r[0], i = r[1]; this.read(o, i, \"read\", void 0, void 0, function (r, a) { r && t.logger.warn(\"\".concat(n, \"loading namespace \").concat(i, \" for language \").concat(o, \" failed\"), r), !r && a && t.logger.log(\"\".concat(n, \"loaded namespace \").concat(i, \" for language \").concat(o), a), t.loaded(e, r, a) }) } }, { key: \"saveMissing\", value: function (e, t, n, r, o) { var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t) ? this.logger.warn('did not save key \"'.concat(n, '\" as the namespace \"').concat(t, '\" was not yet loaded'), \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\") : null != n && \"\" !== n && (this.backend && this.backend.create && this.backend.create(e, t, n, r, null, X(X({}, i), {}, { isUpdate: o })), e && e[0] && this.store.addResource(e[0], t, n, r)) } }]), i }(); function te(e) { return \"string\" == typeof e.ns && (e.ns = [e.ns]), \"string\" == typeof e.fallbackLng && (e.fallbackLng = [e.fallbackLng]), \"string\" == typeof e.fallbackNS && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf(\"cimode\") < 0 && (e.supportedLngs = e.supportedLngs.concat([\"cimode\"])), e } function ne(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function re(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? ne(Object(n), !0).forEach(function (t) { c(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ne(Object(n)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function oe(e) { var t = function () { if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (\"function\" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (e) { return !1 } }(); return function () { var n, r = u(e); if (t) { var o = u(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return s(this, n) } } function ie() { } var ae = function (n) { a(u, h); var i = oe(u); function u() { var e, n, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0; if (t(this, u), e = i.call(this), S && h.call(o(e)), e.options = te(r), e.services = {}, e.logger = g, e.modules = { external: [] }, n = o(e), Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(function (e) { \"function\" == typeof n[e] && (n[e] = n[e].bind(n)) }), a && !e.isInitialized && !r.isClone) { if (!e.options.initImmediate) return e.init(r, a), s(e, o(e)); setTimeout(function () { e.init(r, a) }, 0) } return e } return r(u, [{ key: \"init\", value: function () { var t = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0; \"function\" == typeof n && (r = n, n = {}), !n.defaultNS && n.ns && (\"string\" == typeof n.ns ? n.defaultNS = n.ns : n.ns.indexOf(\"translation\") < 0 && (n.defaultNS = n.ns[0])); var o = { debug: !1, initImmediate: !0, ns: [\"translation\"], defaultNS: [\"translation\"], fallbackLng: [\"dev\"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: \"all\", preload: !1, simplifyPluralSuffix: !0, keySeparator: \".\", nsSeparator: \":\", pluralSeparator: \"_\", contextSeparator: \"_\", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: \"fallback\", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !0, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: function (t) { var n = {}; if (\"object\" === e(t[1]) && (n = t[1]), \"string\" == typeof t[1] && (n.defaultValue = t[1]), \"string\" == typeof t[2] && (n.tDescription = t[2]), \"object\" === e(t[2]) || \"object\" === e(t[3])) { var r = t[3] || t[2]; Object.keys(r).forEach(function (e) { n[e] = r[e] }) } return n }, interpolation: { escapeValue: !0, format: function (e, t, n, r) { return e }, prefix: \"{{\", suffix: \"}}\", formatSeparator: \",\", unescapePrefix: \"-\", nestingPrefix: \"$t(\", nestingSuffix: \")\", nestingOptionsSeparator: \",\", maxReplaces: 1e3, skipOnVariables: !0 } }; function i(e) { return e ? \"function\" == typeof e ? new e : e : null } if (this.options = re(re(re({}, o), this.options), te(n)), \"v1\" !== this.options.compatibilityAPI && (this.options.interpolation = re(re({}, o.interpolation), this.options.interpolation)), void 0 !== n.keySeparator && (this.options.userDefinedKeySeparator = n.keySeparator), void 0 !== n.nsSeparator && (this.options.userDefinedNsSeparator = n.nsSeparator), !this.options.isClone) { var a; this.modules.logger ? g.init(i(this.modules.logger), this.options) : g.init(null, this.options), this.modules.formatter ? a = this.modules.formatter : \"undefined\" != typeof Intl && (a = G); var s = new T(this.options); this.store = new N(this.options.resources, this.options); var u = this.services; u.logger = g, u.resourceStore = this.store, u.languageUtils = s, u.pluralResolver = new H(s, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), !a || this.options.interpolation.format && this.options.interpolation.format !== o.interpolation.format || (u.formatter = i(a), u.formatter.init(u, this.options), this.options.interpolation.format = u.formatter.format.bind(u.formatter)), u.interpolator = new _(this.options), u.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, u.backendConnector = new ee(i(this.modules.backend), u.resourceStore, u, this.options), u.backendConnector.on(\"*\", function (e) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)r[o - 1] = arguments[o]; t.emit.apply(t, [e].concat(r)) }), this.modules.languageDetector && (u.languageDetector = i(this.modules.languageDetector), u.languageDetector.init(u, this.options.detection, this.options)), this.modules.i18nFormat && (u.i18nFormat = i(this.modules.i18nFormat), u.i18nFormat.init && u.i18nFormat.init(this)), this.translator = new A(this.services, this.options), this.translator.on(\"*\", function (e) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)r[o - 1] = arguments[o]; t.emit.apply(t, [e].concat(r)) }), this.modules.external.forEach(function (e) { e.init && e.init(t) }) } if (this.format = this.options.interpolation.format, r || (r = ie), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { var c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); c.length > 0 && \"dev\" !== c[0] && (this.options.lng = c[0]) } this.services.languageDetector || this.options.lng || this.logger.warn(\"init: no languageDetector is used and no lng is defined\");[\"getResource\", \"hasResourceBundle\", \"getResourceBundle\", \"getDataByLanguage\"].forEach(function (e) { t[e] = function () { var n; return (n = t.store)[e].apply(n, arguments) } });[\"addResource\", \"addResources\", \"addResourceBundle\", \"removeResourceBundle\"].forEach(function (e) { t[e] = function () { var n; return (n = t.store)[e].apply(n, arguments), t } }); var l = d(), f = function () { var e = function (e, n) { t.isInitialized && !t.initializedStoreOnce && t.logger.warn(\"init: i18next is already initialized. You should call init just once!\"), t.isInitialized = !0, t.options.isClone || t.logger.log(\"initialized\", t.options), t.emit(\"initialized\", t.options), l.resolve(n), r(e, n) }; if (t.languages && \"v1\" !== t.options.compatibilityAPI && !t.isInitialized) return e(null, t.t.bind(t)); t.changeLanguage(t.options.lng, e) }; return this.options.resources || !this.options.initImmediate ? f() : setTimeout(f, 0), l } }, { key: \"loadResources\", value: function (e) { var t = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ie, r = \"string\" == typeof e ? e : this.language; if (\"function\" == typeof e && (n = e), !this.options.resources || this.options.partialBundledLanguages) { if (r && \"cimode\" === r.toLowerCase()) return n(); var o = [], i = function (e) { e && t.services.languageUtils.toResolveHierarchy(e).forEach(function (e) { o.indexOf(e) < 0 && o.push(e) }) }; if (r) i(r); else this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(function (e) { return i(e) }); this.options.preload && this.options.preload.forEach(function (e) { return i(e) }), this.services.backendConnector.load(o, this.options.ns, function (e) { e || t.resolvedLanguage || !t.language || t.setResolvedLanguage(t.language), n(e) }) } else n(null) } }, { key: \"reloadResources\", value: function (e, t, n) { var r = d(); return e || (e = this.languages), t || (t = this.options.ns), n || (n = ie), this.services.backendConnector.reload(e, t, function (e) { r.resolve(), n(e) }), r } }, { key: \"use\", value: function (e) { if (!e) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\"); if (!e.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\"); return \"backend\" === e.type && (this.modules.backend = e), (\"logger\" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e), \"languageDetector\" === e.type && (this.modules.languageDetector = e), \"i18nFormat\" === e.type && (this.modules.i18nFormat = e), \"postProcessor\" === e.type && C.addPostProcessor(e), \"formatter\" === e.type && (this.modules.formatter = e), \"3rdParty\" === e.type && this.modules.external.push(e), this } }, { key: \"setResolvedLanguage\", value: function (e) { if (e && this.languages && !([\"cimode\", \"dev\"].indexOf(e) > -1)) for (var t = 0; t < this.languages.length; t++) { var n = this.languages[t]; if (!([\"cimode\", \"dev\"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) { this.resolvedLanguage = n; break } } } }, { key: \"changeLanguage\", value: function (e, t) { var n = this; this.isLanguageChangingTo = e; var r = d(); this.emit(\"languageChanging\", e); var o = function (e) { n.language = e, n.languages = n.services.languageUtils.toResolveHierarchy(e), n.resolvedLanguage = void 0, n.setResolvedLanguage(e) }, i = function (i) { e || i || !n.services.languageDetector || (i = []); var a = \"string\" == typeof i ? i : n.services.languageUtils.getBestMatchFromCodes(i); a && (n.language || o(a), n.translator.language || n.translator.changeLanguage(a), n.services.languageDetector && n.services.languageDetector.cacheUserLanguage(a)), n.loadResources(a, function (e) { !function (e, i) { i ? (o(i), n.translator.changeLanguage(i), n.isLanguageChangingTo = void 0, n.emit(\"languageChanged\", i), n.logger.log(\"languageChanged\", i)) : n.isLanguageChangingTo = void 0, r.resolve(function () { return n.t.apply(n, arguments) }), t && t(e, function () { return n.t.apply(n, arguments) }) }(e, a) }) }; return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(i) : i(e) : i(this.services.languageDetector.detect()), r } }, { key: \"getFixedT\", value: function (t, n, r) { var o = this, i = function t(n, i) { var a; if (\"object\" !== e(i)) { for (var s = arguments.length, u = new Array(s > 2 ? s - 2 : 0), c = 2; c < s; c++)u[c - 2] = arguments[c]; a = o.options.overloadTranslationOptionHandler([n, i].concat(u)) } else a = re({}, i); a.lng = a.lng || t.lng, a.lngs = a.lngs || t.lngs, a.ns = a.ns || t.ns; var l = o.options.keySeparator || \".\", f = r ? \"\".concat(r).concat(l).concat(n) : n; return o.t(f, a) }; return \"string\" == typeof t ? i.lng = t : i.lngs = t, i.ns = n, i.keyPrefix = r, i } }, { key: \"t\", value: function () { var e; return this.translator && (e = this.translator).translate.apply(e, arguments) } }, { key: \"exists\", value: function () { var e; return this.translator && (e = this.translator).exists.apply(e, arguments) } }, { key: \"setDefaultNamespace\", value: function (e) { this.options.defaultNS = e } }, { key: \"hasLoadedNamespace\", value: function (e) { var t = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.isInitialized) return this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages), !1; var r = this.resolvedLanguage || this.languages[0], o = !!this.options && this.options.fallbackLng, i = this.languages[this.languages.length - 1]; if (\"cimode\" === r.toLowerCase()) return !0; var a = function (e, n) { var r = t.services.backendConnector.state[\"\".concat(e, \"|\").concat(n)]; return -1 === r || 2 === r }; if (n.precheck) { var s = n.precheck(this, a); if (void 0 !== s) return s } return !!this.hasResourceBundle(r, e) || (!(this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages)) || !(!a(r, e) || o && !a(i, e))) } }, { key: \"loadNamespaces\", value: function (e, t) { var n = this, r = d(); return this.options.ns ? (\"string\" == typeof e && (e = [e]), e.forEach(function (e) { n.options.ns.indexOf(e) < 0 && n.options.ns.push(e) }), this.loadResources(function (e) { r.resolve(), t && t(e) }), r) : (t && t(), Promise.resolve()) } }, { key: \"loadLanguages\", value: function (e, t) { var n = d(); \"string\" == typeof e && (e = [e]); var r = this.options.preload || [], o = e.filter(function (e) { return r.indexOf(e) < 0 }); return o.length ? (this.options.preload = r.concat(o), this.loadResources(function (e) { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } }, { key: \"dir\", value: function (e) { if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return \"rtl\"; return [\"ar\", \"shu\", \"sqr\", \"ssh\", \"xaa\", \"yhd\", \"yud\", \"aao\", \"abh\", \"abv\", \"acm\", \"acq\", \"acw\", \"acx\", \"acy\", \"adf\", \"ads\", \"aeb\", \"aec\", \"afb\", \"ajp\", \"apc\", \"apd\", \"arb\", \"arq\", \"ars\", \"ary\", \"arz\", \"auz\", \"avl\", \"ayh\", \"ayl\", \"ayn\", \"ayp\", \"bbz\", \"pga\", \"he\", \"iw\", \"ps\", \"pbt\", \"pbu\", \"pst\", \"prp\", \"prd\", \"ug\", \"ur\", \"ydd\", \"yds\", \"yih\", \"ji\", \"yi\", \"hbo\", \"men\", \"xmn\", \"fa\", \"jpr\", \"peo\", \"pes\", \"prs\", \"dv\", \"sam\", \"ckb\"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\" } }, { key: \"cloneInstance\", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ie, r = re(re(re({}, this.options), t), { isClone: !0 }), o = new u(r); return [\"store\", \"services\", \"language\"].forEach(function (t) { o[t] = e[t] }), o.services = re({}, this.services), o.services.utils = { hasLoadedNamespace: o.hasLoadedNamespace.bind(o) }, o.translator = new A(o.services, o.options), o.translator.on(\"*\", function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; o.emit.apply(o, [e].concat(n)) }), o.init(r, n), o.translator.options = o.options, o.translator.backendConnector.services.utils = { hasLoadedNamespace: o.hasLoadedNamespace.bind(o) }, o } }, { key: \"toJSON\", value: function () { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } }]), u }(); c(ae, \"createInstance\", function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0; return new ae(e, t) }); var se = ae.createInstance(); return se.createInstance = ae.createInstance, se });\n\n\n//Included:lib/011.vue-i18next-v0.15.2.js\n// ~$ npm install @panter/vue-i18next@0.15.2\n\n(function (factory) {\n    // Only navigators:\n    if (typeof window === 'undefined') return;\n    // General boilerplate:\n    if (typeof window !== \"undefined\") {\n        if (\"VueI18n\" in window) return window.VueI18n;\n    }\n    if (typeof global !== \"undefined\") {\n        if (\"VueI18n\" in global) return global.VueI18n;\n    }\n    const output = factory();\n    if (typeof module === 'object' && typeof module.exports === 'object') module.exports = output;\n    if (typeof define === 'function' && define.amd) define([], factory);\n    if (typeof exports === 'object') exports[\"VueI18n\"] = output;\n    if (typeof window !== \"undefined\") {\n        if (typeof window !== 'undefined') window.VueI18n = output;\n    }\n    if (typeof global !== \"undefined\") {\n        if (typeof global !== 'undefined') global.VueI18n = output;\n    }\n    return output;\n}(function () {\n    'use strict';\n\n    var isMergeableObject = function isMergeableObject(value) {\n        return isNonNullObject(value)\n            && !isSpecial(value)\n    };\n\n    function isNonNullObject(value) {\n        return !!value && typeof value === 'object'\n    }\n\n    function isSpecial(value) {\n        var stringValue = Object.prototype.toString.call(value);\n\n        return stringValue === '[object RegExp]'\n            || stringValue === '[object Date]'\n            || isReactElement(value)\n    }\n\n    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n    function isReactElement(value) {\n        return value.$$typeof === REACT_ELEMENT_TYPE\n    }\n\n    function emptyTarget(val) {\n        return Array.isArray(val) ? [] : {}\n    }\n\n    function cloneUnlessOtherwiseSpecified(value, options) {\n        return (options.clone !== false && options.isMergeableObject(value))\n            ? deepmerge(emptyTarget(value), value, options)\n            : value\n    }\n\n    function defaultArrayMerge(target, source, options) {\n        return target.concat(source).map(function (element) {\n            return cloneUnlessOtherwiseSpecified(element, options)\n        })\n    }\n\n    function mergeObject(target, source, options) {\n        var destination = {};\n        if (options.isMergeableObject(target)) {\n            Object.keys(target).forEach(function (key) {\n                destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n            });\n        }\n        Object.keys(source).forEach(function (key) {\n            if (!options.isMergeableObject(source[key]) || !target[key]) {\n                destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n            } else {\n                destination[key] = deepmerge(target[key], source[key], options);\n            }\n        });\n        return destination\n    }\n\n    function deepmerge(target, source, options) {\n        options = options || {};\n        options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n        options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n        var sourceIsArray = Array.isArray(source);\n        var targetIsArray = Array.isArray(target);\n        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n        if (!sourceAndTargetTypesMatch) {\n            return cloneUnlessOtherwiseSpecified(source, options)\n        } else if (sourceIsArray) {\n            return options.arrayMerge(target, source, options)\n        } else {\n            return mergeObject(target, source, options)\n        }\n    }\n\n    deepmerge.all = function deepmergeAll(array, options) {\n        if (!Array.isArray(array)) {\n            throw new Error('first argument should be an array')\n        }\n\n        return array.reduce(function (prev, next) {\n            return deepmerge(prev, next, options)\n        }, {})\n    };\n\n    var deepmerge_1 = deepmerge;\n\n    var component = {\n        name: 'i18next',\n        functional: true,\n        props: {\n            tag: {\n                type: String,\n                default: 'span'\n            },\n            path: {\n                type: String,\n                required: true\n            },\n            options: {\n                type: Object\n            }\n        },\n        render: function render(h, ref) {\n            var props = ref.props;\n            var data = ref.data;\n            var children = ref.children;\n            var parent = ref.parent;\n\n            var i18next = parent.$i18n;\n            var $t = parent.$t.bind(parent);\n            if (!i18next || !$t) {\n                return h(props.tag, data, children);\n            }\n\n            var path = props.path;\n            var options = props.options || {};\n\n            var REGEXP = i18next.i18next.services.interpolator.regexp;\n            var i18nextOptions = Object.assign({}, options,\n                { interpolation: { prefix: '#$?', suffix: '?$#' } });\n            var format = $t(path, i18nextOptions);\n            var tchildren = [];\n\n            format.split(REGEXP).reduce(function (memo, match, index) {\n                var child;\n                if (index % 2 === 0) {\n                    if (match.length === 0) { return memo; }\n\n                    child = match;\n                } else {\n                    var place = match.trim();\n                    // eslint-disable-next-line no-restricted-globals\n                    if (isNaN(parseFloat(place)) || !isFinite(place)) {\n                        children.forEach(function (e) {\n                            if (\n                                !child &&\n                                e.data.attrs &&\n                                e.data.attrs.place &&\n                                e.data.attrs.place === place\n                            ) {\n                                child = e;\n                            }\n                        });\n                    } else {\n                        child = children[parseInt(match, 10)];\n                    }\n                }\n\n                memo.push(child);\n                return memo;\n            }, tchildren);\n\n            return h(props.tag, data, tchildren);\n        }\n    };\n\n    /* eslint-disable import/prefer-default-export */\n\n    function log(message) {\n        if (typeof console !== 'undefined') {\n            console.warn(message); // eslint-disable-line no-console\n        }\n    }\n\n    function warn(message) {\n        log((\"[vue-i18next warn]: \" + message));\n    }\n\n    function deprecate(message) {\n        log((\"[vue-i18next deprecated]: \" + message));\n    }\n\n    /* eslint-disable no-param-reassign, no-unused-vars */\n\n    function equalLanguage(el, vnode) {\n        var vm = vnode.context;\n        return el._i18nLanguage === vm.$i18n.i18next.language;\n    }\n\n    function equalValue(value, oldValue) {\n        if (value === oldValue) {\n            return true;\n        }\n        if (value && oldValue) {\n            return (\n                value.path === oldValue.path &&\n                value.language === oldValue.language &&\n                value.args === oldValue.args\n            );\n        }\n    }\n\n    function assert(vnode) {\n        var vm = vnode.context;\n\n        if (!vm.$i18n) {\n            warn('No VueI18Next instance found in the Vue instance');\n            return false;\n        }\n\n        return true;\n    }\n\n    function parseValue(value) {\n        var assign;\n\n        var path;\n        var language;\n        var args;\n\n        if (typeof value === 'string') {\n            path = value;\n        } else if (toString.call(value) === '[object Object]') {\n            ((assign = value, path = assign.path, language = assign.language, args = assign.args));\n        }\n\n        return { path: path, language: language, args: args };\n    }\n\n    function t(el, binding, vnode) {\n        var value = binding.value;\n\n        var ref = parseValue(value);\n        var path = ref.path;\n        var language = ref.language;\n        var args = ref.args;\n        if (!path && !language && !args) {\n            warn('v-t: invalid value');\n            return;\n        }\n\n        if (!path) {\n            warn('v-t: \"path\" is required');\n            return;\n        }\n\n        if (language) {\n            deprecate(\"v-t: \\\"language\\\" is deprecated.Use the \\\"lng\\\" property in args.\\n      https://www.i18next.com/overview/configuration-options#configuration-options\");\n        }\n\n        var vm = vnode.context;\n        el.textContent = vm.$i18n.i18next.t(path, Object.assign({}, (language ? { lng: language } : {}),\n            args));\n\n        el._i18nLanguage = vm.$i18n.i18next.language;\n    }\n\n    function bind(el, binding, vnode) {\n        if (!assert(vnode)) {\n            return;\n        }\n\n        t(el, binding, vnode);\n    }\n\n    function update(el, binding, vnode, oldVNode) {\n        if (equalLanguage(el, vnode) && equalValue(binding.value, binding.oldValue)) {\n            return;\n        }\n\n        t(el, binding, vnode);\n    }\n\n    var directive = {\n        bind: bind,\n        update: update\n    };\n\n    /* eslint-disable no-param-reassign, no-unused-vars */\n\n    function assert$1(vnode) {\n        var vm = vnode.context;\n\n        if (!vm.$i18n) {\n            warn('No VueI18Next instance found in the Vue instance');\n            return false;\n        }\n\n        return true;\n    }\n\n    function waitForIt(el, vnode) {\n        if (vnode.context.$i18n.i18next.isInitialized) {\n            el.hidden = false;\n        } else {\n            el.hidden = true;\n            var initialized = function () {\n                vnode.context.$forceUpdate();\n                // due to emitter removing issue in i18next we need to delay remove\n                setTimeout(function () {\n                    if (vnode.context && vnode.context.$i18n) {\n                        vnode.context.$i18n.i18next.off('initialized', initialized);\n                    }\n                }, 1000);\n            };\n            vnode.context.$i18n.i18next.on('initialized', initialized);\n        }\n    }\n\n    function bind$1(el, binding, vnode) {\n        if (!assert$1(vnode)) {\n            return;\n        }\n\n        waitForIt(el, vnode);\n    }\n\n    function update$1(el, binding, vnode, oldVNode) {\n        if (vnode.context.$i18n.i18next.isInitialized) {\n            el.hidden = false;\n        }\n    }\n\n    var waitDirective = {\n        bind: bind$1,\n        update: update$1\n    };\n\n    /* eslint-disable import/no-mutable-exports */\n\n    var Vue;\n\n    function install(_Vue) {\n        if (install.installed) {\n            return;\n        }\n        install.installed = true;\n\n        Vue = _Vue;\n\n        var getByKey = function (i18nOptions, i18nextOptions) {\n            return function (key) {\n                if (\n                    i18nOptions &&\n                    i18nOptions.keyPrefix &&\n                    !key.includes(i18nextOptions.nsSeparator)\n                ) {\n                    return ((i18nOptions.keyPrefix) + \".\" + key);\n                }\n                return key;\n            };\n        };\n\n        var getComponentNamespace = function (vm) {\n            var namespace = vm.$options.name || vm.$options._componentTag;\n            if (namespace) {\n                return {\n                    namespace: namespace,\n                    loadNamespace: true\n                };\n            }\n\n            return {\n                namespace: (\"\" + (Math.random()))\n            };\n        };\n\n        Vue.mixin({\n            beforeCreate: function beforeCreate() {\n                var this$1 = this;\n\n                var options = this.$options;\n                if (options.i18n) {\n                    this._i18n = options.i18n;\n                } else if (options.parent && options.parent.$i18n) {\n                    this._i18n = options.parent.$i18n;\n                }\n                var inlineTranslations = {};\n\n                if (this._i18n) {\n                    var getNamespace =\n                        this._i18n.options.getComponentNamespace || getComponentNamespace;\n                    var ref = getNamespace(this);\n                    var namespace = ref.namespace;\n                    var loadNamespace = ref.loadNamespace;\n\n                    if (options.__i18n) {\n                        options.__i18n.forEach(function (resource) {\n                            inlineTranslations = deepmerge_1(\n                                inlineTranslations,\n                                JSON.parse(resource)\n                            );\n                        });\n                    }\n\n                    if (options.i18nOptions) {\n                        var ref$1 = this.$options.i18nOptions;\n                        var lng = ref$1.lng; if (lng === void 0) lng = null;\n                        var keyPrefix = ref$1.keyPrefix; if (keyPrefix === void 0) keyPrefix = null;\n                        var messages = ref$1.messages;\n                        var ref$2 = this.$options.i18nOptions;\n                        var namespaces = ref$2.namespaces;\n                        namespaces = namespaces || this._i18n.i18next.options.defaultNS;\n\n                        if (typeof namespaces === 'string') { namespaces = [namespaces]; }\n                        var namespacesToLoad = namespaces.concat([namespace]);\n\n                        if (messages) {\n                            inlineTranslations = deepmerge_1(inlineTranslations, messages);\n                        }\n\n                        this._i18nOptions = { lng: lng, namespaces: namespacesToLoad, keyPrefix: keyPrefix };\n                        this._i18n.i18next.loadNamespaces(namespaces);\n                    } else if (options.parent && options.parent._i18nOptions) {\n                        this._i18nOptions = Object.assign({}, options.parent._i18nOptions);\n                        this._i18nOptions.namespaces = [\n                            namespace].concat(this._i18nOptions.namespaces\n                            );\n                    } else if (options.__i18n) {\n                        this._i18nOptions = { namespaces: [namespace] };\n                    }\n\n                    if (loadNamespace && this._i18n.options.loadComponentNamespace) {\n                        this._i18n.i18next.loadNamespaces([namespace]);\n                    }\n\n                    var languages = Object.keys(inlineTranslations);\n                    languages.forEach(function (lang) {\n                        this$1._i18n.i18next.addResourceBundle(\n                            lang,\n                            namespace,\n                            Object.assign({}, inlineTranslations[lang]),\n                            true,\n                            false\n                        );\n                    });\n                }\n\n                var getKey = getByKey(\n                    this._i18nOptions,\n                    this._i18n ? this._i18n.i18next.options : {}\n                );\n\n                if (this._i18nOptions && this._i18nOptions.namespaces) {\n                    var ref$3 = this._i18nOptions;\n                    var lng$1 = ref$3.lng;\n                    var namespaces$1 = ref$3.namespaces;\n\n                    var fixedT = this._i18n.i18next.getFixedT(lng$1, namespaces$1);\n                    this._getI18nKey = function (key, i18nextOptions) { return fixedT(getKey(key), i18nextOptions, this$1._i18n.i18nLoadedAt); };\n                } else {\n                    this._getI18nKey = function (key, i18nextOptions) { return this$1._i18n.t(getKey(key), i18nextOptions, this$1._i18n.i18nLoadedAt); };\n                }\n            }\n        });\n\n        // extend Vue.js\n        if (!Object.prototype.hasOwnProperty.call(Vue.prototype, '$i18n')) {\n            Object.defineProperty(Vue.prototype, '$i18n', {\n                get: function get() {\n                    return this._i18n;\n                }\n            });\n        }\n\n        Vue.prototype.$t = function t(key, options) {\n            return this._getI18nKey(key, options);\n        };\n\n        Vue.component(component.name, component);\n        Vue.directive('t', directive);\n        Vue.directive('waitForT', waitDirective);\n    }\n\n    var VueI18n = function VueI18n(i18next, opts) {\n        if (opts === void 0) opts = {};\n\n        var options = Object.assign({}, {\n            bindI18n: 'languageChanged loaded',\n            bindStore: 'added removed',\n            loadComponentNamespace: false\n        },\n            opts);\n\n        this._vm = null;\n        this.i18next = i18next;\n        this.options = options;\n\n        this.onI18nChanged = this.onI18nChanged.bind(this);\n\n        if (options.bindI18n) {\n            this.i18next.on(options.bindI18n, this.onI18nChanged);\n        }\n        if (options.bindStore && this.i18next.store) {\n            this.i18next.store.on(options.bindStore, this.onI18nChanged);\n        }\n\n        this.resetVM({ i18nLoadedAt: new Date() });\n    };\n\n    var prototypeAccessors = { i18nLoadedAt: { configurable: true } };\n\n    VueI18n.prototype.resetVM = function resetVM(data) {\n        var oldVM = this._vm;\n        var ref = Vue.config;\n        var silent = ref.silent;\n        Vue.config.silent = true;\n        this._vm = new Vue({ data: data });\n        Vue.config.silent = silent;\n        if (oldVM) {\n            Vue.nextTick(function () { return oldVM.$destroy(); });\n        }\n    };\n\n    prototypeAccessors.i18nLoadedAt.get = function () {\n        return this._vm.$data.i18nLoadedAt;\n    };\n\n    prototypeAccessors.i18nLoadedAt.set = function (date) {\n        this._vm.$set(this._vm, 'i18nLoadedAt', date);\n    };\n\n    VueI18n.prototype.t = function t(key, options) {\n        return this.i18next.t(key, options);\n    };\n\n    VueI18n.prototype.onI18nChanged = function onI18nChanged() {\n        this.i18nLoadedAt = new Date();\n    };\n\n    Object.defineProperties(VueI18n.prototype, prototypeAccessors);\n\n    VueI18n.install = install;\n    VueI18n.version = \"0.15.2\";\n\n    /* istanbul ignore if */\n    if (typeof window !== 'undefined' && window.Vue) {\n        window.Vue.use(VueI18n);\n    }\n\n    return VueI18n;\n\n}));\n\n\n//Included:lib/012.ranas-db-v0.0.1.part.js\n(() => { var t = { 363: function (t) { t.exports = function () { class t { static that(...t) { return new this(...t) } constructor(t, n = \"?\", e = \"xxxxx\") { this.target = t, this.targetID = n, this.errorID = e, this.and = this } equals(t, n) { if (this.target === t) return this; throw new Error(\"Expected <\" + this.targetID + \"> to equal <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } isUndefined() { if (void 0 === this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be undefined [ERROR:\" + this.errorID + \"]\") } isNotUndefined() { if (void 0 !== this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to not be undefined [ERROR:\" + this.errorID + \"]\") } isNumber() { if (\"number\" == typeof this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be a number [ERROR:\" + this.errorID + \"]\") } isString() { if (\"string\" == typeof this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be a string [ERROR:\" + this.errorID + \"]\") } isObject() { if (\"object\" == typeof this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be an object [ERROR:\" + this.errorID + \"]\") } isFunction() { if (\"function\" == typeof this.target) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be a function [ERROR:\" + this.errorID + \"]\") } isArray() { if (Array.isArray(this.target)) return this; throw new Error(\"Expected <\" + this.targetID + \"> to be an array [ERROR:\" + this.errorID + \"]\") } isGreaterThan(t, n) { try { if (this.target > t) return this } catch (e) { throw new Error(\"Expected <\" + this.targetID + \"> to be -comparable as- greater than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to be greater than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } isLowerThan(t, n) { try { if (this.target < t) return this } catch (e) { throw new Error(\"Expected <\" + this.targetID + \"> to be -comparable as- lower than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to be lower than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } isInstanceOf(t, n = !1) { try { if (this.target instanceof t) return this } catch (e) { throw new Error(\"Expected <\" + this.targetID + \"> to be -comparable as- instance of <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to be an instance of <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } isDate() { try { if (this.target instanceof Date) return this } catch (t) { throw new Error(\"Expected <\" + this.targetID + \"> to be -comparable as- a date [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to be a date [ERROR:\" + this.errorID + \"]\") } hasLengthGreaterThan(t, n) { try { if (this.target.length > t) return this } catch (e) { throw new Error(\"Expected <\" + this.targetID + \"> to have a length -comparable as- greater than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to have a length greater than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } hasLengthLowerThan(t, n) { try { if (this.target.length < t) return this } catch (e) { throw new Error(\"Expected <\" + this.targetID + \"> to have a length -comparable as- lower than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to have a length lower than <\" + (n || t) + \"> [ERROR:\" + this.errorID + \"]\") } can(t, n = \"?\") { try { if (\"function\" == typeof t && !0 === t(this.target, this)) return this } catch (t) { throw new Error(\"Expected <\" + this.targetID + \"> to -be called and to- be able to <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to be able to <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } cannot(t, n = \"?\") { try { if (\"function\" == typeof t && !1 === t(this.target, this)) return this } catch (t) { throw new Error(\"Expected <\" + this.targetID + \"> to -be called and to- not be able to <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to not be able to <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } throwsOn(t, n = \"?\") { if (\"function\" == typeof t) { try { t(this.target, this) } catch (t) { return this } throw new Error(\"Expected <\" + this.targetID + \"> to throw errors on <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to -be called and to- throw errors on <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } doesNotThrowOn(t, n = \"?\") { try { if (\"function\" == typeof t) return t(this.target, this), this } catch (t) { throw new Error(\"Expected <\" + this.targetID + \"> to not throw errors on <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } throw new Error(\"Expected <\" + this.targetID + \"> to -be called and to- not throw errors on <\" + n + \"> [ERROR:\" + this.errorID + \"]\") } } return t.default = t, t }() }, 534: function (t, n, e) { t.exports = function (t) { \"use strict\"; t = \"default\" in t ? t.default : t; var n = function (t) { this.schema = t }; function e(t) { return null != t && (\"string\" == typeof t || \"number\" == typeof t || t instanceof Date || Array.isArray(t) && t.every(e)) } n.prototype.getForeignKeys = function () { var t = this, n = {}; return Object.keys(this.schema).forEach((function (e) { var r = t.schema[e].split(\",\"); n[e] = r.filter((function (t) { return -1 !== t.indexOf(\"->\") })).map((function (t) { var n = t.split(\"->\").map((function (t) { return t.trim() })), e = n[0], r = n[1]; return { index: e, targetTable: r.split(\".\")[0], targetIndex: r.split(\".\")[1] } })) })), n }, n.prototype.getCleanedSchema = function () { var t = this, n = {}; return Object.keys(this.schema).forEach((function (e) { var r = t.schema[e].split(\",\"); n[e] = r.map((function (t) { return t.split(\"->\")[0].trim() })).join(\",\") })), n }; var r = function (r) { var i = t.Promise; r.Table.prototype.with = function (t) { return this.toCollection().with(t) }, r.Collection.prototype.with = function (t) { var n = this, o = this._ctx.table.name, a = r._allTables, u = []; return Object.keys(t).forEach((function (e) { var r = t[e], i = n._ctx.table.schema.idxByName[r]; if (i && i.hasOwnProperty(\"foreignKey\")) { var s = i; u.push({ column: e, index: s.foreignKey.targetIndex, tableName: s.foreignKey.targetTable, targetIndex: s.foreignKey.index, oneToOne: !0 }) } else { var c = r; if (!a.hasOwnProperty(c)) throw new Error(\"Relationship table \" + c + \" doesn't exist.\"); if (!a[c].schema.hasOwnProperty(\"foreignKeys\")) throw new Error(\"Relationship table \" + c + \" doesn't have foreign keys set.\"); var f = a[c].schema.foreignKeys.filter((function (t) { return t.targetTable === o })); f.length > 0 && u.push({ column: e, index: f[0].index, tableName: c, targetIndex: f[0].targetIndex }) } })), this.toArray().then((function (t) { var n = u.map((function (n) { var r = n.tableName, i = t.map((function (t) { return t[n.targetIndex] })).filter(e); return a[r].where(n.index).anyOf(i) })).map((function (t) { return t.toArray() })); return i.all(n).then((function (n) { u.forEach((function (e, r) { var i = e.tableName, a = n[r], u = e.targetIndex, s = e.index, c = e.column, f = {}; a.forEach((function (t) { var n = t[s]; e.oneToOne ? f[n] = t : (f[n] = f[n] || []).push(t) })), t.forEach((function (t) { var n = t[u], e = f[n] || []; if (null != n && !e) throw new Error(\"Could not lookup foreign key where \" + i + \".\" + s + \" == \" + o + \".\" + c + \". The content of the failing key was: \" + JSON.stringify(n) + \".\"); Object.defineProperty(t, c, { value: e, enumerable: !1, configurable: !0, writable: !0 }) })) })) })).then((function () { return t })) })) }, r.Version.prototype._parseStoresSpec = t.override(r.Version.prototype._parseStoresSpec, (function (t) { return function (e, r) { var i = new n(e), o = i.getForeignKeys(), a = t.call(this, i.getCleanedSchema(), r); return Object.keys(r).forEach((function (t) { o.hasOwnProperty(t) && (r[t].foreignKeys = o[t], o[t].forEach((function (n) { r[t].idxByName[n.index].foreignKey = n }))) })), a } })) }; return r.default = r, r }(e(128)) }, 128: (t, n, e) => { \"use strict\"; e.r(n), e.d(n, { default: () => Mn }); var r = Object.keys, i = Array.isArray, o = \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : e.g; function a(t, n) { return \"object\" != typeof n || r(n).forEach((function (e) { t[e] = n[e] })), t } var u = Object.getPrototypeOf, s = {}.hasOwnProperty; function c(t, n) { return s.call(t, n) } function f(t, n) { \"function\" == typeof n && (n = n(u(t))), r(n).forEach((function (e) { l(t, e, n[e]) })) } var h = Object.defineProperty; function l(t, n, e, r) { h(t, n, a(e && c(e, \"get\") && \"function\" == typeof e.get ? { get: e.get, set: e.set, configurable: !0 } : { value: e, configurable: !0, writable: !0 }, r)) } function d(t) { return { from: function (n) { return t.prototype = Object.create(n.prototype), l(t.prototype, \"constructor\", t), { extend: f.bind(null, t.prototype) } } } } var p = Object.getOwnPropertyDescriptor; function v(t, n) { var e; return p(t, n) || (e = u(t)) && v(e, n) } var g = [].slice; function y(t, n, e) { return g.call(t, n, e) } function m(t, n) { return n(t) } function b(t) { if (!t) throw new Error(\"Assertion Failed\") } function w(t) { o.setImmediate ? setImmediate(t) : setTimeout(t, 0) } function _(t, n) { return t.reduce((function (t, e, r) { var i = n(e, r); return i && (t[i[0]] = i[1]), t }), {}) } function x(t, n, e) { try { t.apply(null, e) } catch (t) { n && n(t) } } function E(t, n) { if (c(t, n)) return t[n]; if (!n) return t; if (\"string\" != typeof n) { for (var e = [], r = 0, i = n.length; r < i; ++r) { var o = E(t, n[r]); e.push(o) } return e } var a = n.indexOf(\".\"); if (-1 !== a) { var u = t[n.substr(0, a)]; return void 0 === u ? void 0 : E(u, n.substr(a + 1)) } } function k(t, n, e) { if (t && void 0 !== n && (!(\"isFrozen\" in Object) || !Object.isFrozen(t))) if (\"string\" != typeof n && \"length\" in n) { b(\"string\" != typeof e && \"length\" in e); for (var r = 0, i = n.length; r < i; ++r)k(t, n[r], e[r]) } else { var o = n.indexOf(\".\"); if (-1 !== o) { var a = n.substr(0, o), u = n.substr(o + 1); if (\"\" === u) void 0 === e ? delete t[a] : t[a] = e; else { var s = t[a]; s || (s = t[a] = {}), k(s, u, e) } } else void 0 === e ? delete t[n] : t[n] = e } } function D(t) { var n = {}; for (var e in t) c(t, e) && (n[e] = t[e]); return n } var I = [].concat; function O(t) { return I.apply([], t) } var R = \"Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set\".split(\",\").concat(O([8, 16, 32, 64].map((function (t) { return [\"Int\", \"Uint\", \"Float\"].map((function (n) { return n + t + \"Array\" })) })))).filter((function (t) { return o[t] })).map((function (t) { return o[t] })); function j(t) { if (!t || \"object\" != typeof t) return t; var n; if (i(t)) { n = []; for (var e = 0, r = t.length; e < r; ++e)n.push(j(t[e])) } else if (R.indexOf(t.constructor) >= 0) n = t; else for (var o in n = t.constructor ? Object.create(t.constructor.prototype) : {}, t) c(t, o) && (n[o] = j(t[o])); return n } function P(t, n, e, i) { return e = e || {}, i = i || \"\", r(t).forEach((function (r) { if (c(n, r)) { var o = t[r], a = n[r]; \"object\" == typeof o && \"object\" == typeof a && o && a && \"\" + o.constructor == \"\" + a.constructor ? P(o, a, e, i + r + \".\") : o !== a && (e[i + r] = n[r]) } else e[i + r] = void 0 })), r(n).forEach((function (r) { c(t, r) || (e[i + r] = n[r]) })), e } var S = \"undefined\" != typeof Symbol && Symbol.iterator, A = S ? function (t) { var n; return null != t && (n = t[S]) && n.apply(t) } : function () { return null }, T = {}; function C(t) { var n, e, r, o; if (1 === arguments.length) { if (i(t)) return t.slice(); if (this === T && \"string\" == typeof t) return [t]; if (o = A(t)) { for (e = []; !(r = o.next()).done;)e.push(r.value); return e } if (null == t) return [t]; if (\"number\" == typeof (n = t.length)) { for (e = new Array(n); n--;)e[n] = t[n]; return e } return [t] } for (n = arguments.length, e = new Array(n); n--;)e[n] = arguments[n]; return e } var K = \"undefined\" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href); function B(t, n) { K = t, F = n } var F = function () { return !0 }, N = !new Error(\"\").stack; function M() { if (N) try { throw M.arguments, new Error } catch (t) { return t } return new Error } function q(t, n) { var e = t.stack; return e ? (n = n || 0, 0 === e.indexOf(t.name) && (n += (t.name + t.message).split(\"\\n\").length), e.split(\"\\n\").slice(n).filter(F).map((function (t) { return \"\\n\" + t })).join(\"\")) : \"\" } var U = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"], L = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"].concat(U), V = { VersionChanged: \"Database version changed by other database connection\", DatabaseClosed: \"Database has been closed\", Abort: \"Transaction aborted\", TransactionInactive: \"Transaction has already completed or failed\" }; function z(t, n) { this._e = M(), this.name = t, this.message = n } function W(t, n, e, r) { this._e = M(), this.failures = n, this.failedKeys = r, this.successCount = e } function $(t, n) { this._e = M(), this.name = \"BulkError\", this.failures = n, this.message = function (t, n) { return t + \". Errors: \" + n.map((function (t) { return t.toString() })).filter((function (t, n, e) { return e.indexOf(t) === n })).join(\"\\n\") }(t, n) } d(z).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + \": \" + this.message + q(this._e, 2)) } }, toString: function () { return this.name + \": \" + this.message } }), d(W).from(z), d($).from(z); var G = L.reduce((function (t, n) { return t[n] = n + \"Error\", t }), {}), Q = z, H = L.reduce((function (t, n) { var e = n + \"Error\"; function r(t, r) { this._e = M(), this.name = e, t ? \"string\" == typeof t ? (this.message = t, this.inner = r || null) : \"object\" == typeof t && (this.message = t.name + \" \" + t.message, this.inner = t) : (this.message = V[n] || e, this.inner = null) } return d(r).from(Q), t[n] = r, t }), {}); H.Syntax = SyntaxError, H.Type = TypeError, H.Range = RangeError; var J = U.reduce((function (t, n) { return t[n + \"Error\"] = H[n], t }), {}), Y = L.reduce((function (t, n) { return -1 === [\"Syntax\", \"Type\", \"Range\"].indexOf(n) && (t[n + \"Error\"] = H[n]), t }), {}); function X() { } function Z(t) { return t } function tt(t, n) { return null == t || t === Z ? n : function (e) { return n(t(e)) } } function nt(t, n) { return function () { t.apply(this, arguments), n.apply(this, arguments) } } function et(t, n) { return t === X ? n : function () { var e = t.apply(this, arguments); void 0 !== e && (arguments[0] = e); var r = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var o = n.apply(this, arguments); return r && (this.onsuccess = this.onsuccess ? nt(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? nt(i, this.onerror) : i), void 0 !== o ? o : e } } function rt(t, n) { return t === X ? n : function () { t.apply(this, arguments); var e = this.onsuccess, r = this.onerror; this.onsuccess = this.onerror = null, n.apply(this, arguments), e && (this.onsuccess = this.onsuccess ? nt(e, this.onsuccess) : e), r && (this.onerror = this.onerror ? nt(r, this.onerror) : r) } } function it(t, n) { return t === X ? n : function (e) { var r = t.apply(this, arguments); a(e, r); var i = this.onsuccess, o = this.onerror; this.onsuccess = null, this.onerror = null; var u = n.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? nt(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? nt(o, this.onerror) : o), void 0 === r ? void 0 === u ? void 0 : u : a(r, u) } } function ot(t, n) { return t === X ? n : function () { return !1 !== n.apply(this, arguments) && t.apply(this, arguments) } } function at(t, n) { return t === X ? n : function () { var e = t.apply(this, arguments); if (e && \"function\" == typeof e.then) { for (var r = this, i = arguments.length, o = new Array(i); i--;)o[i] = arguments[i]; return e.then((function () { return n.apply(r, o) })) } return n.apply(this, arguments) } } Y.ModifyError = W, Y.DexieError = z, Y.BulkError = $; var ut = {}, st = function () { try { return new Function(\"let F=async ()=>{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];\")() } catch (n) { var t = o.Promise; return t ? [t.resolve(), t.prototype, t.resolve()] : [] } }(), ct = st[0], ft = st[1], ht = st[2], lt = ft && ft.then, dt = ct && ct.constructor, pt = st[3], vt = !!ht, gt = !1, yt = ht ? function () { ht.then(qt) } : o.setImmediate ? setImmediate.bind(null, qt) : o.MutationObserver ? function () { var t = document.createElement(\"div\"); new MutationObserver((function () { qt(), t = null })).observe(t, { attributes: !0 }), t.setAttribute(\"i\", \"1\") } : function () { setTimeout(qt, 0) }, mt = function (t, n) { Ot.push([t, n]), wt && (yt(), wt = !1) }, bt = !0, wt = !0, _t = [], xt = [], Et = null, kt = Z, Dt = { id: \"global\", global: !0, ref: 0, unhandleds: [], onunhandled: hn, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach((function (t) { try { hn(t[0], t[1]) } catch (t) { } })) } }, It = Dt, Ot = [], Rt = 0, jt = []; function Pt(t) { if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\"); this._listeners = [], this.onuncatched = X, this._lib = !1; var n = this._PSD = It; if (K && (this._stackHolder = M(), this._prev = null, this._numPrev = 0), \"function\" != typeof t) { if (t !== ut) throw new TypeError(\"Not a function\"); return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Ct(this, this._value)) } this._state = null, this._value = null, ++n.ref, Tt(this, t) } var St = { get: function () { var t = It, n = Jt; function e(e, r) { var i = this, o = !t.global && (t !== It || n !== Jt); o && tn(); var a = new Pt((function (n, a) { Bt(i, new At(sn(e, t, o), sn(r, t, o), n, a, t)) })); return K && Mt(a, this), a } return e.prototype = ut, e }, set: function (t) { l(this, \"then\", t && t.prototype === ut ? St : { get: function () { return t }, set: St.set }) } }; function At(t, n, e, r, i) { this.onFulfilled = \"function\" == typeof t ? t : null, this.onRejected = \"function\" == typeof n ? n : null, this.resolve = e, this.reject = r, this.psd = i } function Tt(t, n) { try { n((function (n) { if (null === t._state) { if (n === t) throw new TypeError(\"A promise cannot be resolved with itself.\"); var e = t._lib && Ut(); n && \"function\" == typeof n.then ? Tt(t, (function (t, e) { n instanceof Pt ? n._then(t, e) : n.then(t, e) })) : (t._state = !0, t._value = n, Kt(t)), e && Lt() } }), Ct.bind(null, t)) } catch (n) { Ct(t, n) } } function Ct(t, n) { if (xt.push(n), null === t._state) { var e = t._lib && Ut(); n = kt(n), t._state = !1, t._value = n, K && null !== n && \"object\" == typeof n && !n._promise && x((function () { var e = v(n, \"stack\"); n._promise = t, l(n, \"stack\", { get: function () { return gt ? e && (e.get ? e.get.apply(n) : e.value) : t.stack } }) })), function (t) { _t.some((function (n) { return n._value === t._value })) || _t.push(t) }(t), Kt(t), e && Lt() } } function Kt(t) { var n = t._listeners; t._listeners = []; for (var e = 0, r = n.length; e < r; ++e)Bt(t, n[e]); var i = t._PSD; --i.ref || i.finalize(), 0 === Rt && (++Rt, mt((function () { 0 == --Rt && Vt() }), [])) } function Bt(t, n) { if (null !== t._state) { var e = t._state ? n.onFulfilled : n.onRejected; if (null === e) return (t._state ? n.resolve : n.reject)(t._value); ++n.psd.ref, ++Rt, mt(Ft, [e, t, n]) } else t._listeners.push(n) } function Ft(t, n, e) { try { Et = n; var r, i = n._value; n._state ? r = t(i) : (xt.length && (xt = []), r = t(i), -1 === xt.indexOf(i) && function (t) { for (var n = _t.length; n;)if (_t[--n]._value === t._value) return void _t.splice(n, 1) }(n)), e.resolve(r) } catch (t) { e.reject(t) } finally { Et = null, 0 == --Rt && Vt(), --e.psd.ref || e.psd.finalize() } } function Nt(t, n, e) { if (n.length === e) return n; var r = \"\"; if (!1 === t._state) { var i, o, a = t._value; null != a ? (i = a.name || \"Error\", o = a.message || a, r = q(a, 0)) : (i = a, o = \"\"), n.push(i + (o ? \": \" + o : \"\") + r) } return K && ((r = q(t._stackHolder, 2)) && -1 === n.indexOf(r) && n.push(r), t._prev && Nt(t._prev, n, e)), n } function Mt(t, n) { var e = n ? n._numPrev + 1 : 0; e < 100 && (t._prev = n, t._numPrev = e) } function qt() { Ut() && Lt() } function Ut() { var t = bt; return bt = !1, wt = !1, t } function Lt() { var t, n, e; do { for (; Ot.length > 0;)for (t = Ot, Ot = [], e = t.length, n = 0; n < e; ++n) { var r = t[n]; r[0].apply(null, r[1]) } } while (Ot.length > 0); bt = !0, wt = !0 } function Vt() { var t = _t; _t = [], t.forEach((function (t) { t._PSD.onunhandled.call(null, t._value, t) })); for (var n = jt.slice(0), e = n.length; e;)n[--e]() } function zt(t) { return new Pt(ut, !1, t) } function Wt(t, n) { var e = It; return function () { var r = Ut(), i = It; try { return on(e, !0), t.apply(this, arguments) } catch (t) { n && n(t) } finally { on(i, !1), r && Lt() } } } f(Pt.prototype, { then: St, _then: function (t, n) { Bt(this, new At(null, null, t, n, It)) }, catch: function (t) { if (1 === arguments.length) return this.then(null, t); var n = arguments[0], e = arguments[1]; return \"function\" == typeof n ? this.then(null, (function (t) { return t instanceof n ? e(t) : zt(t) })) : this.then(null, (function (t) { return t && t.name === n ? e(t) : zt(t) })) }, finally: function (t) { return this.then((function (n) { return t(), n }), (function (n) { return t(), zt(n) })) }, stack: { get: function () { if (this._stack) return this._stack; try { gt = !0; var t = Nt(this, [], 20).join(\"\\nFrom previous: \"); return null !== this._state && (this._stack = t), t } finally { gt = !1 } } }, timeout: function (t, n) { var e = this; return t < 1 / 0 ? new Pt((function (r, i) { var o = setTimeout((function () { return i(new H.Timeout(n)) }), t); e.then(r, i).finally(clearTimeout.bind(null, o)) })) : this } }), \"undefined\" != typeof Symbol && Symbol.toStringTag && l(Pt.prototype, Symbol.toStringTag, \"Promise\"), Dt.env = an(), f(Pt, { all: function () { var t = C.apply(null, arguments).map(nn); return new Pt((function (n, e) { 0 === t.length && n([]); var r = t.length; t.forEach((function (i, o) { return Pt.resolve(i).then((function (e) { t[o] = e, --r || n(t) }), e) })) })) }, resolve: function (t) { if (t instanceof Pt) return t; if (t && \"function\" == typeof t.then) return new Pt((function (n, e) { t.then(n, e) })); var n = new Pt(ut, !0, t); return Mt(n, Et), n }, reject: zt, race: function () { var t = C.apply(null, arguments).map(nn); return new Pt((function (n, e) { t.map((function (t) { return Pt.resolve(t).then(n, e) })) })) }, PSD: { get: function () { return It }, set: function (t) { return It = t } }, newPSD: Xt, usePSD: un, scheduler: { get: function () { return mt }, set: function (t) { mt = t } }, rejectionMapper: { get: function () { return kt }, set: function (t) { kt = t } }, follow: function (t, n) { return new Pt((function (e, r) { return Xt((function (n, e) { var r = It; r.unhandleds = [], r.onunhandled = e, r.finalize = nt((function () { var t = this; jt.push((function r() { 0 === t.unhandleds.length ? n() : e(t.unhandleds[0]), jt.splice(jt.indexOf(r), 1) })), ++Rt, mt((function () { 0 == --Rt && Vt() }), []) }), r.finalize), t() }), n, e, r) })) } }); var $t = { awaits: 0, echoes: 0, id: 0 }, Gt = 0, Qt = [], Ht = 0, Jt = 0, Yt = 0; function Xt(t, n, e, r) { var i = It, o = Object.create(i); o.parent = i, o.ref = 0, o.global = !1, o.id = ++Yt; var u = Dt.env; o.env = vt ? { Promise: Pt, PromiseProp: { value: Pt, configurable: !0, writable: !0 }, all: Pt.all, race: Pt.race, resolve: Pt.resolve, reject: Pt.reject, nthen: cn(u.nthen, o), gthen: cn(u.gthen, o) } : {}, n && a(o, n), ++i.ref, o.finalize = function () { --this.parent.ref || this.parent.finalize() }; var s = un(o, t, e, r); return 0 === o.ref && o.finalize(), s } function Zt() { return $t.id || ($t.id = ++Gt), ++$t.awaits, $t.echoes += 7, $t.id } function tn(t) { !$t.awaits || t && t !== $t.id || (0 == --$t.awaits && ($t.id = 0), $t.echoes = 7 * $t.awaits) } function nn(t) { return $t.echoes && t && t.constructor === dt ? (Zt(), t.then((function (t) { return tn(), t }), (function (t) { return tn(), ln(t) }))) : t } function en(t) { ++Jt, $t.echoes && 0 != --$t.echoes || ($t.echoes = $t.id = 0), Qt.push(It), on(t, !0) } function rn() { var t = Qt[Qt.length - 1]; Qt.pop(), on(t, !1) } function on(t, n) { var e, r = It; if ((n ? !$t.echoes || Ht++ && t === It : !Ht || --Ht && t === It) || (e = n ? en.bind(null, t) : rn, lt.call(ct, e)), t !== It && (It = t, r === Dt && (Dt.env = an()), vt)) { var i = Dt.env.Promise, a = t.env; ft.then = a.nthen, i.prototype.then = a.gthen, (r.global || t.global) && (Object.defineProperty(o, \"Promise\", a.PromiseProp), i.all = a.all, i.race = a.race, i.resolve = a.resolve, i.reject = a.reject) } } function an() { var t = o.Promise; return vt ? { Promise: t, PromiseProp: Object.getOwnPropertyDescriptor(o, \"Promise\"), all: t.all, race: t.race, resolve: t.resolve, reject: t.reject, nthen: ft.then, gthen: t.prototype.then } : {} } function un(t, n, e, r, i) { var o = It; try { return on(t, !0), n(e, r, i) } finally { on(o, !1) } } function sn(t, n, e) { return \"function\" != typeof t ? t : function () { var r = It; e && Zt(), on(n, !0); try { return t.apply(this, arguments) } finally { on(r, !1) } } } function cn(t, n) { return function (e, r) { return t.call(this, sn(e, n, !1), sn(r, n, !1)) } } var fn = \"unhandledrejection\"; function hn(t, n) { var e; try { e = n.onuncatched(t) } catch (t) { } if (!1 !== e) try { var r, i = { promise: n, reason: t }; if (o.document && document.createEvent ? ((r = document.createEvent(\"Event\")).initEvent(fn, !0, !0), a(r, i)) : o.CustomEvent && a(r = new CustomEvent(fn, { detail: i }), i), r && o.dispatchEvent && (dispatchEvent(r), !o.PromiseRejectionEvent && o.onunhandledrejection)) try { o.onunhandledrejection(r) } catch (t) { } r.defaultPrevented || console.warn(\"Unhandled rejection: \" + (t.stack || t)) } catch (t) { } } var ln = Pt.reject; function dn(t) { var n = {}, e = function (e, r) { if (r) { for (var i = arguments.length, o = new Array(i - 1); --i;)o[i - 1] = arguments[i]; return n[e].subscribe.apply(null, o), t } if (\"string\" == typeof e) return n[e] }; e.addEventType = u; for (var o = 1, a = arguments.length; o < a; ++o)u(arguments[o]); return e; function u(t, r, i) { if (\"object\" == typeof t) return s(t); r || (r = ot), i || (i = X); var o = { subscribers: [], fire: i, subscribe: function (t) { -1 === o.subscribers.indexOf(t) && (o.subscribers.push(t), o.fire = r(o.fire, t)) }, unsubscribe: function (t) { o.subscribers = o.subscribers.filter((function (n) { return n !== t })), o.fire = o.subscribers.reduce(r, i) } }; return n[t] = e[t] = o, o } function s(t) { r(t).forEach((function (n) { var e = t[n]; if (i(e)) u(n, t[n][0], t[n][1]); else { if (\"asap\" !== e) throw new H.InvalidArgument(\"Invalid event config\"); var r = u(n, Z, (function () { for (var t = arguments.length, n = new Array(t); t--;)n[t] = arguments[t]; r.subscribers.forEach((function (t) { w((function () { t.apply(null, n) })) })) })) } })) } } var pn, vn = \"{version}\", gn = String.fromCharCode(65535), yn = function () { try { return IDBKeyRange.only([[]]), [[]] } catch (t) { return gn } }(), mn = -1 / 0, bn = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\", wn = \"String expected.\", _n = [], xn = \"undefined\" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent), En = xn, kn = xn, Dn = function (t) { return !/(dexie\\.js|dexie\\.min\\.js)/.test(t) }; function In(t, n) { var e, u, s, h, d, p = In.dependencies, v = a({ addons: In.addons, autoOpen: !0, indexedDB: p.indexedDB, IDBKeyRange: p.IDBKeyRange }, n), g = v.addons, w = v.autoOpen, I = v.indexedDB, R = v.IDBKeyRange, S = this._dbSchema = {}, A = [], B = [], F = {}, N = null, U = null, L = !1, V = null, z = !1, G = \"readonly\", Q = \"readwrite\", J = this, Y = new Pt((function (t) { e = t })), nt = new Pt((function (t, n) { u = n })), ot = !0, ut = !!Nn(I); function st(t) { this._cfg = { version: t, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null }, this.stores({}) } function ct(t, n, e, r) { var i = t.db.createObjectStore(n, e.keyPath ? { keyPath: e.keyPath, autoIncrement: e.auto } : { autoIncrement: e.auto }); return r.forEach((function (t) { ft(i, t) })), i } function ft(t, n) { t.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi }) } function ht(t, n, e) { if (z || It.letThrough) { var r = J._createTransaction(t, n, S); try { r.create() } catch (t) { return ln(t) } return r._promise(t, (function (t, n) { return Xt((function () { return It.trans = r, e(t, n, r) })) })).then((function (t) { return r._completion.then((function () { return t })) })) } if (!L) { if (!w) return ln(new H.DatabaseClosed); J.open().catch(X) } return Y.then((function () { return ht(t, n, e) })) } function lt(t, n, e) { var r = arguments.length; if (r < 2) throw new H.InvalidArgument(\"Too few arguments\"); for (var i = new Array(r - 1); --r;)i[r - 1] = arguments[r]; e = i.pop(); var o = O(i); return [t, o, e] } function vt(t, n, e) { this.name = t, this.schema = n, this._tx = e, this.hook = F[t] ? F[t].hook : dn(null, { creating: [et, X], reading: [tt, Z], updating: [it, X], deleting: [rt, X] }) } function gt(t, n, e) { return (e ? An : Pn)((function (e) { t.push(e), n && n() })) } function yt(t, n, e, r, i) { return new Pt((function (o, a) { var u = e.length, s = u - 1; if (0 === u) return o(); if (r) { var c, f = An(a), h = jn(null); x((function () { for (var r = 0; r < u; ++r) { c = { onsuccess: null, onerror: null }; var a = e[r]; i.call(c, a[0], a[1], n); var l = t.delete(a[0]); l._hookCtx = c, l.onerror = f, l.onsuccess = r === s ? jn(o) : h } }), (function (t) { throw c.onerror && c.onerror(t), t })) } else for (var l = 0; l < u; ++l) { var d = t.delete(e[l]); d.onerror = Pn(a), l === s && (d.onsuccess = Wt((function () { return o() }))) } })) } function mt(t, n, e, r) { var i = this; this.db = J, this.mode = t, this.storeNames = n, this.idbtrans = null, this.on = dn(this, \"complete\", \"error\", \"abort\"), this.parent = r || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Pt((function (t, n) { i._resolve = t, i._reject = n })), this._completion.then((function () { i.active = !1, i.on.complete.fire() }), (function (t) { var n = i.active; return i.active = !1, i.on.error.fire(t), i.parent ? i.parent._reject(t) : n && i.idbtrans && i.idbtrans.abort(), ln(t) })) } function bt(t, n, e) { this._ctx = { table: t, index: \":id\" === n ? null : n, or: e } } function wt(t, n) { var e = null, r = null; if (n) try { e = n() } catch (t) { r = t } var i = t._ctx, o = i.table; this._ctx = { table: o, index: i.index, isPrimKey: !i.index || o.schema.primKey.keyPath && i.index === o.schema.primKey.name, range: e, keysOnly: !1, dir: \"next\", unique: \"\", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: r, or: i.or, valueMapper: o.hook.reading.fire } } function _t(t, n) { return !(t.filter || t.algorithm || t.or) && (n ? t.justLimit : !t.replayFilter) } function xt(t, n) { return t._cfg.version - n._cfg.version } function Et(t, n, e) { n.forEach((function (n) { var r = e[n]; t.forEach((function (t) { n in t || (t === mt.prototype || t instanceof mt ? l(t, n, { get: function () { return this.table(n) } }) : t[n] = new vt(n, r)) })) })) } function kt(t, n, e, r, i, o) { var a = Wt(o ? function (t, n, r) { return e(o(t), n, r) } : e, i); t.onerror || (t.onerror = Pn(i)), t.onsuccess = function (t, n) { return function () { try { t.apply(this, arguments) } catch (t) { n(t) } } }(n ? function () { var e = t.result; if (e) { var o = function () { e.continue() }; n(e, (function (t) { o = t }), r, i) && a(e.value, e, (function (t) { o = t })), o() } else r() } : function () { var n = t.result; if (n) { var e = function () { n.continue() }; a(n.value, n, (function (t) { e = t })), e() } else r() }, i) } function Dt(t, n) { return I.cmp(t, n) } function Ot(t, n) { return Dt(t, n) > 0 ? t : n } function Rt(t, n) { return I.cmp(t, n) } function jt(t, n) { return I.cmp(n, t) } function St(t, n) { return t < n ? -1 : t === n ? 0 : 1 } function At(t, n) { return t > n ? -1 : t === n ? 0 : 1 } function Tt(t, n) { return t ? n ? function () { return t.apply(this, arguments) && n.apply(this, arguments) } : t : n } function Ct(t, n) { for (var e = n.db.objectStoreNames, r = 0; r < e.length; ++r) { var i = e[r], a = n.objectStore(i); s = \"getAll\" in a; for (var u = 0; u < a.indexNames.length; ++u) { var c = a.indexNames[u], f = a.index(c).keyPath, h = \"string\" == typeof f ? f : \"[\" + y(f).join(\"+\") + \"]\"; if (t[i]) { var l = t[i].idxByName[h]; l && (l.name = c) } } } /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (s = !1) } function Kt(t) { J.on(\"blocked\").fire(t), _n.filter((function (t) { return t.name === J.name && t !== J && !t._vcFired })).map((function (n) { return n.on(\"versionchange\").fire(t) })) } this.version = function (t) { if (N || L) throw new H.Schema(\"Cannot add version when database is open\"); this.verno = Math.max(this.verno, t); var n = A.filter((function (n) { return n._cfg.version === t }))[0]; return n || (n = new st(t), A.push(n), A.sort(xt), ot = !1, n) }, a(st.prototype, { stores: function (t) { this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, t) : t; var n = {}; A.forEach((function (t) { a(n, t._cfg.storesSource) })); var e = this._cfg.dbschema = {}; return this._parseStoresSpec(n, e), S = J._dbSchema = e, [F, J, mt.prototype].forEach((function (t) { for (var n in t) t[n] instanceof vt && delete t[n] })), Et([F, J, mt.prototype, this._cfg.tables], r(e), e), B = r(e), this }, upgrade: function (t) { return this._cfg.contentUpgrade = t, this }, _parseStoresSpec: function (t, n) { r(t).forEach((function (e) { if (null !== t[e]) { var r = {}, o = function (t) { var n = []; return t.split(\",\").forEach((function (t) { var e = (t = t.trim()).replace(/([&*]|\\+\\+)/g, \"\"), r = /^\\[/.test(e) ? e.match(/^\\[(.*)\\]$/)[1].split(\"+\") : e; n.push(new Kn(e, r || null, /\\&/.test(t), /\\*/.test(t), /\\+\\+/.test(t), i(r), /\\./.test(t))) })), n }(t[e]), a = o.shift(); if (a.multi) throw new H.Schema(\"Primary key cannot be multi-valued\"); a.keyPath && k(r, a.keyPath, a.auto ? 0 : a.keyPath), o.forEach((function (t) { if (t.auto) throw new H.Schema(\"Only primary key can be marked as autoIncrement (++)\"); if (!t.keyPath) throw new H.Schema(\"Index must have a name and cannot be an empty string\"); k(r, t.keyPath, t.compound ? t.keyPath.map((function () { return \"\" })) : \"\") })), n[e] = new Bn(e, a, o, r) } })) } }), this._allTables = F, this._createTransaction = function (t, n, e, r) { return new mt(t, n, e, r) }, this._whenReady = function (t) { return z || It.letThrough ? t() : new Pt((function (t, n) { if (!L) { if (!w) return void n(new H.DatabaseClosed); J.open().catch(X) } Y.then(t, n) })).then(t) }, this.verno = 0, this.open = function () { if (L || N) return Y.then((function () { return U ? ln(U) : J })); K && (nt._stackHolder = M()), L = !0, U = null, z = !1; var n = e, i = null; return Pt.race([nt, new Pt((function (n, e) { if (!I) throw new H.MissingAPI(\"indexedDB API not found. If using IE10+, make sure to run your code on a server URL (not locally). If using old Safari versions, make sure to include indexedDB polyfill.\"); var o = ot ? I.open(t) : I.open(t, Math.round(10 * J.verno)); if (!o) throw new H.MissingAPI(\"IndexedDB API not available\"); o.onerror = Pn(e), o.onblocked = Wt(Kt), o.onupgradeneeded = Wt((function (n) { if (i = o.transaction, ot && !J._allowEmptyDB) { o.onerror = Tn, i.abort(), o.result.close(); var a = I.deleteDatabase(t); a.onsuccess = a.onerror = Wt((function () { e(new H.NoSuchDatabase(\"Database \" + t + \" doesnt exist\")) })) } else i.onerror = Pn(e), function (t, n, e) { var i = J._createTransaction(Q, B, S); i.create(n), i._completion.catch(e); var o = i._reject.bind(i); Xt((function () { It.trans = i, 0 === t ? (r(S).forEach((function (t) { ct(n, t, S[t].primKey, S[t].indexes) })), Pt.follow((function () { return J.on.populate.fire(i) })).catch(o)) : function (t, n, e) { var i = [], o = A.filter((function (n) { return n._cfg.version === t }))[0]; if (!o) throw new H.Upgrade(\"Dexie specification of currently installed DB version is missing\"); S = J._dbSchema = o._cfg.dbschema; var a = !1; return A.filter((function (n) { return n._cfg.version > t })).forEach((function (t) { i.push((function () { var r = S, i = t._cfg.dbschema; Ct(r, e), Ct(i, e), S = J._dbSchema = i; var o = function (t, n) { var e = { del: [], add: [], change: [] }; for (var r in t) n[r] || e.del.push(r); for (r in n) { var i = t[r], o = n[r]; if (i) { var a = { name: r, def: o, recreate: !1, del: [], add: [], change: [] }; if (i.primKey.src !== o.primKey.src) a.recreate = !0, e.change.push(a); else { var u = i.idxByName, s = o.idxByName; for (var c in u) s[c] || a.del.push(c); for (c in s) { var f = u[c], h = s[c]; f ? f.src !== h.src && a.change.push(h) : a.add.push(h) } (a.del.length > 0 || a.add.length > 0 || a.change.length > 0) && e.change.push(a) } } else e.add.push([r, o]) } return e }(r, i); if (o.add.forEach((function (t) { ct(e, t[0], t[1].primKey, t[1].indexes) })), o.change.forEach((function (t) { if (t.recreate) throw new H.Upgrade(\"Not yet support for changing primary key\"); var n = e.objectStore(t.name); t.add.forEach((function (t) { ft(n, t) })), t.change.forEach((function (t) { n.deleteIndex(t.name), ft(n, t) })), t.del.forEach((function (t) { n.deleteIndex(t) })) })), t._cfg.contentUpgrade) return a = !0, Pt.follow((function () { t._cfg.contentUpgrade(n) })) })), i.push((function (n) { a && En || function (t, n) { for (var e = 0; e < n.db.objectStoreNames.length; ++e) { var r = n.db.objectStoreNames[e]; null == t[r] && n.db.deleteObjectStore(r) } }(t._cfg.dbschema, n) })) })), function t() { return i.length ? Pt.resolve(i.shift()(n.idbtrans)).then(t) : Pt.resolve() }().then((function () { !function (t, n) { r(t).forEach((function (e) { n.db.objectStoreNames.contains(e) || ct(n, e, t[e].primKey, t[e].indexes) })) }(S, e) })) }(t, i, n).catch(o) })) }((n.oldVersion > Math.pow(2, 62) ? 0 : n.oldVersion) / 10, i, e) }), e), o.onsuccess = Wt((function () { if (i = null, N = o.result, _n.push(J), ot) !function () { if (J.verno = N.version / 10, J._dbSchema = S = {}, 0 !== (B = y(N.objectStoreNames, 0)).length) { var t = N.transaction(Fn(B), \"readonly\"); B.forEach((function (n) { for (var e = t.objectStore(n), r = e.keyPath, i = r && \"string\" == typeof r && -1 !== r.indexOf(\".\"), o = new Kn(r, r || \"\", !1, !1, !!e.autoIncrement, r && \"string\" != typeof r, i), a = [], u = 0; u < e.indexNames.length; ++u) { var s = e.index(e.indexNames[u]); i = (r = s.keyPath) && \"string\" == typeof r && -1 !== r.indexOf(\".\"); var c = new Kn(s.name, r, !!s.unique, !!s.multiEntry, !1, r && \"string\" != typeof r, i); a.push(c) } S[n] = new Bn(n, o, a, {}) })), Et([F], r(S), S) } }(); else if (N.objectStoreNames.length > 0) try { Ct(S, N.transaction(Fn(N.objectStoreNames), G)) } catch (t) { } N.onversionchange = Wt((function (t) { J._vcFired = !0, J.on(\"versionchange\").fire(t) })), ut || \"__dbnames\" === t || pn.dbnames.put({ name: t }).catch(X), n() }), e) }))]).then((function () { return V = [], Pt.resolve(In.vip(J.on.ready.fire)).then((function t() { if (V.length > 0) { var n = V.reduce(at, X); return V = [], Pt.resolve(In.vip(n)).then(t) } })) })).finally((function () { V = null })).then((function () { return L = !1, J })).catch((function (t) { try { i && i.abort() } catch (t) { } return L = !1, J.close(), ln(U = t) })).finally((function () { z = !0, n() })) }, this.close = function () { var t = _n.indexOf(J); if (t >= 0 && _n.splice(t, 1), N) { try { N.close() } catch (t) { } N = null } w = !1, U = new H.DatabaseClosed, L && u(U), Y = new Pt((function (t) { e = t })), nt = new Pt((function (t, n) { u = n })) }, this.delete = function () { var n = arguments.length > 0; return new Pt((function (e, r) { if (n) throw new H.InvalidArgument(\"Arguments not allowed in db.delete()\"); function i() { J.close(); var n = I.deleteDatabase(t); n.onsuccess = Wt((function () { ut || pn.dbnames.delete(t).catch(X), e() })), n.onerror = Pn(r), n.onblocked = Kt } L ? Y.then(i) : i() })) }, this.backendDB = function () { return N }, this.isOpen = function () { return null !== N }, this.hasBeenClosed = function () { return U && U instanceof H.DatabaseClosed }, this.hasFailed = function () { return null !== U }, this.dynamicallyOpened = function () { return ot }, this.name = t, f(this, { tables: { get: function () { return r(F).map((function (t) { return F[t] })) } } }), this.on = dn(this, \"populate\", \"blocked\", \"versionchange\", { ready: [at, X] }), this.on.ready.subscribe = m(this.on.ready.subscribe, (function (t) { return function (n, e) { In.vip((function () { z ? (U || Pt.resolve().then(n), e && t(n)) : V ? (V.push(n), e && t(n)) : (t(n), e || t((function t() { J.on.ready.unsubscribe(n), J.on.ready.unsubscribe(t) }))) })) } })), this.transaction = function () { var t = lt.apply(this, arguments); return this._transaction.apply(this, t) }, this._transaction = function (t, n, e) { var r = It.trans; r && r.db === J && -1 === t.indexOf(\"!\") || (r = null); var i = -1 !== t.indexOf(\"?\"); t = t.replace(\"!\", \"\").replace(\"?\", \"\"); try { var o = n.map((function (t) { var n = t instanceof vt ? t.name : t; if (\"string\" != typeof n) throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\"); return n })); if (\"r\" == t || t == G) t = G; else { if (\"rw\" != t && t != Q) throw new H.InvalidArgument(\"Invalid transaction mode: \" + t); t = Q } if (r) { if (r.mode === G && t === Q) { if (!i) throw new H.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\"); r = null } r && o.forEach((function (t) { if (r && -1 === r.storeNames.indexOf(t)) { if (!i) throw new H.SubTransaction(\"Table \" + t + \" not included in parent transaction.\"); r = null } })), i && r && !r.active && (r = null) } } catch (t) { return r ? r._promise(null, (function (n, e) { e(t) })) : ln(t) } return r ? r._promise(t, a, \"lock\") : It.trans ? un(It.transless, (function () { return J._whenReady(a) })) : J._whenReady(a); function a() { return Pt.resolve().then((function () { var n, i = It.transless || It, a = J._createTransaction(t, o, S, r), u = { trans: a, transless: i }; r ? a.idbtrans = r.idbtrans : a.create(), e.constructor === pt && Zt(); var s = Pt.follow((function () { if (n = e.call(a, a)) if (n.constructor === dt) { var t = tn.bind(null, null); n.then(t, t) } else \"function\" == typeof n.next && \"function\" == typeof n.throw && (n = Cn(n)) }), u); return (n && \"function\" == typeof n.then ? Pt.resolve(n).then((function (t) { return a.active ? t : ln(new H.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")) })) : s.then((function () { return n }))).then((function (t) { return r && a._resolve(), a._completion.then((function () { return t })) })).catch((function (t) { return a._reject(t), ln(t) })) })) } }, this.table = function (t) { if (!c(F, t)) throw new H.InvalidTable(\"Table \" + t + \" does not exist\"); return F[t] }, f(vt.prototype, { _trans: function (t, n, e) { var r = this._tx || It.trans; return r && r.db === J ? r === It.trans ? r._promise(t, n, e) : Xt((function () { return r._promise(t, n, e) }), { trans: r, transless: It.transless || It }) : ht(t, [this.name], n) }, _idbstore: function (t, n, e) { var r = this.name; return this._trans(t, (function (t, e, i) { if (-1 === i.storeNames.indexOf(r)) throw new H.NotFound(\"Table\" + r + \" not part of transaction\"); return n(t, e, i.idbtrans.objectStore(r), i) }), e) }, get: function (t, n) { if (t && t.constructor === Object) return this.where(t).first(n); var e = this; return this._idbstore(G, (function (n, r, i) { var o = i.get(t); o.onerror = Pn(r), o.onsuccess = Wt((function () { n(e.hook.reading.fire(o.result)) }), r) })).then(n) }, where: function (t) { if (\"string\" == typeof t) return new bt(this, t); if (i(t)) return new bt(this, \"[\" + t.join(\"+\") + \"]\"); var n = r(t); if (1 === n.length) return this.where(n[0]).equals(t[n[0]]); var e = this.schema.indexes.concat(this.schema.primKey).filter((function (t) { return t.compound && n.every((function (n) { return t.keyPath.indexOf(n) >= 0 })) && t.keyPath.every((function (t) { return n.indexOf(t) >= 0 })) }))[0]; if (e && yn !== gn) return this.where(e.name).equals(e.keyPath.map((function (n) { return t[n] }))); e || console.warn(\"The query \" + JSON.stringify(t) + \" on \" + this.name + \" would benefit of a compound index [\" + n.join(\"+\") + \"]\"); var o = this.schema.idxByName, a = n.reduce((function (n, e) { return [n[0] || o[e], n[0] || !o[e] ? Tt(n[1], (function (n) { return \"\" + E(n, e) == \"\" + t[e] })) : n[1]] }), [null, null]), u = a[0]; return u ? this.where(u.name).equals(t[u.keyPath]).filter(a[1]) : e ? this.filter(a[1]) : this.where(n).equals(\"\") }, count: function (t) { return this.toCollection().count(t) }, offset: function (t) { return this.toCollection().offset(t) }, limit: function (t) { return this.toCollection().limit(t) }, reverse: function () { return this.toCollection().reverse() }, filter: function (t) { return this.toCollection().and(t) }, each: function (t) { return this.toCollection().each(t) }, toArray: function (t) { return this.toCollection().toArray(t) }, orderBy: function (t) { return new wt(new bt(this, i(t) ? \"[\" + t.join(\"+\") + \"]\" : t)) }, toCollection: function () { return new wt(new bt(this)) }, mapToClass: function (t, n) { this.schema.mappedClass = t; var e = Object.create(t.prototype); n && Rn(e, n), this.schema.instanceTemplate = e; var r = function (n) { if (!n) return n; var e = Object.create(t.prototype); for (var r in n) if (c(n, r)) try { e[r] = n[r] } catch (t) { } return e }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook(\"reading\", r), t }, defineClass: function (t) { return this.mapToClass(In.defineClass(t), t) }, bulkDelete: function (t) { return this.hook.deleting.fire === X ? this._idbstore(Q, (function (n, e, r, i) { n(yt(r, i, t, !1, X)) })) : this.where(\":id\").anyOf(t).delete().then((function () { })) }, bulkPut: function (t, n) { var e = this; return this._idbstore(Q, (function (r, i, o) { if (!o.keyPath && !e.schema.primKey.auto && !n) throw new H.InvalidArgument(\"bulkPut() with non-inbound keys requires keys array in second argument\"); if (o.keyPath && n) throw new H.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\"); if (n && n.length !== t.length) throw new H.InvalidArgument(\"Arguments objects and keys must have the same length\"); if (0 === t.length) return r(); var a, u, s = function (t) { 0 === c.length ? r(t) : i(new $(e.name + \".bulkPut(): \" + c.length + \" of \" + f + \" operations failed\", c)) }, c = [], f = t.length, h = e; if (e.hook.creating.fire === X && e.hook.updating.fire === X) { u = gt(c); for (var l = 0, d = t.length; l < d; ++l)(a = n ? o.put(t[l], n[l]) : o.put(t[l])).onerror = u; a.onerror = gt(c, s), a.onsuccess = Sn(s) } else { var p = n || o.keyPath && t.map((function (t) { return E(t, o.keyPath) })), v = p && _(p, (function (n, e) { return null != n && [n, t[e]] })), g = p ? h.where(\":id\").anyOf(p.filter((function (t) { return null != t }))).modify((function () { this.value = v[this.primKey], v[this.primKey] = null })).catch(W, (function (t) { c = t.failures })).then((function () { for (var e = [], r = n && [], i = p.length - 1; i >= 0; --i) { var o = p[i]; (null == o || v[o]) && (e.push(t[i]), n && r.push(o), null != o && (v[o] = null)) } return e.reverse(), n && r.reverse(), h.bulkAdd(e, r) })).then((function (t) { var n = p[p.length - 1]; return null != n ? n : t })) : h.bulkAdd(t); g.then(s).catch($, (function (t) { c = c.concat(t.failures), s() })).catch(i) } }), \"locked\") }, bulkAdd: function (t, n) { var e = this, r = this.hook.creating.fire; return this._idbstore(Q, (function (i, o, a, u) { if (!a.keyPath && !e.schema.primKey.auto && !n) throw new H.InvalidArgument(\"bulkAdd() with non-inbound keys requires keys array in second argument\"); if (a.keyPath && n) throw new H.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\"); if (n && n.length !== t.length) throw new H.InvalidArgument(\"Arguments objects and keys must have the same length\"); if (0 === t.length) return i(); function s(t) { 0 === l.length ? i(t) : o(new $(e.name + \".bulkAdd(): \" + l.length + \" of \" + d + \" operations failed\", l)) } var c, f, h, l = [], d = t.length; if (r !== X) { var p, v = a.keyPath; f = gt(l, null, !0), h = jn(null), x((function () { for (var e = 0, i = t.length; e < i; ++e) { p = { onerror: null, onsuccess: null }; var o = n && n[e], s = t[e], l = n ? o : v ? E(s, v) : void 0, d = r.call(p, l, s, u); null == l && null != d && (v ? k(s = j(s), v, d) : o = d), (c = null != o ? a.add(s, o) : a.add(s))._hookCtx = p, e < i - 1 && (c.onerror = f, p.onsuccess && (c.onsuccess = h)) } }), (function (t) { throw p.onerror && p.onerror(t), t })), c.onerror = gt(l, s, !0), c.onsuccess = jn(s) } else { f = gt(l); for (var g = 0, y = t.length; g < y; ++g)(c = n ? a.add(t[g], n[g]) : a.add(t[g])).onerror = f; c.onerror = gt(l, s), c.onsuccess = Sn(s) } })) }, add: function (t, n) { var e = this.hook.creating.fire; return this._idbstore(Q, (function (r, i, o, a) { var u = { onsuccess: null, onerror: null }; if (e !== X) { var s = null != n ? n : o.keyPath ? E(t, o.keyPath) : void 0, c = e.call(u, s, t, a); null == s && null != c && (o.keyPath ? k(t, o.keyPath, c) : n = c) } try { var f = null != n ? o.add(t, n) : o.add(t); f._hookCtx = u, f.onerror = An(i), f.onsuccess = jn((function (n) { var e = o.keyPath; e && k(t, e, n), r(n) })) } catch (t) { throw u.onerror && u.onerror(t), t } })) }, put: function (t, n) { var e = this, r = this.hook.creating.fire, i = this.hook.updating.fire; if (r !== X || i !== X) { var o = this.schema.primKey.keyPath, a = void 0 !== n ? n : o && E(t, o); return null == a ? this.add(t) : (t = j(t), this._trans(Q, (function () { return e.where(\":id\").equals(a).modify((function () { this.value = t })).then((function (r) { return 0 === r ? e.add(t, n) : a })) }), \"locked\")) } return this._idbstore(Q, (function (e, r, i) { var o = void 0 !== n ? i.put(t, n) : i.put(t); o.onerror = Pn(r), o.onsuccess = Wt((function (n) { var r = i.keyPath; r && k(t, r, n.target.result), e(o.result) })) })) }, delete: function (t) { return this.hook.deleting.subscribers.length ? this.where(\":id\").equals(t).delete() : this._idbstore(Q, (function (n, e, r) { var i = r.delete(t); i.onerror = Pn(e), i.onsuccess = Wt((function () { n(i.result) })) })) }, clear: function () { return this.hook.deleting.subscribers.length ? this.toCollection().delete() : this._idbstore(Q, (function (t, n, e) { var r = e.clear(); r.onerror = Pn(n), r.onsuccess = Wt((function () { t(r.result) })) })) }, update: function (t, n) { if (\"object\" != typeof n || i(n)) throw new H.InvalidArgument(\"Modifications must be an object.\"); if (\"object\" != typeof t || i(t)) return this.where(\":id\").equals(t).modify(n); r(n).forEach((function (e) { k(t, e, n[e]) })); var e = E(t, this.schema.primKey.keyPath); return void 0 === e ? ln(new H.InvalidArgument(\"Given object does not contain its primary key\")) : this.where(\":id\").equals(e).modify(n) } }), f(mt.prototype, { _lock: function () { return b(!It.global), ++this._reculock, 1 !== this._reculock || It.global || (It.lockOwnerFor = this), this }, _unlock: function () { if (b(!It.global), 0 == --this._reculock) for (It.global || (It.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { un(t[1], t[0]) } catch (t) { } } return this }, _locked: function () { return this._reculock && It.lockOwnerFor !== this }, create: function (t) { var n = this; if (!this.mode) return this; if (b(!this.idbtrans), !t && !N) switch (U && U.name) { case \"DatabaseClosedError\": throw new H.DatabaseClosed(U); case \"MissingAPIError\": throw new H.MissingAPI(U.message, U); default: throw new H.OpenFailed(U) }if (!this.active) throw new H.TransactionInactive; return b(null === this._completion._state), (t = this.idbtrans = t || N.transaction(Fn(this.storeNames), this.mode)).onerror = Wt((function (e) { Tn(e), n._reject(t.error) })), t.onabort = Wt((function (e) { Tn(e), n.active && n._reject(new H.Abort(t.error)), n.active = !1, n.on(\"abort\").fire(e) })), t.oncomplete = Wt((function () { n.active = !1, n._resolve() })), this }, _promise: function (t, n, e) { var r = this; if (t === Q && this.mode !== Q) return ln(new H.ReadOnly(\"Transaction is readonly\")); if (!this.active) return ln(new H.TransactionInactive); if (this._locked()) return new Pt((function (i, o) { r._blockedFuncs.push([function () { r._promise(t, n, e).then(i, o) }, It]) })); if (e) return Xt((function () { var t = new Pt((function (t, e) { r._lock(); var i = n(t, e, r); i && i.then && i.then(t, e) })); return t.finally((function () { return r._unlock() })), t._lib = !0, t })); var i = new Pt((function (t, e) { var i = n(t, e, r); i && i.then && i.then(t, e) })); return i._lib = !0, i }, _root: function () { return this.parent ? this.parent._root() : this }, waitFor: function (t) { var n = this._root(); if (t = Pt.resolve(t), n._waitingFor) n._waitingFor = n._waitingFor.then((function () { return t })); else { n._waitingFor = t, n._waitingQueue = []; var e = n.idbtrans.objectStore(n.storeNames[0]); !function t() { for (++n._spinCount; n._waitingQueue.length;)n._waitingQueue.shift()(); n._waitingFor && (e.get(-1 / 0).onsuccess = t) }() } var r = n._waitingFor; return new Pt((function (e, i) { t.then((function (t) { return n._waitingQueue.push(Wt(e.bind(null, t))) }), (function (t) { return n._waitingQueue.push(Wt(i.bind(null, t))) })).finally((function () { n._waitingFor === r && (n._waitingFor = null) })) })) }, abort: function () { this.active && this._reject(new H.Abort), this.active = !1 }, tables: { get: (h = \"Transaction.tables\", d = function () { return F }, function () { return console.warn(h + \" is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. \" + q(M(), 1)), d.apply(this, arguments) }) }, table: function (t) { return new vt(t, J.table(t).schema, this) } }), f(bt.prototype, (function () { function t(t, n, e) { var r = t instanceof bt ? new wt(t) : t; return r._ctx.error = e ? new e(n) : new TypeError(n), r } function n(t) { return new wt(t, (function () { return R.only(\"\") })).limit(0) } function e(t, n, e, r, i, o) { for (var a = Math.min(t.length, r.length), u = -1, s = 0; s < a; ++s) { var c = n[s]; if (c !== r[s]) return i(t[s], e[s]) < 0 ? t.substr(0, s) + e[s] + e.substr(s + 1) : i(t[s], r[s]) < 0 ? t.substr(0, s) + r[s] + e.substr(s + 1) : u >= 0 ? t.substr(0, u) + n[u] + e.substr(u + 1) : null; i(t[s], c) < 0 && (u = s) } return a < r.length && \"next\" === o ? t + e.substr(t.length) : a < t.length && \"prev\" === o ? t.substr(0, e.length) : u < 0 ? null : t.substr(0, u) + r[u] + e.substr(u + 1) } function r(n, r, i, o) { var a, u, s, c, f, h, l, d = i.length; if (!i.every((function (t) { return \"string\" == typeof t }))) return t(n, wn); function p(t) { a = function (t) { return \"next\" === t ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } }(t), u = function (t) { return \"next\" === t ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } }(t), s = \"next\" === t ? St : At; var n = i.map((function (t) { return { lower: u(t), upper: a(t) } })).sort((function (t, n) { return s(t.lower, n.lower) })); c = n.map((function (t) { return t.upper })), f = n.map((function (t) { return t.lower })), h = t, l = \"next\" === t ? \"\" : o } p(\"next\"); var v = new wt(n, (function () { return R.bound(c[0], f[d - 1] + o) })); v._ondirectionchange = function (t) { p(t) }; var g = 0; return v._addAlgorithm((function (t, n, i) { var o = t.key; if (\"string\" != typeof o) return !1; var a = u(o); if (r(a, f, g)) return !0; for (var p = null, v = g; v < d; ++v) { var y = e(o, a, c[v], f[v], s, h); null === y && null === p ? g = v + 1 : (null === p || s(p, y) > 0) && (p = y) } return n(null !== p ? function () { t.continue(p + l) } : i), !1 })), v } return { between: function (e, r, i, o) { i = !1 !== i, o = !0 === o; try { return Dt(e, r) > 0 || 0 === Dt(e, r) && (i || o) && (!i || !o) ? n(this) : new wt(this, (function () { return R.bound(e, r, !i, !o) })) } catch (n) { return t(this, bn) } }, equals: function (t) { return new wt(this, (function () { return R.only(t) })) }, above: function (t) { return new wt(this, (function () { return R.lowerBound(t, !0) })) }, aboveOrEqual: function (t) { return new wt(this, (function () { return R.lowerBound(t) })) }, below: function (t) { return new wt(this, (function () { return R.upperBound(t, !0) })) }, belowOrEqual: function (t) { return new wt(this, (function () { return R.upperBound(t) })) }, startsWith: function (n) { return \"string\" != typeof n ? t(this, wn) : this.between(n, n + gn, !0, !0) }, startsWithIgnoreCase: function (t) { return \"\" === t ? this.startsWith(t) : r(this, (function (t, n) { return 0 === t.indexOf(n[0]) }), [t], gn) }, equalsIgnoreCase: function (t) { return r(this, (function (t, n) { return t === n[0] }), [t], \"\") }, anyOfIgnoreCase: function () { var t = C.apply(T, arguments); return 0 === t.length ? n(this) : r(this, (function (t, n) { return -1 !== n.indexOf(t) }), t, \"\") }, startsWithAnyOfIgnoreCase: function () { var t = C.apply(T, arguments); return 0 === t.length ? n(this) : r(this, (function (t, n) { return n.some((function (n) { return 0 === t.indexOf(n) })) }), t, gn) }, anyOf: function () { var e = C.apply(T, arguments), r = Rt; try { e.sort(r) } catch (n) { return t(this, bn) } if (0 === e.length) return n(this); var i = new wt(this, (function () { return R.bound(e[0], e[e.length - 1]) })); i._ondirectionchange = function (t) { r = \"next\" === t ? Rt : jt, e.sort(r) }; var o = 0; return i._addAlgorithm((function (t, n, i) { for (var a = t.key; r(a, e[o]) > 0;)if (++o === e.length) return n(i), !1; return 0 === r(a, e[o]) || (n((function () { t.continue(e[o]) })), !1) })), i }, notEqual: function (t) { return this.inAnyRange([[mn, t], [t, yn]], { includeLowers: !1, includeUppers: !1 }) }, noneOf: function () { var n = C.apply(T, arguments); if (0 === n.length) return new wt(this); try { n.sort(Rt) } catch (n) { return t(this, bn) } var e = n.reduce((function (t, n) { return t ? t.concat([[t[t.length - 1][1], n]]) : [[mn, n]] }), null); return e.push([n[n.length - 1], yn]), this.inAnyRange(e, { includeLowers: !1, includeUppers: !1 }) }, inAnyRange: function (e, r) { if (0 === e.length) return n(this); if (!e.every((function (t) { return void 0 !== t[0] && void 0 !== t[1] && Rt(t[0], t[1]) <= 0 }))) return t(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", H.InvalidArgument); var i, o = !r || !1 !== r.includeLowers, a = r && !0 === r.includeUppers, u = Rt; function s(t, n) { return u(t[0], n[0]) } try { i = e.reduce((function (t, n) { for (var e = 0, r = t.length; e < r; ++e) { var i = t[e]; if (Dt(n[0], i[1]) < 0 && Dt(n[1], i[0]) > 0) { i[0] = Dt(o = i[0], a = n[0]) < 0 ? o : a, i[1] = Ot(i[1], n[1]); break } } var o, a; return e === r && t.push(n), t }), []), i.sort(s) } catch (n) { return t(this, bn) } var c = 0, f = a ? function (t) { return Rt(t, i[c][1]) > 0 } : function (t) { return Rt(t, i[c][1]) >= 0 }, h = o ? function (t) { return jt(t, i[c][0]) > 0 } : function (t) { return jt(t, i[c][0]) >= 0 }, l = f, d = new wt(this, (function () { return R.bound(i[0][0], i[i.length - 1][1], !o, !a) })); return d._ondirectionchange = function (t) { \"next\" === t ? (l = f, u = Rt) : (l = h, u = jt), i.sort(s) }, d._addAlgorithm((function (t, n, e) { for (var r = t.key; l(r);)if (++c === i.length) return n(e), !1; return !!function (t) { return !f(t) && !h(t) }(r) || (0 === Dt(r, i[c][1]) || 0 === Dt(r, i[c][0]) || n((function () { u === Rt ? t.continue(i[c][0]) : t.continue(i[c][1]) })), !1) })), d }, startsWithAnyOf: function () { var e = C.apply(T, arguments); return e.every((function (t) { return \"string\" == typeof t })) ? 0 === e.length ? n(this) : this.inAnyRange(e.map((function (t) { return [t, t + gn] }))) : t(this, \"startsWithAnyOf() only works with strings\") } } })), f(wt.prototype, (function () { function t(t, n) { t.filter = Tt(t.filter, n) } function n(t, n, e) { var r = t.replayFilter; t.replayFilter = r ? function () { return Tt(r(), n()) } : n, t.justLimit = e && !r } function e(t, n) { if (t.isPrimKey) return n; var e = t.table.schema.idxByName[t.index]; if (!e) throw new H.Schema(\"KeyPath \" + t.index + \" on object store \" + n.name + \" is not indexed\"); return n.index(e.name) } function i(t, n) { var r = e(t, n); return t.keysOnly && \"openKeyCursor\" in r ? r.openKeyCursor(t.range || null, t.dir + t.unique) : r.openCursor(t.range || null, t.dir + t.unique) } function o(t, n, e, r, o) { var a = t.replayFilter ? Tt(t.filter, t.replayFilter()) : t.filter; t.or ? function () { var u = {}, s = 0; function f() { 2 == ++s && e() } function h(t, e, i) { if (!a || a(e, i, f, r)) { var o = e.primaryKey, s = \"\" + o; \"[object ArrayBuffer]\" === s && (s = \"\" + new Uint8Array(o)), c(u, s) || (u[s] = !0, n(t, e, i)) } } t.or._iterate(h, f, r, o), kt(i(t, o), t.algorithm, h, f, r, !t.keysOnly && t.valueMapper) }() : kt(i(t, o), Tt(t.algorithm, a), n, e, r, !t.keysOnly && t.valueMapper) } return { _read: function (t, n) { var e = this._ctx; return e.error ? e.table._trans(null, ln.bind(null, e.error)) : e.table._idbstore(G, t).then(n) }, _write: function (t) { var n = this._ctx; return n.error ? n.table._trans(null, ln.bind(null, n.error)) : n.table._idbstore(Q, t, \"locked\") }, _addAlgorithm: function (t) { var n = this._ctx; n.algorithm = Tt(n.algorithm, t) }, _iterate: function (t, n, e, r) { return o(this._ctx, t, n, e, r) }, clone: function (t) { var n = Object.create(this.constructor.prototype), e = Object.create(this._ctx); return t && a(e, t), n._ctx = e, n }, raw: function () { return this._ctx.valueMapper = null, this }, each: function (t) { var n = this._ctx; return this._read((function (e, r, i) { o(n, t, e, r, i) })) }, count: function (t) { var n = this._ctx; if (_t(n, !0)) return this._read((function (t, r, i) { var o = e(n, i), a = n.range ? o.count(n.range) : o.count(); a.onerror = Pn(r), a.onsuccess = function (e) { t(Math.min(e.target.result, n.limit)) } }), t); var r = 0; return this._read((function (t, e, i) { o(n, (function () { return ++r, !1 }), (function () { t(r) }), e, i) }), t) }, sortBy: function (t, n) { var e = t.split(\".\").reverse(), r = e[0], i = e.length - 1; function o(t, n) { return n ? o(t[e[n]], n - 1) : t[r] } var a = \"next\" === this._ctx.dir ? 1 : -1; function u(t, n) { var e = o(t, i), r = o(n, i); return e < r ? -a : e > r ? a : 0 } return this.toArray((function (t) { return t.sort(u) })).then(n) }, toArray: function (t) { var n = this._ctx; return this._read((function (t, r, i) { if (s && \"next\" === n.dir && _t(n, !0) && n.limit > 0) { var a = n.table.hook.reading.fire, u = e(n, i), c = n.limit < 1 / 0 ? u.getAll(n.range, n.limit) : u.getAll(n.range); c.onerror = Pn(r), c.onsuccess = Sn(a === Z ? t : function (n) { try { t(n.map(a)) } catch (t) { r(t) } }) } else { var f = []; o(n, (function (t) { f.push(t) }), (function () { t(f) }), r, i) } }), t) }, offset: function (t) { var e = this._ctx; return t <= 0 || (e.offset += t, _t(e) ? n(e, (function () { var n = t; return function (t, e) { return 0 === n || (1 === n ? (--n, !1) : (e((function () { t.advance(n), n = 0 })), !1)) } })) : n(e, (function () { var n = t; return function () { return --n < 0 } }))), this }, limit: function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), n(this._ctx, (function () { var n = t; return function (t, e, r) { return --n <= 0 && e(r), n >= 0 } }), !0), this }, until: function (n, e) { return t(this._ctx, (function (t, r, i) { return !n(t.value) || (r(i), e) })), this }, first: function (t) { return this.limit(1).toArray((function (t) { return t[0] })).then(t) }, last: function (t) { return this.reverse().first(t) }, filter: function (n) { return t(this._ctx, (function (t) { return n(t.value) })), function (t, n) { t.isMatch = Tt(t.isMatch, n) }(this._ctx, n), this }, and: function (t) { return this.filter(t) }, or: function (t) { return new bt(this._ctx.table, t, this) }, reverse: function () { return this._ctx.dir = \"prev\" === this._ctx.dir ? \"next\" : \"prev\", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, desc: function () { return this.reverse() }, eachKey: function (t) { var n = this._ctx; return n.keysOnly = !n.isMatch, this.each((function (n, e) { t(e.key, e) })) }, eachUniqueKey: function (t) { return this._ctx.unique = \"unique\", this.eachKey(t) }, eachPrimaryKey: function (t) { var n = this._ctx; return n.keysOnly = !n.isMatch, this.each((function (n, e) { t(e.primaryKey, e) })) }, keys: function (t) { var n = this._ctx; n.keysOnly = !n.isMatch; var e = []; return this.each((function (t, n) { e.push(n.key) })).then((function () { return e })).then(t) }, primaryKeys: function (t) { var n = this._ctx; if (s && \"next\" === n.dir && _t(n, !0) && n.limit > 0) return this._read((function (t, r, i) { var o = e(n, i), a = n.limit < 1 / 0 ? o.getAllKeys(n.range, n.limit) : o.getAllKeys(n.range); a.onerror = Pn(r), a.onsuccess = Sn(t) })).then(t); n.keysOnly = !n.isMatch; var r = []; return this.each((function (t, n) { r.push(n.primaryKey) })).then((function () { return r })).then(t) }, uniqueKeys: function (t) { return this._ctx.unique = \"unique\", this.keys(t) }, firstKey: function (t) { return this.limit(1).keys((function (t) { return t[0] })).then(t) }, lastKey: function (t) { return this.reverse().firstKey(t) }, distinct: function () { var n = this._ctx, e = n.index && n.table.schema.idxByName[n.index]; if (!e || !e.multi) return this; var r = {}; return t(this._ctx, (function (t) { var n = t.primaryKey.toString(), e = c(r, n); return r[n] = !0, !e })), this }, modify: function (t) { var n = this, e = this._ctx.table.hook, i = e.updating.fire, o = e.deleting.fire; return this._write((function (e, u, s, f) { var h; if (\"function\" == typeof t) h = i === X && o === X ? t : function (n) { var e = j(n); if (!1 === t.call(this, n, this)) return !1; if (c(this, \"value\")) { var a = P(e, this.value), u = i.call(this, a, this.primKey, e, f); u && (n = this.value, r(u).forEach((function (t) { k(n, t, u[t]) }))) } else o.call(this, this.primKey, n, f) }; else if (i === X) { var l = r(t), d = l.length; h = function (n) { for (var e = !1, r = 0; r < d; ++r) { var i = l[r], o = t[i]; E(n, i) !== o && (k(n, i, o), e = !0) } return e } } else { var p = t; t = D(p), h = function (n) { var e = !1, o = i.call(this, t, this.primKey, j(n), f); return o && a(t, o), r(t).forEach((function (r) { var i = t[r]; E(n, r) !== i && (k(n, r, i), e = !0) })), o && (t = D(p)), e } } var v = 0, g = 0, y = !1, m = [], b = [], w = null; function _(t) { return t && (m.push(t), b.push(w)), u(new W(\"Error modifying one or more objects\", m, g, b)) } function I() { y && g + m.length === v && (m.length > 0 ? _() : e(g)) } n.clone().raw()._iterate((function (t, n) { w = n.primaryKey; var e = { primKey: n.primaryKey, value: t, onsuccess: null, onerror: null }; function r(t) { return m.push(t), b.push(e.primKey), I(), !0 } if (!1 !== h.call(e, t, e)) { var i = !c(e, \"value\"); ++v, x((function () { var t = i ? n.delete() : n.update(e.value); t._hookCtx = e, t.onerror = An(r), t.onsuccess = jn((function () { ++g, I() })) }), r) } else e.onsuccess && e.onsuccess(e.value) }), (function () { y = !0, I() }), _, s) })) }, delete: function () { var t = this, n = this._ctx, e = n.range, r = n.table.hook.deleting.fire, i = r !== X; if (!i && _t(n) && (n.isPrimKey && !kn || !e)) return this._write((function (t, n, r) { var i = Pn(n), o = e ? r.count(e) : r.count(); o.onerror = i, o.onsuccess = function () { var a = o.result; x((function () { var n = e ? r.delete(e) : r.clear(); n.onerror = i, n.onsuccess = function () { return t(a) } }), (function (t) { return n(t) })) } })); var o = i ? 2e3 : 1e4; return this._write((function (e, a, u, s) { var c = 0, f = t.clone({ keysOnly: !n.isMatch && !i }).distinct().limit(o).raw(), h = [], l = function () { return f.each(i ? function (t, n) { h.push([n.primaryKey, n.value]) } : function (t, n) { h.push(n.primaryKey) }).then((function () { return i ? h.sort((function (t, n) { return Rt(t[0], n[0]) })) : h.sort(Rt), yt(u, s, h, i, r) })).then((function () { var t = h.length; return c += t, h = [], t < o ? c : l() })) }; e(l()) })) } } })), a(this, { Collection: wt, Table: vt, Transaction: mt, Version: st, WhereClause: bt }), J.on(\"versionchange\", (function (t) { t.newVersion > 0 ? console.warn(\"Another connection wants to upgrade database '\" + J.name + \"'. Closing db now to resume the upgrade.\") : console.warn(\"Another connection wants to delete database '\" + J.name + \"'. Closing db now to resume the delete request.\"), J.close() })), J.on(\"blocked\", (function (t) { !t.newVersion || t.newVersion < t.oldVersion ? console.warn(\"Dexie.delete('\" + J.name + \"') was blocked\") : console.warn(\"Upgrade '\" + J.name + \"' blocked by other connection holding version \" + t.oldVersion / 10) })), g.forEach((function (t) { t(J) })) } function On(t) { if (\"function\" == typeof t) return new t; if (i(t)) return [On(t[0])]; if (t && \"object\" == typeof t) { var n = {}; return Rn(n, t), n } return t } function Rn(t, n) { return r(n).forEach((function (e) { var r = On(n[e]); t[e] = r })), t } function jn(t) { return Wt((function (n) { var e = n.target, r = e._hookCtx, i = r.value || e.result, o = r && r.onsuccess; o && o(i), t && t(i) }), t) } function Pn(t) { return Wt((function (n) { return Tn(n), t(n.target.error), !1 })) } function Sn(t) { return Wt((function (n) { t(n.target.result) })) } function An(t) { return Wt((function (n) { var e = n.target, r = e.error, i = e._hookCtx, o = i && i.onerror; return o && o(r), Tn(n), t(r), !1 })) } function Tn(t) { t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault() } function Cn(t) { var n = function (n) { return t.next(n) }, e = o(n), r = o((function (n) { return t.throw(n) })); function o(t) { return function (n) { var o = t(n), a = o.value; return o.done ? a : a && \"function\" == typeof a.then ? a.then(e, r) : i(a) ? Pt.all(a).then(e, r) : e(a) } } return o(n)() } function Kn(t, n, e, r, i, o, a) { this.name = t, this.keyPath = n, this.unique = e, this.multi = r, this.auto = i, this.compound = o, this.dotted = a; var u = \"string\" == typeof n ? n : n && \"[\" + [].join.call(n, \"+\") + \"]\"; this.src = (e ? \"&\" : \"\") + (r ? \"*\" : \"\") + (i ? \"++\" : \"\") + u } function Bn(t, n, e, r) { this.name = t, this.primKey = n || new Kn, this.indexes = e || [new Kn], this.instanceTemplate = r, this.mappedClass = null, this.idxByName = _(e, (function (t) { return [t.name, t] })) } function Fn(t) { return 1 === t.length ? t[0] : t } function Nn(t) { var n = t && (t.getDatabaseNames || t.webkitGetDatabaseNames); return n && n.bind(t) } B(K, Dn), f(In, Y), f(In, { delete: function (t) { var n = new In(t), e = n.delete(); return e.onblocked = function (t) { return n.on(\"blocked\", t), this }, e }, exists: function (t) { return new In(t).open().then((function (t) { return t.close(), !0 })).catch(In.NoSuchDatabaseError, (function () { return !1 })) }, getDatabaseNames: function (t) { var n = Nn(In.dependencies.indexedDB); return n ? new Pt((function (t, e) { var r = n(); r.onsuccess = function (n) { t(y(n.target.result, 0)) }, r.onerror = Pn(e) })).then(t) : pn.dbnames.toCollection().primaryKeys(t) }, defineClass: function () { return function (t) { t && a(this, t) } }, applyStructure: Rn, ignoreTransaction: function (t) { return It.trans ? un(It.transless, t) : t() }, vip: function (t) { return Xt((function () { return It.letThrough = !0, t() })) }, async: function (t) { return function () { try { var n = Cn(t.apply(this, arguments)); return n && \"function\" == typeof n.then ? n : Pt.resolve(n) } catch (t) { return ln(t) } } }, spawn: function (t, n, e) { try { var r = Cn(t.apply(e, n || [])); return r && \"function\" == typeof r.then ? r : Pt.resolve(r) } catch (t) { return ln(t) } }, currentTransaction: { get: function () { return It.trans || null } }, waitFor: function (t, n) { var e = Pt.resolve(\"function\" == typeof t ? In.ignoreTransaction(t) : t).timeout(n || 6e4); return It.trans ? It.trans.waitFor(e) : e }, Promise: Pt, debug: { get: function () { return K }, set: function (t) { B(t, \"dexie\" === t ? function () { return !0 } : Dn) } }, derive: d, extend: a, props: f, override: m, Events: dn, getByKeyPath: E, setByKeyPath: k, delByKeyPath: function (t, n) { \"string\" == typeof n ? k(t, n, void 0) : \"length\" in n && [].map.call(n, (function (n) { k(t, n, void 0) })) }, shallowClone: D, deepClone: j, getObjectDiff: P, asap: w, maxKey: yn, minKey: mn, addons: [], connections: _n, MultiModifyError: H.Modify, errnames: G, IndexSpec: Kn, TableSchema: Bn, dependencies: function () { try { return { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange } } catch (t) { return { indexedDB: null, IDBKeyRange: null } } }(), semVer: vn, version: vn.split(\".\").map((function (t) { return parseInt(t) })).reduce((function (t, n, e) { return t + n / Math.pow(10, 2 * e) })), default: In, Dexie: In }), Pt.rejectionMapper = function (t, n) { if (!t || t instanceof z || t instanceof TypeError || t instanceof SyntaxError || !t.name || !J[t.name]) return t; var e = new J[t.name](n || t.message, t); return \"stack\" in t && l(e, \"stack\", { get: function () { return this.inner.stack } }), e }, (pn = new In(\"__dbnames\")).version(1).stores({ dbnames: \"name\" }), function () { var t = \"Dexie.DatabaseNames\"; try { void 0 !== typeof localStorage && void 0 !== o.document && (JSON.parse(localStorage.getItem(t) || \"[]\").forEach((function (t) { return pn.dbnames.put({ name: t }).catch(X) })), localStorage.removeItem(t)) } catch (t) { } }(); const Mn = In } }, n = {}; function e(r) { var i = n[r]; if (void 0 !== i) return i.exports; var o = n[r] = { exports: {} }; return t[r].call(o.exports, o, o.exports, e), o.exports } e.n = t => { var n = t && t.__esModule ? () => t.default : () => t; return e.d(n, { a: n }), n }, e.d = (t, n) => { for (var r in n) e.o(n, r) && !e.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: n[r] }) }, e.g = function () { if (\"object\" == typeof globalThis) return globalThis; try { return this || new Function(\"return this\")() } catch (t) { if (\"object\" == typeof window) return window } }(), e.o = (t, n) => Object.prototype.hasOwnProperty.call(t, n), e.r = t => { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t, \"__esModule\", { value: !0 }) }, (() => { \"use strict\"; var t = e(128), n = e(534), r = e.n(n), i = e(363), o = e.n(i); const a = { debug: !1 }; /* console.log(\"[*] Cargando RanasDB...\"); */ class u { static get Dexie() { return t.default } static get DexieRelationships() { return r() } static get Check() { return o() } static create(t, n, e, r) { return new u(t, n, e, r) } static connect(t, n, e, r) { return new u(t, n, e, r).initialize() } static dropDatabase(t) { return u.Dexie.delete(t) } static dropDatabaseIfExists(t) { try { return u.Dexie.delete(t) } catch (t) { } } static get defaultOptions() { return a } constructor(n = \"Base_de_datos_por_defecto_de_ranas_db\", e = [], i = this.constructor.defaultOptions, a = {}) { o().that(n).isString(), o().that(e).isArray(); for (let t = 0; t < e.length; t++) { const n = e[t]; o().that(n).isArray().hasLengthGreaterThan(1), o().that(n[0]).isObject(), o().that(n[1]).isFunction() } this.options = i, this.databaseID = n, this.versionation = e, this.dexieDB = new t.default(this.databaseID, { addons: [r()] }) } debug(...t) { \"function\" == typeof this.options.debug && this.options.debug(...t) } initialize() { if (this.debug(`Initializing: #${this.databaseID}`), !this.dexieDB.isOpen()) for (let t = 0; t < this.versionation.length; t++) { const [n, e] = this.versionation[t], r = this.dexieDB.version(t + 1).stores(n); e && r.upgrade(e) } return this } select(t, n = (() => !0), e = []) { this.debug(`Selecting on: #${this.databaseID} » ${t}`, { table: t, filter: n, joins: e }), o().that(t).isString(), o().that(n).isFunction(); let r = this.dexieDB.table(t).filter(n); for (let t = 0; t < e.length; t++) { let n = e[t]; r = r.with({ [n]: n }) } return r.toArray() } insert(t, n) { return this.debug(`Inserting on: #${this.databaseID} » ${t}`, { table: t, item: n }), o().that(t).isString(), o().that(n).isObject(), this.dexieDB.table(t).add(n) } update(t, n, e) { return this.debug(`Updating on: #${this.databaseID} » ${t}`, { table: t, id: n, value: e }), o().that(t).isString(), o().that(n).isNumber(), o().that(e).isObject(), this.dexieDB.table(t).update(n, e) } delete(t, n) { return this.debug(`Deleting on: #${this.databaseID} » ${t}`, { table: t, id: n }), o().that(t).isString(), o().that(n).isNumber(), this.dexieDB.table(t).delete(n) } } \"undefined\" != typeof window && (window.RanasDB = u), void 0 !== e.g && (e.g.RanasDB = u) })() })();\n\n//Included:lib/013.rest-v0.0.1.part.js\n//RestUtils.require(\"fs\").writeFileSync(__dirname + \"/../process.json\", \"\" + process.pid, \"utf8\");\n\n(function (scope, factory) {\n    const jsmodule = factory();\n    if (typeof window !== \"undefined\") {\n        window.Automatic_http_rest_api_interface = jsmodule;\n    }\n    if (typeof global !== \"undefined\") {\n        global.Automatic_http_rest_api_interface = jsmodule;\n    }\n    if (typeof define === \"function\") {\n        define(\"Automatic_http_rest_api_interface\", jsmodule);\n    }\n    if (typeof module !== \"undefined\") {\n        module.exports = jsmodule;\n    }\n    return jsmodule;\n})(this, () => function (factoryParameters) {\n\n    const defaultConfigurations = {\n        platform: \"node\", // \"browser\"\n        environment: \"production\", // \"development\", \"testing\"\n        debug: true,\n        debugSQL: true,\n        debugErrors: true,\n        responseWrapper: {\n            app: {\n                title: \"Automatic HTTP REST API development\",\n                author: {\n                    name: \"allnulled\",\n                    telephone: \"+34 619 98 26 22\",\n                    url: \"https://www.github.com/allnulled\",\n                }\n            }\n        },\n        traceCallback: function (id) {\n            if (configurations.debug) {\n                if (configurations.platform === \"node\") {\n                    console.log(\"\\u001b[32m[TRACE]\\u001b[0m \" + id);\n                } else {\n                    console.log(\"[TRACE] \" + id);\n                }\n            }\n        },\n        traceSQLCallback: function (id) {\n            if (configurations.debugSQL) {\n                if (configurations.platform === \"node\") {\n                    console.log(\"\\u001b[33m[·SQL·]\\u001b[0m \" + id.split(\"\\n\").join(\"\\n  \"));\n                } else {\n                    console.log(\"[·SQL·] \" + id);\n                }\n            }\n        },\n        traceErrorCallback: function (error) {\n            try {\n                if (configurations.debugErrors) {\n                    let id = undefined;\n                    if (typeof error === \"string\") {\n                        id = error;\n                    } else if (error instanceof Error) {\n                        id = error.name + \": \" + error.message + \"\\n      \" + error.stack + \"\";\n                    }\n                    if (configurations.platform === \"node\") {\n                        console.log(\"\\u001b[31m[ERROR]\\u001b[0m \" + id.split(\"\\n\").join(\"\\n  \"));\n                    } else {\n                        console.log(\"[ERROR] \" + id);\n                    }\n                }\n            } catch (error) {\n                console.log(error);\n            }\n        },\n    };\n\n    const configurations = Object.assign(defaultConfigurations, factoryParameters);\n    const trace = configurations.traceCallback;\n    const traceSQL = configurations.traceSQLCallback;\n    const traceError = configurations.traceErrorCallback;\n\n    const RestClient = function (baseUrl, client = {}) {\n        Object.assign(client, {\n            defaults: {\n                headers: {\n                    common: {\n                        // @CONFIGURABLE\n                    }\n                }\n            },\n            request: (method, url, requestArgs = {}, requestConfigArgs = {}, responseArgs = {}, ...args) => {\n                trace(\"DataServer.prototype.createClient:request\");\n                const parsedUrl = RestUtils.require(\"url\").parse(url);\n                trace(\"RestClient is requesting: \" + url);\n                const requestParameters = Object.assign({}, requestArgs);\n                const responseParameters = Object.assign({}, responseArgs);\n                if (configurations.platform === \"browser\") {\n                    const queryParameters = Object.assign({}, requestParameters);\n                    requestParameters.headers = Object.assign({}, client.defaults.headers.common, requestConfigArgs.headers || {});\n                    requestParameters.query = queryParameters;\n                    if (parsedUrl.pathname.startsWith(client.server.basePathForData)) {\n                        return client.server.dispatchSelf(method, url, requestParameters, responseParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForAuth)) {\n                        return client.server.dispatchSelf(method, url, requestParameters, responseParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForProcess)) {\n                        return client.server.dispatchSelf(method, url, requestParameters, responseParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForQuery)) {\n                        return client.server.dispatchSelf(method, url, requestParameters, responseParameters, ...args);\n                    } else {\n                        throw new Error(\"Required parameter «url» to start as a valid basepath on browser in order to «createClient:request»\");\n                    }\n                } else if (configurations.platform === \"node\") {\n                    const requestConfigParameters = Object.assign({}, { headers: {} }, requestConfigArgs);\n                    Object.assign(requestConfigParameters.headers, client.defaults.headers.common,)\n                    if (parsedUrl.pathname.startsWith(client.server.basePathForData)) {\n                        return require(\"axios\").create()[method](url, requestParameters, requestConfigParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForAuth)) {\n                        return require(\"axios\").create()[method](url, requestParameters, requestConfigParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForProcess)) {\n                        return require(\"axios\").create()[method](url, requestParameters, requestConfigParameters, ...args);\n                    } else if (parsedUrl.pathname.startsWith(client.server.basePathForQuery)) {\n                        return require(\"axios\").create()[method](url, requestParameters, requestConfigParameters, ...args);\n                    } else {\n                        throw new Error(\"Required parameter «url» to start as a valid basepath on browser in order to «createClient:request»\");\n                    }\n                } else {\n                    throw new Error(\"Required configuration «platform» to be a valid platform on node in order to «createClient:request»\");\n                }\n            },\n            auth: {\n                login: (user, password) => {\n                    trace(\"DataServer.prototype.createClient:auth:login\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/login\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        user,\n                        password,\n                    }).toString());\n                },\n                logout: (session_token) => {\n                    trace(\"DataServer.prototype.createClient:auth:logout\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/logout\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        session_token: session_token,\n                    }).toString());\n                },\n                register: (user, password, email) => {\n                    trace(\"DataServer.prototype.createClient:auth:register\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/register\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        user,\n                        password,\n                        email,\n                    }).toString());\n                },\n                confirm: (token) => {\n                    trace(\"DataServer.prototype.createClient:auth:confirm\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/confirm\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        token,\n                    }).toString());\n                },\n                forgot: (user) => {\n                    trace(\"DataServer.prototype.createClient:auth:forgot\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/forgot\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        user,\n                    }).toString());\n                },\n                recover: (token) => {\n                    trace(\"DataServer.prototype.createClient:auth:recover\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/recover\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        token,\n                    }).toString());\n                },\n                unregister: (user, password) => {\n                    trace(\"DataServer.prototype.createClient:auth:unregister\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForAuth, \"/unregister\");\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        user,\n                        password,\n                    }).toString());\n                },\n            },\n            rest: {\n                selectOne: (model, where) => {\n                    trace(\"DataServer.prototype.createClient:rest:selectOne\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/select/one\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where)\n                    }).toString());\n                },\n                selectMany: (model, where = [], order = [], group = [], pagination = []) => {\n                    trace(\"DataServer.prototype.createClient:rest:selectMany\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/select/many\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where),\n                        group: JSON.stringify(group),\n                        order: JSON.stringify(order),\n                        pagination: JSON.stringify(pagination)\n                    }).toString());\n                },\n                insertOne: (model, item) => {\n                    trace(\"DataServer.prototype.createClient:rest:insertOne\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/insert/one\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        item: JSON.stringify(item),\n                    }).toString());\n                },\n                insertMany: (model, items) => {\n                    trace(\"DataServer.prototype.createClient:rest:insertMany\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/insert/many\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        items: JSON.stringify(items),\n                    }).toString());\n                },\n                updateOne: (model, where, values) => {\n                    trace(\"DataServer.prototype.createClient:rest:updateOne\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/update/one\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where),\n                        values: JSON.stringify(values),\n                    }).toString());\n                },\n                updateMany: (model, where, values) => {\n                    trace(\"DataServer.prototype.createClient:rest:updateMany\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/update/many\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where),\n                        values: JSON.stringify(values),\n                    }).toString());\n                },\n                deleteOne: (model, where) => {\n                    trace(\"DataServer.prototype.createClient:rest:deleteOne\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/delete/one\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where),\n                    }).toString());\n                },\n                deleteMany: (model, where) => {\n                    trace(\"DataServer.prototype.createClient:rest:deleteMany\");\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForData, model, \"/delete/many\");\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams({\n                        where: JSON.stringify(where),\n                    }).toString());\n                },\n            },\n            queries: client.server.queries.reduce((output, item) => {\n                output[item.id] = (parameters, ...args) => {\n                    trace(\"DataServer.prototype.createClient:queries:\" + item.id);\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForQuery, item.path);\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams(parameters), ...args);\n                };\n                return output;\n            }, {}),\n            processes: client.server.processes.reduce((output, item) => {\n                output[item.id] = (parameters, ...args) => {\n                    trace(\"DataServer.prototype.createClient:processes:\" + item.id);\n                    const finalUrl = baseUrl + RestUtils.require(\"path\").join(client.server.basePathForProcess, item.path);\n                    trace(finalUrl);\n                    return this.request(\"get\", finalUrl + \"?\" + new URLSearchParams(parameters), ...args);\n                };\n                return output;\n            }, {})\n        });\n        return Object.assign(this, client);\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // -1. Hooks class:\n    const Hooks = function () {\n        this.hooks = {};\n    };\n    Hooks.create = function (...args) {\n        trace(\"Hooks.create\");\n        return new Hooks(...args);\n    };\n    Hooks.prototype.addHook = function (selectorString, hookId, event) {\n        trace(\"Hooks.prototype.addHook\");\n        if (typeof selectorString !== \"string\") {\n            throw new Error(\"Required argument «selectorString» to be an array in order to «addHook»\");\n        } else if (selectorString.length === 0) {\n            throw new Error(\"Required argument «selectorString» to have one or more items in order to «addHook»\");\n        }\n        if (typeof hookId !== \"string\") {\n            throw new Error(\"Required argument «hookId» to be a string in order to «addHook»\");\n        }\n        if (typeof event !== \"function\") {\n            throw new Error(\"Required argument «event» to be a function in order to «addHook»\");\n        }\n        if (!(selectorString in this.hooks)) {\n            this.hooks[selectorString] = [];\n        }\n        this.hooks[selectorString].push({\n            id: hookId,\n            event\n        });\n        return this;\n    };\n    Hooks.prototype.addHooks = function (selectorList, hookId, event) {\n        trace(\"Hooks.prototype.addHooks\");\n        if (!Array.isArray(selectorList)) {\n            throw new Error(\"Required argument «selectorList» to be an array in order to «addHooks»\");\n        } else if (selectorList.length === 0) {\n            throw new Error(\"Required argument «selectorList» to have one or more items in order to «addHooks»\");\n        }\n        if (typeof hookId !== \"string\") {\n            throw new Error(\"Required argument «hookId» to be a string in order to «addHooks»\");\n        }\n        if (typeof event !== \"function\") {\n            throw new Error(\"Required argument «event» to be a function in order to «addHooks»\");\n        }\n        const selectors = Array.isArray(selectorList) ? selectorList : [selectorList];\n        for (let indexSelectors = 0; indexSelectors < selectors.length; indexSelectors++) {\n            const selector = selectors[indexSelectors];\n            this.addHook(selector, hookId, event);\n        }\n        return this;\n    };\n    Hooks.prototype.useHook = async function (selectorString, parameters = {}) {\n        trace(\"Hooks.prototype.useHook\");\n        try {\n            trace(\"Throwing hook: \" + selectorString);\n            if (typeof selectorString !== \"string\") {\n                throw new Error(\"Required argument «selectorString» to be a string in order to «useHook»\");\n            }\n            if (typeof parameters !== \"object\") {\n                throw new Error(\"Required argument «parameters» to be an object or omitted in order to «useHook»\");\n            }\n            if (!(selectorString in this.hooks)) {\n                return parameters;\n            }\n            const hookEvents = this.hooks[selectorString];\n            IteratingSelection:\n            for (let indexList = 0; indexList < hookEvents.length; indexList++) {\n                const hookEvent = hookEvents[indexList];\n                let hookFunction = undefined;\n                if (typeof hookEvent === \"object\") {\n                    if (typeof hookEvent.event === \"function\") {\n                        hookFunction = hookEvent.event;\n                    } else throw new Error(\"Required hook «\" + selectorString + \"» on index «\" + indexList + \"» on property «event» to be a function in order to «useHook»\");\n                } else throw new Error(\"Required hook «\" + selectorString + \"» on index «\" + indexList + \"» to be an object in order to «useHook»\");\n                const result = await hookFunction(parameters);\n                if (typeof result !== \"undefined\") {\n                    parameters = result;\n                }\n            }\n            return parameters;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    Hooks.prototype.replaceHook = function (selectorString, hookId, eventSource) {\n        trace(\"Hooks.prototype.replaceHook\");\n        try {\n            if (typeof selectorString !== \"string\") {\n                throw new Error(\"Required argument «selectorString» to be a string in order to «replaceHook»\");\n            }\n            if (!(selectorString in this.hooks)) {\n                throw new Error(\"Required argument «selectorString» to be a valid hook id in order to «replaceHook»\");\n            }\n            if (typeof hookId !== \"string\") {\n                throw new Error(\"Required argument «hookId» to be a string in order to «replaceHook»\");\n            }\n            if (typeof eventSource !== \"object\") {\n                throw new Error(\"Required argument «eventSource» to be an object in order to «replaceHook»\");\n            }\n            if (typeof eventSource.id !== \"string\") {\n                throw new Error(\"Required argument «eventSource.id» to be a string in order to «replaceHook»\");\n            }\n            if (typeof eventSource.event !== \"function\") {\n                throw new Error(\"Required argument «eventSource.event» to be a function in order to «replaceHook»\");\n            }\n            let count = 0;\n            const hookEvents = this.hooks[selectorString];\n            IteratingSelection:\n            for (let indexList = 0; indexList < hookEvents.length; indexList++) {\n                const hookEvent = hookEvents[indexList];\n                if (hookEvent.id === hookId) {\n                    this.hooks[selectorString].splice(indexList, 1, eventSource);\n                    count++;\n                }\n            }\n            return count;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    Hooks.prototype.removeHook = function (selectorString, hookId) {\n        trace(\"Hooks.prototype.removeHook\");\n        try {\n            if (typeof selectorString !== \"string\") {\n                throw new Error(\"Required argument «selectorString» to be a string in order to «removeHook»\");\n            }\n            if (!(selectorString in this.hooks)) {\n                throw new Error(\"Required argument «selectorString» to be a valid hook id in order to «removeHook»\");\n            }\n            if (typeof hookId !== \"string\") {\n                throw new Error(\"Required argument «hookId» to be an string in order to «removeHook»\");\n            }\n            let count = 0;\n            const hookEvents = this.hooks[selectorString];\n            IteratingSelection:\n            for (let indexList = 0; indexList < hookEvents.length; indexList++) {\n                const hookEvent = hookEvents[indexList];\n                if (typeof hookEvent === \"object\") {\n                    if (hookEvent.id === hookId) {\n                        this.hooks[selectorString].splice(indexList, 1);\n                        count++;\n                    }\n                }\n            }\n            return count;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 0. RestUtils object:\n    const RestUtils = {\n        prototype: {},\n        modules: {},\n        modulePolyfills: {\n            \"mysql2/promise\": {\n                createConnection: function () {\n                    trace(\"polyfill://require:mysql2/promise:createConnection\");\n                    return {\n                        ping() {\n                            trace(\"polyfill://require:mysql2/promise:createConnection:ping\");\n                            // throw new Error(\"Method ping must be overriden\");\n                        },\n                        query(query, ...args) {\n                            trace(\"polyfill://require:mysql2/promise:createConnection:query\");\n                            console.log(\"Function «RestUtils.modulePolyfills.mysql2/promises.createConnection.query» to be overwritten\");\n                            console.log(query);\n                            return [[], []];\n                        },\n                        proxifiedQuery(query, ...args) {\n                            trace(\"polyfill://require:mysql2/promise:createConnection:proxifiedQuery\");\n                            traceSQL(query);\n                            return this.query(query, ...args);\n                        }\n                    }\n                }\n            },\n            \"url\": {\n                parse: function (parameter) {\n                    trace(\"polyfill://require:url:parse x \" + parameter);\n                    return new URL(parameter);\n                },\n            },\n            \"sqlstring\": {\n                sanitize: function (arg) {\n                    trace(\"polyfill://require:sqlstring:sanitize\");\n                    return arg;\n                },\n                sanitizeId: function (arg) {\n                    trace(\"polyfill://require:sqlstring:sanitizeId\");\n                    return arg;\n                },\n            },\n            \"path\": {\n                resolve: function (...args) {\n                    trace(\"polyfill://require:path:resolve\");\n                    return [\"\", ...args].map(i => i.replace(/^\\//g, \"\").replace(/\\/$/g, \"\")).join(\"/\");\n                },\n                join: function (...args) {\n                    trace(\"polyfill://require:path:join\");\n                    return [\"\", ...args].filter(i => typeof i !== \"undefined\").map(i => i.replace(/^\\//g, \"\").replace(/\\/$/g, \"\")).join(\"/\");\n                },\n            },\n            \"http\": {\n                createServer: function (controller) {\n                    trace(\"polyfill://require:http:createServer\");\n                    return {\n                        listen: function (options, callback) {\n                            trace(\"polyfill://require:http:createServer:listen\");\n                            setTimeout(callback, 0);\n                        }\n                    }\n                }\n            },\n        },\n        require: function (modulepath) {\n            trace(\"RestUtils.require\");\n            if (modulepath in RestUtils.modules) {\n                return RestUtils.modules[modulepath];\n            }\n            if (configurations.platform === \"browser\") {\n                if (modulepath in RestUtils.modulePolyfills) {\n                    return RestUtils.modulePolyfills[modulepath];\n                } else {\n                    throw new Error(\"Not identified package: \" + modulepath);\n                }\n            }\n            RestUtils.modules[modulepath] = require(modulepath);\n            return RestUtils.modules[modulepath];\n        },\n        define: function (name, value) {\n            trace(\"RestUtils.define\");\n            RestUtils.modules[name] = value;\n        },\n        definePolyfill: function (name, value) {\n            trace(\"RestUtils.definePolyfill\");\n            RestUtils.modulePolyfills[name] = value;\n        },\n        wrapResponse: function (data) {\n            trace(\"RestUtils.wrapResponse\");\n            return {\n                ...configurations.responseWrapper,\n                ...data,\n                time: new Date().toString()\n            };\n        },\n        respondContext: function (context) {\n            trace(\"RestUtils.respondContext\");\n            const response = context.output;\n            const responseWrapped = RestUtils.wrapResponse(response);\n            const responseJson = JSON.stringify(responseWrapped, null, 2);\n            context.response.writeHead(200, { \"Content-type\": \"application/json\" });\n            context.response.write(responseJson);\n            return context.response.end();\n        },\n        generateRandomToken: function (len, alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\") {\n            trace(\"RestUtils.generateRandomToken\");\n            let output = \"\";\n            for (let index = 0; index < len; index++) {\n                output += alphabet[Math.floor(Math.random() * alphabet.length)];\n            }\n            return output;\n        },\n        generateOnErrorFunction: function (id) {\n            trace(\"RestUtils.generateOnErrorFunction\");\n            return function (error, propagate = true) {\n                trace(id);\n                traceError(error);\n                if (propagate) {\n                    throw error;\n                }\n            };\n        },\n        generateContextByRequestResponseFactory: function (id) {\n            trace(\"RestUtils.generateContextByRequestResponseFactory\");\n            return function (request, response) {\n                trace(id);\n                const parsedURL = RestUtils.require(\"url\").parse(request.url, true);\n                return {\n                    output: {},\n                    parameters: {},\n                    state: {},\n                    input: {\n                        url: parsedURL.pathname,\n                        query: RestUtils.fromURLToQuerystringObject(request.url),\n                        body: request.body,\n                        params: request.params,\n                        request,\n                        response\n                    },\n                    request,\n                    response,\n                };\n            };\n        },\n        generateOnDispatchErrorFunction: function (traceId) {\n            trace(\"RestUtils.generateOnDispatchErrorFunction\");\n            return function (error, request, response) {\n                trace(traceId);\n                traceError(error);\n                response.writeHead(500, { \"Content-Type\": \"application/json\" });\n                const data = {\n                    name: error.name,\n                    message: error.message,\n                    stack: Object.assign({}, error.stack.split(/\\n    /g))\n                };\n                const wrappedData = RestUtils.wrapResponse({\n                    status: \"error\",\n                    error: data\n                });\n                const wrappedJson = JSON.stringify(wrappedData, null, 2);\n                response.write(wrappedJson);\n                return response.end();\n            };\n        },\n        noop: function () { },\n        basicServiceFactory: function () {\n            trace(\"RestUtils.basicServiceFactory\");\n            return function (modifications) {\n                trace(\"RestUtils.basicServiceFactory:Service\");\n                Object.assign(this, modifications);\n                return this;\n            }\n        },\n        basicQueryFactory: function () {\n            trace(\"RestUtils.basicQueryFactory\");\n            return function () {\n                trace(\"RestUtils.basicQueryFactory:Query\");\n                return this;\n            }\n        },\n        basicProcessFactory: function () {\n            trace(\"RestUtils.basicProcessFactory\");\n            return function () {\n                trace(\"RestUtils.basicProcessFactory:Process\");\n                return this;\n            }\n        },\n        basicControllerFallback: function (request, response) {\n            trace(\"RestUtils.basicControllerFallback\");\n            response.writeHead(404);\n            response.write(\"Error 404: Page was not found.\");\n            return response.end();\n        },\n        sanitize: function (value) {\n            trace(\"RestUtils.sanitize\");\n            return RestUtils.require(\"sqlstring\").escape(value);\n        },\n        sanitizeId: function (id) {\n            trace(\"RestUtils.sanitizeId\");\n            return RestUtils.require(\"sqlstring\").escapeId(id);\n        },\n        availableOperators: {\n            \"<\": \"<\",\n            \"<=\": \"<=\",\n            \">\": \">\",\n            \">=\": \">=\",\n            \"=\": \"=\",\n            \"!=\": \"!=\",\n            \"in\": \"IN\",\n            \"!in\": \"NOT IN\",\n            // \"contains\": \"contains\",\n            // \"!contains\": \"!contains\",\n        },\n        validateStaticServiceInterface: function (staticInterface) {\n            trace(\"RestUtils.validateStaticServiceInterface\");\n            if (typeof staticInterface !== \"function\") {\n                throw new Error(\"Required parameter «staticInterface» to be an function in order to «validateStaticServiceInterface»\")\n            }\n            if (typeof staticInterface.table !== \"string\") {\n                throw new Error(\"Required parameter «staticInterface.table» to be a string in order to «validateStaticServiceInterface»\")\n            }\n            if (typeof staticInterface.path !== \"string\") {\n                throw new Error(\"Required parameter «staticInterface.path» to be a string in order to «validateStaticServiceInterface»\")\n            }\n            if (typeof staticInterface.creationScript !== \"string\") {\n                throw new Error(\"Required parameter «staticInterface.creationScript» to be a string in order to «validateStaticServiceInterface»\")\n            }\n            if (typeof staticInterface.schema !== \"object\") {\n                throw new Error(\"Required parameter «staticInterface.schema» to be an object in order to «validateStaticServiceInterface»\")\n            }\n            return true;\n        },\n        validateDynamicServiceInterface: function (dynamicInterface) {\n            trace(\"RestUtils.validateDynamicServiceInterface\");\n            return true;\n        },\n        validateStaticQueryInterface: function (staticInterface) {\n            trace(\"RestUtils.validateStaticQueryInterface\");\n            if (typeof staticInterface.path !== \"string\") {\n                throw new Error(\"Required parameter «staticInterface.path» to be a string in order to «validateStaticQueryInterface»\")\n            }\n            if (typeof staticInterface.query !== \"function\") {\n                throw new Error(\"Required parameter «staticInterface.query» to be a function in order to «validateStaticQueryInterface»\")\n            }\n            return true;\n        },\n        validateDynamicQueryInterface: function (dynamicInterface) {\n            trace(\"RestUtils.validateDynamicQueryInterface\");\n            return true;\n        },\n        validateStaticProcessInterface: function (staticInterface) {\n            trace(\"RestUtils.validateStaticProcessInterface\");\n            if (typeof staticInterface.path !== \"string\") {\n                throw new Error(\"Required parameter «staticInterface.path» to be a string in order to «validateStaticProcessInterface»\")\n            }\n            if (typeof staticInterface.process !== \"function\") {\n                throw new Error(\"Required parameter «staticInterface.process» to be a function in order to «validateStaticProcessInterface»\")\n            }\n            return true;\n        },\n        validateDynamicProcessInterface: function (dynamicInterface) {\n            trace(\"RestUtils.validateDynamicProcessInterface\");\n            return true;\n        },\n        expandConnection: function (connection) {\n            trace(\"RestUtils.expandConnection\");\n            connection.proxifiedQuery = function (query) {\n                trace(\"RestUtils.expandConnection:connection.proxifiedQuery\");\n                traceSQL(query);\n                return this.query(query);\n            }\n            return connection;\n        },\n        formatTableFromRequest: function (context, { start, end }) {\n            trace(\"RestUtils.formatTableFromRequest\");\n            return RestUtils.require(\"url\").parse(context.request.url).pathname\n                .replace(start, \"\")\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n                .replace(end.split(\"\").reverse().join(\"\"), \"\")\n                .split(\"\")\n                .reverse()\n                .join(\"\");\n        },\n        formatWhereFromRequest: function (context) {\n            trace(\"RestUtils.formatWhereFromRequest\");\n            const where = context.input.query.where || \"[]\";\n            if (typeof where === \"object\") {\n                return where;\n            }\n            let whereData = undefined;\n            try {\n                whereData = JSON.parse(where);\n            } catch (error) {\n                throw new Error(\"Required parameter «where» to be a well-formed JSON object in order to «formatWhereFromRequest»\");\n            }\n            if (!Array.isArray(whereData)) {\n                throw new Error(\"Required parameter «where» to be a JSON array in order to «formatWhereFromRequest»\");\n            }\n            if (whereData.length === 0) {\n                return whereData;\n            }\n            for (let index = 0; index < whereData.length; index++) {\n                const whereRule = whereData[index];\n                if (!Array.isArray(whereRule)) {\n                    throw new Error(\"Required parameter «where[\" + index + \"]» to be an array in order to «formatWhereFromRequest»\");\n                }\n                if (whereRule.length < 3) {\n                    throw new Error(\"Required parameter «where[\" + index + \"]» to be an array of 3 or more items in order to «formatWhereFromRequest»\");\n                }\n                if (typeof whereRule[0] !== \"string\") {\n                    throw new Error(\"Required parameter «where[\" + index + \"][0]» to be a string in order to «formatWhereFromRequest»\");\n                }\n                if (typeof whereRule[1] !== \"string\") {\n                    throw new Error(\"Required parameter «where[\" + index + \"][1]» to be a string in order to «formatWhereFromRequest»\");\n                }\n                if (!(whereRule[1] in RestUtils.availableOperators)) {\n                    throw new Error(\"Required parameter «where[\" + index + \"][1]» to be a valid query operator in order to «formatWhereFromRequest»\");\n                }\n            }\n            return whereData;\n        },\n        formatOrderFromRequest: function (context) {\n            trace(\"RestUtils.formatOrderFromRequest\");\n            const order = context.input.query.order || \"[]\";\n            let orderData = undefined;\n            if (typeof order === \"object\") {\n                orderData = order;\n            } else if (typeof order !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.order» to be an (optionally JSON) array in order to «formatOrderFromRequest»\");\n            } else {\n                try {\n                    orderData = JSON.parse(order);\n                } catch (error) {\n                    throw new Error(\"Required parameter «order» to be a well-formed JSON object in order to «formatOrderFromRequest»\");\n                }\n            }\n            if (!Array.isArray(orderData)) {\n                throw new Error(\"Required parameter «order» to be a JSON array in order to «formatOrderFromRequest»\");\n            }\n            if (orderData.length === 0) {\n                orderData.push(\"id\");\n            }\n            for (let index = 0; index < orderData.length; index++) {\n                const orderRule = orderData[index];\n                if (typeof orderRule !== \"string\") {\n                    throw new Error(\"Required parameter «order[\" + index + \"]» to be a string in order to «formatOrderFromRequest»\");\n                }\n            }\n            return orderData;\n        },\n        formatGroupFromRequest: function (context) {\n            trace(\"RestUtils.formatGroupFromRequest\");\n            const group = context.input.query.group || \"[]\";\n            let groupData = undefined;\n            if (typeof group === \"object\") {\n                groupData = group;\n            } else if (typeof group !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.group» to be an (optionally JSON) array in order to «formatGroupFromRequest»\");\n            } else {\n                try {\n                    groupData = JSON.parse(group);\n                } catch (error) {\n                    throw new Error(\"Required parameter «group» to be a well-formed JSON object in group to «formatGroupFromRequest»\");\n                }\n            }\n            if (!Array.isArray(groupData)) {\n                throw new Error(\"Required parameter «group» to be a JSON array in group to «formatGroupFromRequest»\");\n            }\n            if (groupData.length === 0) {\n                return groupData;\n            }\n            for (let index = 0; index < groupData.length; index++) {\n                const groupRule = groupData[index];\n                if (typeof groupRule !== \"string\") {\n                    throw new Error(\"Required parameter «group[\" + index + \"]» to be a string in group to «formatGroupFromRequest»\");\n                }\n            }\n            return groupData;\n        },\n        formatPaginationFromRequest: function (context) {\n            trace(\"RestUtils.formatPaginationFromRequest\");\n            const pagination = context.input.query.pagination || \"[1,20]\";\n            let paginationData = undefined;\n            if (typeof pagination === \"object\") {\n                paginationData = pagination;\n            } else if (typeof pagination !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.pagination» to be an (optionally JSON) array in order to «formatPaginationFromRequest»\");\n            } else {\n                try {\n                    paginationData = JSON.parse(pagination);\n                } catch (error) {\n                    throw new Error(\"Required parameter «pagination» to be a well-formed JSON object in pagination to «formatPaginationFromRequest»\");\n                }\n            }\n            if (!Array.isArray(paginationData)) {\n                throw new Error(\"Required parameter «pagination» to be a JSON array in pagination to «formatPaginationFromRequest»\");\n            }\n            if (paginationData.length === 0) {\n                return paginationData;\n            }\n            const [page = 1, items = 20] = paginationData;\n            if (typeof page !== \"number\") {\n                throw new Error(\"Required parameter «page» to be a number in order to «formatPaginationFromRequest»\");\n            }\n            if (typeof items !== \"number\") {\n                throw new Error(\"Required parameter «items» to be a number in order to «formatPaginationFromRequest»\");\n            }\n            if (page < 0) {\n                throw new Error(\"Required parameter «pagination[0]» to be a number higher or equal to 0 in order to «formatPaginationFromRequest»\");\n            }\n            if (items < 1) {\n                throw new Error(\"Required parameter «pagination[1]» to be a number higher or equal to 1 in order to «formatPaginationFromRequest»\");\n            }\n            return paginationData;\n        },\n        formatItemFromRequest: function (context) {\n            trace(\"RestUtils.formatItemFromRequest\");\n            const item = context.input.query.item || \"{}\";\n            let itemData = undefined;\n            if (typeof item === \"object\") {\n                itemData = item;\n            } else if (typeof item !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.item» to be an (optionally JSON) object in order to «formatItemFromRequest»\");\n            } else {\n                try {\n                    itemData = JSON.parse(item);\n                } catch (error) {\n                    throw new Error(\"Required parameter «item» to be a well-formed JSON object to «formatItemFromRequest»\");\n                }\n            }\n            if (typeof itemData !== \"object\") {\n                throw new Error(\"Required parameter «item» to be a JSON object to «formatItemFromRequest»\");\n            }\n            return itemData;\n        },\n        formatItemsFromRequest: function (context) {\n            trace(\"RestUtils.formatItemsFromRequest\");\n            const items = context.input.query.items || \"{}\";\n            let itemsData = undefined;\n            if (typeof items === \"object\") {\n                itemsData = items;\n            } else if (typeof items !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.items» to be an (optionally JSON) object in order to «formatItemsFromRequest»\");\n            } else {\n                try {\n                    itemsData = JSON.parse(items);\n                } catch (error) {\n                    throw new Error(\"Required parameter «item» to be a well-formed JSON object to «formatItemsFromRequest»\");\n                }\n            }\n            if (!Array.isArray(itemsData)) {\n                throw new Error(\"Required parameter «items» to be an (optionally JSON) array in order to «formatItemsFromRequest»\");\n            }\n            for (let index = 0; index < itemsData.length; index++) {\n                const itemData = itemsData[index];\n                if (typeof itemData !== \"object\") {\n                    throw new Error(\"Required parameter «items[\" + index + \"]» to be a JSON object to «formatItemsFromRequest»\");\n                }\n            }\n            return itemsData;\n        },\n        formatValuesFromRequest: function (context) {\n            trace(\"RestUtils.formatValuesFromRequest\");\n            const values = context.input.query.values || \"{}\";\n            let valuesData = undefined;\n            if (typeof values === \"object\") {\n                valuesData = values;\n            } else if (typeof values !== \"string\") {\n                throw new Error(\"Required parameter «context.input.query.values» to be an (optionally JSON) object in order to «formatValuesFromRequest»\");\n            } else {\n                try {\n                    valuesData = JSON.parse(values);\n                } catch (error) {\n                    throw new Error(\"Required parameter «values» to be a well-formed JSON object to «formatValuesFromRequest»\");\n                }\n            }\n            if (Array.isArray(valuesData)) {\n                throw new Error(\"Required parameter «values» to be an object and not an array in order to «formatValuesFromRequest»\");\n            } else if (typeof valuesData !== \"object\") {\n                throw new Error(\"Required parameter «values» to be an object in order to «formatValuesFromRequest»\");\n            }\n            return valuesData;\n        },\n        fromWhereToSQL: function (where, wholeClause = false) {\n            trace(\"RestUtils.fromWhereToSQL\");\n            if (!Array.isArray(where)) {\n                throw new Error(\"Required parameter «where» to be an array in order to «fromWhereToSQL»\");\n            }\n            if (where.length === 0) {\n                return \"# No filtering rules\";\n            }\n            let query = where.map((whereRule, index) => {\n                const sanitizedSubject = RestUtils.sanitizeId(whereRule[0]);\n                const sanitizedOperation = RestUtils.availableOperators[whereRule[1]];\n                const unsanitizedObject = whereRule[2];\n                const thirdArgumentMode = whereRule[3] || \"default\";\n                let sanitizedObject = whereRule[2];\n                if (thirdArgumentMode === \"default\") {\n                    if ((typeof unsanitizedObject !== \"string\") && (typeof unsanitizedObject !== \"number\")) {\n                        throw new Error(\"Required argument «where[\" + index + \"][2]» to be a string or a number (on «default» mode) in order to «RestUtils.fromWhereToSQL»\");\n                    }\n                    sanitizedObject = RestUtils.sanitize(unsanitizedObject);\n                } else if (thirdArgumentMode === \"column\") {\n                    throw new Error(\"Required argument «where[\" + index + \"][3]» to be a valid mode and 'column' mode is not allowed in order to «RestUtils.fromWhereToSQL»\");\n                    sanitizedObject = RestUtils.sanitizeId(unsanitizedObject);\n                } else if (thirdArgumentMode === \"null\") {\n                    sanitizedObject = \"NULL\";\n                } else if (thirdArgumentMode === \"array\") {\n                    let parsedObject = undefined;\n                    if (typeof unsanitizedObject === \"string\") {\n                        try {\n                            parsedObject = JSON.parse(unsanitizedObject);\n                        } catch (error) {\n                            throw new Error(\"Required argument «where[\" + index + \"][3]» to be a well-formed JSON in order to «RestUtils.fromWhereToSQL»\");\n                        }\n                    } else if (Array.isArray(unsanitizedObject)) {\n                        parsedObject = unsanitizedObject;\n                    } else {\n                        throw new Error(\"Required argument «where[\" + index + \"][2]» to be an (optionally JSON) array in order to «RestUtils.fromWhereToSQL»\");\n                    }\n                    if (!Array.isArray(parsedObject)) {\n                        throw new Error(\"Required argument «where[\" + index + \"][2]» to be a JSON array in order to «RestUtils.fromWhereToSQL»\");\n                    } else if (parsedObject.length === 0) {\n                        throw new Error(\"Required argument «where[\" + index + \"][2]» to be a JSON array with 1 or more items in order to «RestUtils.fromWhereToSQL»\");\n                    }\n                    sanitizedObject = \"(\" + parsedObject.map(item => RestUtils.sanitize(item)) + \")\";\n                } else {\n                    throw new Error(\"Required argument «where[\" + index + \"][3]» to be a a known mode in order to «RestUtils.fromWhereToSQL»\");\n                }\n                return `    AND ${sanitizedSubject} ${sanitizedOperation} ${sanitizedObject}`;\n            }).join(\"\\n\");\n            if (wholeClause) {\n                query = query.replace('    AND ', '  WHERE ');\n            }\n            return query;\n        },\n        fromOrderToSQL: function (order, wholeClause = true) {\n            trace(\"RestUtils.fromOrderToSQL\");\n            if (!Array.isArray(order)) {\n                throw new Error(\"Required parameter «order» to be an array in order to «fromOrderToSQL»\");\n            }\n            if (order.length === 0) {\n                return \"# No ordering rules\";\n            }\n            let query = order.map((orderRule, index) => {\n                if (typeof orderRule !== \"string\") {\n                    throw new Error(\"Required parameter «order[\" + index + \"]» to be a string in order «fromOrderToSQL»\");\n                }\n                const isDescending = orderRule.startsWith(\"!\");\n                const orderColumn = isDescending ? orderRule.substr(1) : orderRule;\n                return \", \" + RestUtils.sanitizeId(orderColumn) + (isDescending ? ' DESC' : ' ASC');\n            }).join(\", \");\n            if (wholeClause) {\n                query = query.replace(', ', '  ORDER BY ');\n            }\n            return query;\n        },\n        fromGroupToSQL: function (groups, wholeClause = true) {\n            trace(\"RestUtils.fromGroupToSQL\");\n            if (!Array.isArray(groups)) {\n                throw new Error(\"Required parameter «groups» to be an array in order to «fromGroupToSQL»\");\n            }\n            if (groups.length === 0) {\n                return \"# No grouping rules\";\n            }\n            let query = groups.map((groupsRule, index) => {\n                if (typeof groupsRule !== \"string\") {\n                    throw new Error(\"Required parameter «groups[\" + index + \"]» to be a string in order «fromGroupToSQL»\");\n                }\n                const isDescending = groupsRule.startsWith(\"!\");\n                const groupsColumn = isDescending ? groupsRule.substr(1) : groupsRule;\n                return \", \" + RestUtils.sanitizeId(groupsColumn) + (isDescending ? ' DESC' : ' ASC');\n            }).join(\", \");\n            if (wholeClause) {\n                query = query.replace(', ', '  GROUP BY ');\n            }\n            return query;\n        },\n        fromPaginationToSQL: function (pagination = []) {\n            trace(\"RestUtils.fromPaginationToSQL\");\n            if (!Array.isArray(pagination)) {\n                throw new Error(\"Required parameter «pagination» to be an array in order to «fromPaginationToSQL»\");\n            }\n            const [page = 1, items = 20] = pagination;\n            if (typeof page !== \"number\") {\n                throw new Error(\"Required parameter «pagination[0]» to be an array in order to «fromPaginationToSQL»\");\n            }\n            if (typeof items !== \"number\") {\n                throw new Error(\"Required parameter «pagination[1]» to be an array in order to «fromPaginationToSQL»\");\n            }\n            if (page < 0) {\n                throw new Error(\"Required parameter «pagination[0]» to be a number higher or equal to 0 in order to «fromPaginationToSQL»\");\n            }\n            if (items < 1) {\n                throw new Error(\"Required parameter «pagination[1]» to be a number higher or equal to 1 in order to «fromPaginationToSQL»\");\n            }\n            if (page === 0) {\n                return \"# No pagination rules\";\n            }\n            const limit = items;\n            const offset = (page - 1) * items;\n            const query = [\n                `  LIMIT ${limit}`,\n                `  OFFSET ${offset}`,\n            ].join(\"\\n\");\n            return query;\n        },\n        fromItemToKeysSQL: function (item, wholeToken = true) {\n            trace(\"RestUtils.fromItemToKeysSQL\");\n            if (typeof item !== \"object\") {\n                throw new Error(\"Required argument «item» to be an object in order to «fromItemToKeysSQL»\");\n            }\n            const keys = Object.keys(item);\n            const query = keys.map(key => RestUtils.sanitizeId(key)).join(\", \");\n            if (wholeToken) {\n                return \"(\" + query + \")\";\n            }\n            return query;\n        },\n        fromItemsToKeysSQL: function (items, wholeExpression = true) {\n            trace(\"RestUtils.fromItemsToKeysSQL\");\n            if (typeof items !== \"object\") {\n                throw new Error(\"Required argument «items» to be an object in order to «fromItemsToKeysSQL»\");\n            }\n            if (!Array.isArray(items)) {\n                throw new Error(\"Required argument «items» to be an array in order to «fromItemsToKeysSQL»\");\n            }\n            if (items.length === 0) {\n                throw new Error(\"Required argument «items» to have one or more items in order to «fromItemsToKeysSQL»\");\n            }\n            return this.fromItemToKeysSQL(items[0], wholeExpression);\n        },\n        fromItemToValuesSQL: function (item, wholeToken = true) {\n            trace(\"RestUtils.fromItemToValuesSQL\");\n            if (typeof item !== \"object\") {\n                throw new Error(\"Required argument «item» to be an object in order to «fromItemToValuesSQL»\");\n            }\n            const keys = Object.keys(item);\n            const query = keys.map(key => RestUtils.sanitize(item[key])).join(\", \");\n            if (wholeToken) {\n                return \"(\" + query + \")\";\n            }\n            return query;\n        },\n        fromItemToSettablesSQL: function (item, wholeToken = false) {\n            trace(\"RestUtils.fromItemToSettablesSQL\");\n            if (typeof item !== \"object\") {\n                throw new Error(\"Required argument «item» to be an object in order to «fromItemToSettablesSQL»\");\n            }\n            const keys = Object.keys(item);\n            const query = keys.map(key => \"\\n    \" + RestUtils.sanitizeId(key) + \" = \" + RestUtils.sanitize(item[key])).join(\",\");\n            if (wholeToken) {\n                return \"(\" + query + \")\";\n            }\n            return query;\n        },\n        fromItemsToValuesSQL: function (items, wholeExpression = true) {\n            trace(\"RestUtils.fromItemsToValuesSQL\");\n            const query = items.map((item, index) => {\n                if (typeof item !== \"object\") {\n                    throw new Error(\"Required argument «items[\" + index + \"]» to be an object in order to «fromItemsToValuesSQL»\");\n                }\n                const itemQuery = \"(\" + Object.keys(item).map((key, index) => {\n                    return \"\\n    \" + RestUtils.sanitize(item[key]);\n                }).join(\", \") + \"\\n  )\";\n                return itemQuery;\n            }).join(\", \");\n            return query;\n        },\n        fromWhereToFilterFunction(whereRules) {\n            const allFilters = [];\n            for (let indexRules = 0; indexRules < whereRules.length; indexRules++) {\n                const whereRule = whereRules[indexRules];\n                const [subject, operator, target, targetType = \"value\"] = whereRule;\n                const t1 = subject;\n                const t2 = RestUtils.availableOperators[operator];\n                const t3 = targetType === \"value\" ? target : targetType === \"array\" ? JSON.parse(target) : target;\n                const partialFilter = item => {\n                    // trace(\"RestUtils.fromWhereToFilterFunction:partialFilter\");\n                    if (!(t1 in item)) return false;\n                    const s1 = item[t1];\n                    const s2 = t2;\n                    const s3 = t3;\n                    switch (s2) {\n                        case \"<\":\n                            return s1 < s3;\n                        case \"<=\":\n                            return s1 <= s3;\n                        case \">\":\n                            return s1 > s3;\n                        case \">=\":\n                            return s1 >= s3;\n                        case \"!=\":\n                            return s1 !== s3;\n                        case \"=\":\n                            return s1 === s3;\n                        case \"!in\":\n                            return s3.indexOf(s1) === -1;\n                        case \"in\":\n                            return s3.indexOf(s1) !== -1;\n                    }\n                    return false;\n                };\n                allFilters.push((() => partialFilter)());\n            };\n            const finalFilter = function (item) {\n                // trace(\"RestUtils.fromWhereToFilterFunction:finalFilter\");\n                for (let indexFilters = 0; indexFilters < allFilters.length; indexFilters++) {\n                    const oneFilter = allFilters[indexFilters];\n                    const result = oneFilter(item);\n                    if (!result) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return finalFilter;\n        },\n        fromURLToQuerystringObject(url) {\n            const output = {};\n            const searchParams = new URLSearchParams(this.require(\"url\").parse(url).search);\n            searchParams.forEach((value, key) => {\n                output[key] = value;\n            });\n            return output;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 1. RestInterface class:\n    const RestInterface = function () { };\n    RestInterface.prototype.initialize = function () { throw new Error(\"Required method «initialize» to be overriden\") };\n    RestInterface.prototype.selectMany = function (dataType, { where, order, groups, page, items }, authentication) { throw new Error(\"Required method «selectMany» to be overriden\") };\n    RestInterface.prototype.selectOne = function (dataType, { where, order }, authentication) { throw new Error(\"Required method «selectOne» to be overriden\") };\n    RestInterface.prototype.insertMany = function (dataType, { values }, authentication) { throw new Error(\"Required method «insertMany» to be overriden\") };\n    RestInterface.prototype.insertOne = function (dataType, { value }, authentication) { throw new Error(\"Required method «insertOne» to be overriden\") };\n    RestInterface.prototype.updateMany = function (dataType, { where, value }, authentication) { throw new Error(\"Required method «updateMany» to be overriden\") };\n    RestInterface.prototype.updateOne = function (dataType, { where, value }, authentication) { throw new Error(\"Required method «updateOne» to be overriden\") };\n    RestInterface.prototype.deleteMany = function (dataType, { where }, authentication) { throw new Error(\"Required method «deleteMany» to be overriden\") };\n    RestInterface.prototype.deleteOne = function (dataType, { where }, authentication) { throw new Error(\"Required method «deleteOne» to be overriden\") };\n    RestInterface.prototype.getFile = function (dataType, { id, column }, authentication) { throw new Error(\"Required method «getFile» to be overriden\") };\n    RestInterface.prototype.setFile = function (dataType, { id, column, file }, authentication) { throw new Error(\"Required method «setFile» to be overriden\") };\n    RestInterface.prototype.resetDatabase = function (authentication) { throw new Error(\"Required method «resetDatabase» to be overriden\") };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 2. AuthInterface class:\n    const AuthInterface = function () { };\n    AuthInterface.prototype.initialize = function () { throw new Error(\"Required method «initialize» to be overriden\") };\n    AuthInterface.prototype.authenticate = function (token) { throw new Error(\"Required method «authenticate» to be overriden\") };\n    AuthInterface.prototype.login = function ({ user, password }) { throw new Error(\"Required method «login» to be overriden\") };\n    AuthInterface.prototype.logout = function (token) { throw new Error(\"Required method «logout» to be overriden\") };\n    AuthInterface.prototype.refresh = function (token) { throw new Error(\"Required method «refresh» to be overriden\") };\n    AuthInterface.prototype.register = function ({ user, password, email }) { throw new Error(\"Required method «register» to be overriden\") };\n    AuthInterface.prototype.confirm = function (confirmationToken) { throw new Error(\"Required method «confirm» to be overriden\") };\n    AuthInterface.prototype.forgot = function () { throw new Error(\"Required method «forgot» to be overriden\") };\n    AuthInterface.prototype.recover = function (recoverToken) { throw new Error(\"Required method «recover» to be overriden\") };\n    AuthInterface.prototype.unregister = function () { throw new Error(\"Required method «unregister» to be overriden\") };\n    AuthInterface.prototype.hasAuthorizationFor = function () { throw new Error(\"Required method «isAuthorizedFor» to be overriden\") };\n    AuthInterface.prototype.resetAuth = function () { throw new Error(\"Required method «resetAuth» to be overriden\") };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 4. DataServer class:\n    const DataServer = function (dynamicInterface = {}) {\n        trace(\"DataServer.constructor\");\n        Object.assign(this, dynamicInterface);\n        this.client = configurations.platform === \"node\" ? require(\"axios\").create() : {};\n        this.rest = undefined;\n        this.auth = undefined;\n        this.services = [];\n        this.queries = [];\n        this.processes = [];\n        this.hooks = Hooks.create();\n        this.basePathForData = \"/rest/api/v1\";\n        this.basePathForAuth = \"/auth/api/v1\";\n        this.basePathForQuery = \"/query/api/v1\";\n        this.basePathForProcess = \"/process/api/v1\";\n\n        return this;\n    };\n    DataServer.create = function (...args) {\n        trace(\"DataServer.create\");\n        return new this(...args);\n    };\n    DataServer.initialize = function (...args) {\n        trace(\"DataServer.initialize\");\n        return (new this(...args)).initialize();\n    };\n    DataServer.prototype.addService = function (...args) {\n        trace(\"DataServer.prototype.addService\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicServiceFactory()\n        const service = constructorFunction;\n        Object.assign(service, { ...DataService }, { ...staticInterface });\n        Object.assign(service.prototype, { ...DataService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticServiceInterface(service);\n        RestUtils.validateDynamicServiceInterface(service.prototype);\n        this.services.push(service);\n        return this;\n    };\n    DataServer.prototype.addQuery = function (...args) {\n        trace(\"DataServer.prototype.addQuery\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicQueryFactory()\n        const queryClass = constructorFunction;\n        Object.assign(queryClass, { ...QueryService }, { ...staticInterface });\n        Object.assign(queryClass.prototype, { ...QueryService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticQueryInterface(queryClass);\n        RestUtils.validateDynamicQueryInterface(queryClass.prototype);\n        this.queries.push(queryClass);\n        return this;\n    };\n    DataServer.prototype.addProcess = function (...args) {\n        trace(\"DataServer.prototype.addProcess\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicProcessFactory()\n        const processClass = constructorFunction;\n        Object.assign(processClass, { ...ProcessService }, { ...staticInterface });\n        Object.assign(processClass.prototype, { ...ProcessService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticProcessInterface(processClass);\n        RestUtils.validateDynamicProcessInterface(processClass.prototype);\n        this.processes.push(processClass);\n        return this;\n    };\n    const RequestPolyfill = function (method, url, others = {}) {\n        trace(\"RequestPolyfill.constructor\");\n        this.method = method;\n        this.url = url;\n        Object.assign(this, others);\n        return this;\n    }\n    const ResponsePolyfill = function () {\n        trace(\"ResponsePolyfill.constructor\");\n        this.output = { status: 200, headers: {}, data: \"\", json: true };\n        this.response_promise = new Promise((ok, fail) => {\n            this.solve_response = ok;\n            this.fail_response = fail;\n        }).then(finalResponse => {\n            if (finalResponse.status < 300 && finalResponse.status >= 200) {\n                return finalResponse;\n            }\n            throw finalResponse;\n        });\n        this.writeHead = (statusCode, headers = {}) => {\n            trace(\"ResponsePolyfill.prototype.writeHead\");\n            this.output.status = statusCode;\n            Object.assign(this.output.headers, headers);\n            return this;\n        };\n        this.write = (contents) => {\n            trace(\"ResponsePolyfill.prototype.write\");\n            this.output.data += contents;\n            return this;\n        };\n        this.end = (contents = \"\") => {\n            trace(\"ResponsePolyfill.prototype.end\");\n            this.output.data += contents;\n            if (this.output.json === true) {\n                try {\n                    this.output.data = JSON.parse(this.output.data);\n                } catch (error) {\n\n                }\n            }\n            if (this.output.status < 300 && this.output.status >= 200) {\n                this.output.statusText = \"OK\";\n            } else {\n                this.output.statusText = \"Erroneous\";\n                this.output.name = this.output.data.error.name;\n                this.output.message = this.output.data.error.message;\n                this.output.stack = this.output.data.error.stack;\n            }\n            this.output.response = Object.assign({}, this.output);\n            return this.solve_response(this.output);\n        };\n        return this;\n    }\n    DataServer.prototype.dispatch = function (request, response, fallback = RestUtils.basicControllerFallback) {\n        trace(\"DataServer.prototype.dispatch\");\n        try {\n            const path = RestUtils.require(\"path\");\n            const url = RestUtils.require(\"url\");\n            const parsedUrl = url.parse(request.url);\n            if (parsedUrl.pathname.startsWith(this.basePathForData)) {\n                for (let index = 0; index < this.services.length; index++) {\n                    const service = this.services[index];\n                    const serviceUrl = path.join(this.basePathForData, service.path) + \"/\";\n                    if (parsedUrl.pathname.startsWith(serviceUrl)) {\n                        trace(\"Dispatching by data service on: \" + parsedUrl.pathname);\n                        const serviceInstance = service.create({\n                            server: this\n                        });\n                        return serviceInstance.dispatch(request, response);\n                    }\n                }\n            } else if (parsedUrl.pathname.startsWith(this.basePathForAuth)) {\n                trace(\"Dispatching by auth service on: \" + parsedUrl.pathname);\n                return this.auth.dispatch(request, response, fallback);\n            } else if (parsedUrl.pathname.startsWith(this.basePathForQuery)) {\n                trace(\"Dispatching by query service on: \" + parsedUrl.pathname);\n                const queryId = \"/\" + parsedUrl.pathname.replace(this.basePathForQuery, \"\").split(\"/\").filter(it => it !== \"\").join(\"/\");\n                const matchedServices = this.queries.filter(x => x.path === queryId);\n                if (matchedServices.length === 0) {\n                    throw new Error(\"Required parameter «queryId» to be a known query in order to «DataServer.prototype.dispatch» (passed: «\" + queryId + \"») (available: «\" + this.queries.map(x => x.path).join(\"» «\") + \"»)\");\n                }\n                const [queryServiceClass] = matchedServices;\n                const queryService = queryServiceClass.create({ server: this });\n                return queryService.dispatch(request, response, fallback);\n            } else if (parsedUrl.pathname.startsWith(this.basePathForProcess)) {\n                trace(\"Dispatching by process service on: \" + parsedUrl.pathname);\n                const processId = \"/\" + parsedUrl.pathname.replace(this.basePathForProcess, \"\").split(\"/\").filter(it => it !== \"\").join(\"/\");\n                const matchedServices = this.processes.filter(x => x.path === processId);\n                if (matchedServices.length === 0) {\n                    throw new Error(\"Required parameter «processId» to be a known process in order to «DataServer.prototype.dispatch» (passed: «\" + processId + \"») (available: «\" + this.processes.map(x => x.path).join(\"» «\") + \"»)\");\n                }\n                const [processServiceClass] = matchedServices;\n                const processService = processServiceClass.create({ server: this });\n                return processService.dispatch(request, response, fallback);\n            }\n            trace(\"Dispatching by fallback on: \" + serviceUrl);\n            return fallback(request, response);\n        } catch (error) {\n            return this.onDispatchError(error, request, response);\n        }\n    };\n    DataServer.prototype.createDispatcher = function (fallback = RestUtils.basicControllerFallback) {\n        trace(\"DataServer.prototype.createDispatcher\");\n        return (request, response) => this.dispatch(request, response, fallback);\n    };\n    DataServer.prototype.createHttpServerController = function () {\n        trace(\"DataServer.prototype.createHttpServerController\");\n        const dispatcher = this.createDispatcher();\n        return (request, response) => dispatcher(request, response);\n    };\n    DataServer.prototype.createHttpServer = function (fallback = RestUtils.basicControllerFallback) {\n        trace(\"DataServer.prototype.createHttpServer\");\n        this.httpServer = RestUtils.require(\"http\").createServer(this.createHttpServerController());\n        return this.httpServer;\n    };\n    DataServer.prototype.listen = function (options) {\n        trace(\"DataServer.prototype.listen\");\n        return new Promise((ok, fail) => {\n            const httpServer = this.httpServer || this.createHttpServer();\n            try {\n                httpServer.listen(options, () => {\n                    return ok(httpServer);\n                });\n            } catch (error) {\n                return fail(error);\n            }\n        });\n    };\n    DataServer.prototype.stopDatabaseConnection = function () {\n        trace(\"DataServer.prototype.stopDatabaseConnection\");\n        return this.rest.connection.end();\n    };\n    DataServer.prototype.stopHttpServer = function () {\n        trace(\"DataServer.prototype.stopHttpServer\");\n        return this.httpServer.close();\n    };\n    DataServer.prototype.resetDatabase = function () {\n        trace(\"DataServer.prototype.resetDatabase\");\n        return this.rest.resetDatabase();\n    };\n    DataServer.prototype.resetAuth = function () {\n        trace(\"DataServer.prototype.resetAuth\");\n        return this.auth.resetAuth();\n    };\n    DataServer.prototype.dispatchSelf = function (method = \"get\", url = \"/\", requestArgs = {}, responseArgs = {}) {\n        throw new Error(\"Required method «dispatchSelf» to be overriden\");\n    };\n    DataServer.prototype.createClient = function (baseUrl = undefined) {\n        trace(\"DataServer.prototype.createClient\");\n        if (typeof baseUrl !== \"string\") {\n            throw new Error(\"Required argument «baseUrl» to be a string in order to «createClient»\");\n        }\n        return new RestClient(baseUrl, { server: this });\n    };\n    DataServer.prototype.initialize = async function () {\n        try {\n            trace(\"DataServer.prototype.initialize\");\n            await this.initializeRest();\n            await this.initializeAuth();\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    DataServer.prototype.initializeRest = async function () {\n        try {\n            trace(\"DataServer.prototype.initializeRest\");\n            let restAdapter = undefined;\n            if (typeof this.adapter !== \"string\") {\n                this.adapter = \"mysql\";\n            }\n            // @TOCONTINUE: continue adding other REST adapters on the following conditional:\n            if (this.adapter === \"mysql\") {\n                if (typeof this.credentials !== \"object\") {\n                    throw new Error(\"Required parameter «this.credentials» to be an object in order to «initalizeRest» (on 'mysql' REST adapter)\");\n                }\n                restAdapter = new RestByMySQL({\n                    credentials: this.credentials,\n                }, {\n                    ...this.restExtension,\n                    server: this,\n                });\n            } else {\n                throw new Error(\"Required configuration «this.adapter» to be a valid option in order to «initializeRest»\");\n            }\n            // @OK!\n            this.rest = await restAdapter.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    DataServer.prototype.initializeAuth = async function () {\n        try {\n            trace(\"DataServer.prototype.initializeAuth\");\n            let authAdapter = undefined;\n            if (typeof this.adapter !== \"string\") {\n                this.adapter = \"mysql\";\n            }\n            // @TOCONTINUE: continue adding other AUTH adapters on the following conditional:\n            if (this.adapter === \"mysql\") {\n                if (typeof this.credentials !== \"object\") {\n                    throw new Error(\"Required parameter «this.credentials» to be an object in order to «initializeAuth» (on 'mysql' REST adapter)\");\n                }\n                authAdapter = new AuthByMySQL({\n                    credentials: this.credentials,\n                }, {\n                    ...this.authExtension,\n                    server: this,\n                });\n            } else {\n                throw new Error(\"Required parameter «adapter» to be a valid option in order to «initializeRest»\");\n            }\n            // @OK!\n            this.auth = await authAdapter.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 5. DataService class:\n    const DataService = function (dynamicInterface = {}) {\n        trace(\"DataService.constructor\");\n        Object.assign(this, dynamicInterface);\n        return this;\n    };\n    DataService.create = function (...args) {\n        trace(\"DataService.create\");\n        return new this(...args);\n    };\n    DataService.initialize = function (...args) {\n        trace(\"DataService.initialize\");\n        return (new this(...args)).initialize();\n    };\n    DataService.path = \"/customize/path/here\";\n    DataService.prototype.initialize = async function () {\n        try {\n            trace(\"DataService.prototype.initialize\");\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    DataService.prototype.generateContext = RestUtils.generateContextByRequestResponseFactory(\"DataService.prototype.generateContext\");\n    DataService.prototype.dispatch = function (request, response) {\n        trace(\"DataService.prototype.dispatch\");\n        const parsedUrl = RestUtils.require(\"url\").parse(request.url);\n        if (parsedUrl.pathname.startsWith(this.server.basePathForData)) {\n            const actionPath = parsedUrl.pathname.replace(this.server.basePathForData, \"\").replace(this.constructor.path, \"\");\n            if (false) {\n                return false;\n            } else if (actionPath === \"/define\") {\n                return this.dispatchDefine(request, response);\n            } else if (actionPath === \"/select/one\") {\n                return this.dispatchSelectOne(request, response);\n            } else if (actionPath === \"/select/many\") {\n                return this.dispatchSelectMany(request, response);\n            } else if (actionPath === \"/insert/one\") {\n                return this.dispatchInsertOne(request, response);\n            } else if (actionPath === \"/insert/many\") {\n                return this.dispatchInsertMany(request, response);\n            } else if (actionPath === \"/update/one\") {\n                return this.dispatchUpdateOne(request, response);\n            } else if (actionPath === \"/update/many\") {\n                return this.dispatchUpdateMany(request, response);\n            } else if (actionPath === \"/delete/one\") {\n                return this.dispatchDeleteOne(request, response);\n            } else if (actionPath === \"/delete/many\") {\n                return this.dispatchDeleteMany(request, response);\n            } else if (actionPath === \"/get/file\") {\n                return this.dispatchGetFile(request, response);\n            } else if (actionPath === \"/set/file\") {\n                return this.dispatchSetFile(request, response);\n            } else {\n                return this.onDispatchError(new Error(\"Required action path to be valid in order to «dispatch» (passed: «\" + actionPath + \"»)\"), request, response);\n            }\n        } else {\n            return this.onDispatchError(new Error(\"Required url path to be valid in order to «dispatch» (passed: «\" + parsedUrl.pathname + \"»)\"), request, response);\n        }\n    };\n    DataService.prototype.dispatchDefine = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchDefine\");\n            const context = this.generateContext(request, response);\n            await this.onDefine(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchSelectOne = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchSelectOne\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForSelectOne(context);\n            await this.onQueryForSelectOne(context);\n            await this.onFormatOutputForSelectOne(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchSelectMany = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchSelectMany\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForSelectMany(context);\n            await this.onQueryForSelectMany(context);\n            await this.onFormatOutputForSelectMany(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchInsertOne = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchInsertOne\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForInsertOne(context);\n            await this.onQueryForInsertOne(context);\n            await this.onFormatOutputForInsertOne(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchInsertMany = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchInsertMany\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForInsertMany(context);\n            await this.onQueryForInsertMany(context);\n            await this.onFormatOutputForInsertMany(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchUpdateOne = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchUpdateOne\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForUpdateOne(context);\n            await this.onQueryForUpdateOne(context);\n            await this.onFormatOutputForUpdateOne(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchUpdateMany = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchUpdateMany\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForUpdateMany(context);\n            await this.onQueryForUpdateMany(context);\n            await this.onFormatOutputForUpdateMany(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchDeleteOne = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchDeleteOne\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForDeleteOne(context);\n            await this.onQueryForDeleteOne(context);\n            await this.onFormatOutputForDeleteOne(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchDeleteMany = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchDeleteMany\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForDeleteMany(context);\n            await this.onQueryForDeleteMany(context);\n            await this.onFormatOutputForDeleteMany(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchGetFile = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchGetFile\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForGetFile(context);\n            await this.onQueryForGetFile(context);\n            await this.onServeFile(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    DataService.prototype.dispatchSetFile = async function (request, response) {\n        try {\n            trace(\"DataService.prototype.dispatchSetFile\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForSetFile(context);\n            await this.onQueryForSetFile(context);\n            await this.onPersistFile(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n\n    //////////////////////////////////////////////////////\n    // (01) Service for SELECT ONE:\n    DataService.prototype.onFormatParametersForSelectOne = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForSelectOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n        return true;\n    };\n    DataService.prototype.onQueryForSelectOne = function (context) {\n        trace(\"DataService.prototype.onQueryForSelectOne\");\n        return this.server.rest.selectOne(context.parameters.table, {\n            where: context.parameters.where\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForSelectOne = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForSelectOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/select/one\",\n                model: this.constructor.table,\n                action: \"/select/one\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (02) Service for SELECT MANY:\n    DataService.prototype.onFormatParametersForSelectMany = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForSelectMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        context.parameters.order = RestUtils.formatOrderFromRequest(context);\n        context.parameters.group = RestUtils.formatGroupFromRequest(context);\n        context.parameters.pagination = RestUtils.formatPaginationFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForSelectMany = function (context) {\n        trace(\"DataService.prototype.onQueryForSelectMany\");\n        return this.server.rest.selectMany(context.parameters.table, {\n            where: context.parameters.where,\n            order: context.parameters.order,\n            group: context.parameters.group,\n            pagination: context.parameters.pagination,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForSelectMany = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForSelectMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/select/many\",\n                model: this.constructor.table,\n                action: \"/select/many\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (03) Service for INSERT ONE:\n    DataService.prototype.onFormatParametersForInsertOne = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForInsertOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.item = RestUtils.formatItemFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForInsertOne = function (context) {\n        trace(\"DataService.prototype.onQueryForInsertOne\");\n        return this.server.rest.insertOne(context.parameters.table, {\n            item: context.parameters.item,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForInsertOne = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForInsertOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/insert/one\",\n                model: this.constructor.table,\n                action: \"/insert/one\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (04) Service for INSERT MANY:\n    DataService.prototype.onFormatParametersForInsertMany = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForInsertMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        console.log(context);\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.items = RestUtils.formatItemsFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForInsertMany = function (context) {\n        trace(\"DataService.prototype.onQueryForInsertMany\");\n        return this.server.rest.insertMany(context.parameters.table, {\n            items: context.parameters.items,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForInsertMany = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForInsertMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/insert/many\",\n                model: this.constructor.table,\n                action: \"/insert/many\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (05) Service for UPDATE ONE:\n    DataService.prototype.onFormatParametersForUpdateOne = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForUpdateOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        context.parameters.values = RestUtils.formatValuesFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForUpdateOne = function (context) {\n        trace(\"DataService.prototype.onQueryForUpdateOne\");\n        return this.server.rest.updateOne(context.parameters.table, {\n            where: context.parameters.where,\n            values: context.parameters.values,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForUpdateOne = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForUpdateOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/update/one\",\n                model: this.constructor.table,\n                action: \"/update/one\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (06) Service for UPDATE MANY:\n    DataService.prototype.onFormatParametersForUpdateMany = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForUpdateMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        context.parameters.values = RestUtils.formatValuesFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForUpdateMany = function (context) {\n        trace(\"DataService.prototype.onQueryForUpdateMany\");\n        return this.server.rest.updateMany(context.parameters.table, {\n            where: context.parameters.where,\n            values: context.parameters.values,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForUpdateMany = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForUpdateMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/update/many\",\n                model: this.constructor.table,\n                action: \"/update/many\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (07) Service for DELETE ONE:\n    DataService.prototype.onFormatParametersForDeleteOne = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForDeleteOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForDeleteOne = function (context) {\n        trace(\"DataService.prototype.onQueryForDeleteOne\");\n        return this.server.rest.deleteOne(context.parameters.table, {\n            where: context.parameters.where,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForDeleteOne = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForDeleteOne\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/delete/one\",\n                model: this.constructor.table,\n                action: \"/delete/one\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (08) Service for DELETE MANY:\n    DataService.prototype.onFormatParametersForDeleteMany = async function (context) {\n        trace(\"DataService.prototype.onFormatParametersForDeleteMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::before\", { context });\n        context.parameters.table = this.constructor.table;\n        context.parameters.path = this.constructor.path;\n        context.parameters.where = RestUtils.formatWhereFromRequest(context);\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatParameters::after\", { context });\n    };\n    DataService.prototype.onQueryForDeleteMany = function (context) {\n        trace(\"DataService.prototype.onQueryForDeleteMany\");\n        return this.server.rest.deleteMany(context.parameters.table, {\n            where: context.parameters.where,\n        }).then(data => {\n            context.state.queryResults = data;\n            return data;\n        });\n    };\n    DataService.prototype.onFormatOutputForDeleteMany = async function (context) {\n        trace(\"DataService.prototype.onFormatOutputForDeleteMany\");\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::before\", { context });\n        context.output = {\n            data: context.state.queryResults,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/delete/many\",\n                model: this.constructor.table,\n                action: \"/delete/many\",\n            }\n        };\n        await this.server.hooks.useHook(\"service://\" + context.input.url.replace(/^\\//g, \"\") + \"@onFormatOutput::after\", { context });\n    };\n\n    //////////////////////////////////////////////////////\n    // (09) Service for GET FILE:\n    DataService.prototype.onFormatParametersForGetFile = function (context) {\n        trace(\"DataService.prototype.onFormatParametersForGetFile\");\n    };\n    DataService.prototype.onQueryForGetFile = function (context) {\n        trace(\"DataService.prototype.onQueryForGetFile\");\n    };\n    DataService.prototype.onServeFile = function (context) {\n        trace(\"DataService.prototype.onServeFile\");\n        throw new Error(\"Required «DataService.prototype.onServeFile» to be overriden\");\n    };\n\n    //////////////////////////////////////////////////////\n    // (10) Service for SET FILE:\n    DataService.prototype.onFormatParametersForSetFile = function (context) {\n        trace(\"DataService.prototype.onFormatParametersForSetFile\");\n    };\n    DataService.prototype.onQueryForSetFile = function (context) {\n        trace(\"DataService.prototype.onQueryForSetFile\");\n    };\n    DataService.prototype.onPersistFile = function (context) {\n        trace(\"DataService.prototype.onPersistFile\");\n        throw new Error(\"Required «DataService.prototype.onPersistFile» to be overriden\");\n    };\n    DataService.prototype.onRespond = function (context) {\n        trace(\"DataService.prototype.onRespond\");\n        return RestUtils.respondContext(context);\n    };\n    DataService.prototype.onDefine = function (context) {\n        trace(\"DataService.prototype.onDefine\");\n        const publicFieldIds = this.constructor.publicFields || [\"id\", \"path\", \"table\", \"class\", \"schema\"];\n        const data = {};\n        for (let index = 0; index < publicFieldIds.length; index++) {\n            const publicFieldId = publicFieldIds[index];\n            data[publicFieldId] = this.constructor[publicFieldId];\n        }\n        context.output = {\n            data,\n            metadata: {\n                path: this.server.basePathForData + this.constructor.path + \"/define\",\n                model: this.constructor.table,\n                action: \"/define\",\n            }\n        };\n    };\n    DataService.prototype.setServer = function (server) {\n        trace(\"DataService.prototype.setServer\");\n        this.server = server;\n        return this;\n    };\n\n\n    const QueryService = function (dynamicInterface = {}) {\n        trace(\"QueryService.constructor\");\n        Object.assign(this, dynamicInterface);\n        return this;\n    };\n    QueryService.create = function (...args) {\n        return new this(...args);\n    };\n    QueryService.prototype = { ...DataService.prototype };\n    QueryService.prototype.getParametersByURL = function (url) {\n        trace(\"QueryService.prototype.getParametersByURL\");\n        const parsedUrl = RestUtils.require(\"url\").parse(url);\n        const urlStarter = RestUtils.require(\"path\").join(this.server.basePathForQuery, this.constructor.path);\n        const extraPath = parsedUrl.pathname.replace(urlStarter, \"\");\n        return extraPath;\n    };\n    QueryService.prototype.serve = function (status, headers, body, response) {\n        trace(\"QueryService.prototype.serve\");\n        const responseHeaders = Object.assign({ \"Content-type\": \"application/json\" }, headers);\n        response.writeHead(status, responseHeaders);\n        response.write(typeof body === \"string\" ? body : JSON.stringify(body));\n        return response.end();\n    };\n    QueryService.prototype.onDispatchQuery = function (request, response, fallback) {\n        trace(\"QueryService.prototype.onDispatchQuery\");\n        return this.constructor.query.call(this, request, response, fallback);\n    };\n    QueryService.prototype.dispatch = function (request, response, fallback = RestUtils.noop) {\n        trace(\"QueryService.prototype.dispatch\");\n        const parsedUrl = RestUtils.require(\"url\").parse(request.url);\n        const urlStarter = RestUtils.require(\"path\").join(this.server.basePathForQuery, this.constructor.path);\n        if (parsedUrl.pathname.startsWith(urlStarter)) {\n            return this.onDispatchQuery(request, response, fallback);\n        } else {\n            return this.onDispatchError(new Error(\"Required url path to be valid in order to «QueryService.prototype.dispatch» (passed: «\" + parsedUrl.pathname + \"») (valid: «\" + urlStarter + \"»)\"), request, response);\n        }\n    };\n    const ProcessService = function (dynamicInterface = {}) {\n        trace(\"ProcessService.constructor\");\n        Object.assign(this, dynamicInterface);\n        return this;\n    };\n    ProcessService.create = function (...args) {\n        return new this(...args);\n    };\n    ProcessService.prototype = { ...DataService.prototype };\n    ProcessService.prototype.getParametersByURL = function (url) {\n        trace(\"ProcessService.prototype.getParametersByURL\");\n        const parsedUrl = RestUtils.require(\"url\").parse(url);\n        const urlStarter = RestUtils.require(\"path\").join(this.server.basePathForQuery, this.constructor.path);\n        const extraPath = parsedUrl.pathname.replace(urlStarter, \"\");\n        return extraPath;\n    };\n    ProcessService.prototype.serve = function (status, headers, body, response) {\n        trace(\"ProcessService.prototype.serve\");\n        const responseHeaders = Object.assign({ \"Content-type\": \"application/json\" }, headers);\n        response.writeHead(status, responseHeaders);\n        response.write(typeof body === \"string\" ? body : JSON.stringify(body));\n        return response.end();\n    };\n    ProcessService.prototype.onDispatchProcess = function (request, response, fallback) {\n        trace(\"ProcessService.prototype.onDispatchProcess\");\n        return this.constructor.process.call(this, request, response, fallback);\n        const parsedUrl = RestUtils.require(\"url\").parse(request.url);\n        const urlStarter = RestUtils.require(\"path\").join(this.server.basePathForProcess, this.constructor.path);\n        const extraPath = parsedUrl.pathname.replace(urlStarter, \"\");\n        response.writeHead(200, { \"Content-Type\": \"application/json\" });\n        response.write(JSON.stringify({\n            process: urlStarter,\n            subroute: extraPath\n        }));\n        return response.end();\n    };\n    ProcessService.prototype.dispatch = function (request, response, fallback = RestUtils.noop) {\n        trace(\"ProcessService.prototype.dispatch\");\n        const parsedUrl = RestUtils.require(\"url\").parse(request.url);\n        const urlStarter = RestUtils.require(\"path\").join(this.server.basePathForProcess, this.constructor.path);\n        if (parsedUrl.pathname.startsWith(urlStarter)) {\n            return this.onDispatchProcess(request, response, fallback);\n        } else {\n            return this.onDispatchError(new Error(\"Required url path to be valid in order to «ProcessService.prototype.dispatch» (passed: «\" + parsedUrl.pathname + \"») (valid: «\" + urlStarter + \"»)\"), request, response);\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 7. RestByMySQL class:\n    const RestByMySQL = function (options, extensions = {}) {\n        trace(\"RestByMySQL.constructor\");\n        if (typeof options !== \"object\") {\n            throw new Error(\"Required parameter «options» to be an object in order to «RestByMySQL.constructor»\");\n        }\n        if (typeof options.credentials !== \"object\") {\n            throw new Error(\"Required parameter «options.credentials» to be an object in order to «RestByMySQL.constructor»\");\n        }\n        if (typeof extensions !== \"object\") {\n            throw new Error(\"Required parameter «extensions» to be an object in order to «RestByMySQL.constructor»\");\n        }\n        this.credentials = options.credentials;\n        Object.assign(this, extensions);\n        return this;\n    };\n    Object.assign(RestByMySQL.prototype, { ...RestInterface.prototype });\n    RestByMySQL.prototype.initialize = async function () {\n        try {\n            trace(\"RestByMySQL.prototype.initialize\");\n            this.connection = await RestUtils.require(\"mysql2/promise\").createConnection(this.credentials);\n            this.connection = RestUtils.expandConnection(this.connection);\n            await this.connection.ping();\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.selectMany = async function (dataType, { where = [], order = [], groups = [], pagination = [1, 20] }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.selectMany\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const sanitizedGroup = RestUtils.fromGroupToSQL(groups);\n            const sanitizedOrder = RestUtils.fromOrderToSQL(order);\n            const sanitizedPagination = RestUtils.fromPaginationToSQL(pagination);\n            const query = [\n                `# Select many query:`,\n                `SELECT * `,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n                sanitizedGroup,\n                sanitizedOrder,\n                sanitizedPagination,\n            ].join(\"\\n\");\n            const resultsReport = await this.connection.proxifiedQuery(query);\n            const [results] = resultsReport;\n            const context = { dataType, where, order, groups, pagination, authentication, query, results };\n            await this.server.hooks.useHook(\"api://rest.selectMany::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.selectMany:\" + dataType + \"::after\", { context });\n            return results;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.selectOne = async function (dataType, { where = [] }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.selectOne\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const query = [\n                `# Select one query:`,\n                `SELECT * `,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const resultsReport = await this.connection.proxifiedQuery(query);\n            const [results] = resultsReport;\n            if (results.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.selectOne»\");\n            } else if (results.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.selectOne»\");\n            }\n            const context = { dataType, where, authentication, query, results };\n            await this.server.hooks.useHook(\"api://rest.selectOne::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.selectOne:\" + dataType + \"::after\", { context });\n            return results[0];\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.insertMany = async function (dataType, { items }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.insertMany\");\n            const sanitizedTable = dataType;\n            const sanitizedKeys = RestUtils.fromItemsToKeysSQL(items);\n            const sanitizedValues = RestUtils.fromItemsToValuesSQL(items);\n            const query = [\n                `# Insert many query:`,\n                `INSERT `,\n                `  INTO ${sanitizedTable} ${sanitizedKeys}`,\n                `  VALUES ${sanitizedValues}`,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                firstId: unsanitizedReport.insertId,\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, items, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.insertMany::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.insertMany:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.insertOne = async function (dataType, { item }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.insertOne\");\n            const sanitizedTable = dataType;\n            const sanitizedKeys = RestUtils.fromItemToKeysSQL(item);\n            const sanitizedValues = RestUtils.fromItemToValuesSQL(item);\n            const query = [\n                `# Insert one query:`,\n                `INSERT `,\n                `  INTO ${sanitizedTable} ${sanitizedKeys}`,\n                `  VALUES ${sanitizedValues}`,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                id: unsanitizedReport.insertId,\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, item, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.insertOne::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.insertOne:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.updateMany = async function (dataType, { where, values }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.updateMany\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const sanitizedSettables = RestUtils.fromItemToSettablesSQL(values);\n            const query = [\n                `# Update many query:`,\n                `UPDATE ${sanitizedTable}`,\n                `  SET ${sanitizedSettables}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, where, values, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.updateMany::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.updateMany:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.updateOne = async function (dataType, { where, values }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.updateOne\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const sanitizedSettables = RestUtils.fromItemToSettablesSQL(values);\n            const querySelectOne = [\n                `# Select one query (in order to update one):`,\n                `SELECT * `,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const [selectionReport] = await this.connection.proxifiedQuery(querySelectOne);\n            if (selectionReport.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.updateOne»\");\n            } else if (selectionReport.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.updateOne»\");\n            }\n            const query = [\n                `# Update one query:`,\n                `UPDATE ${sanitizedTable}`,\n                `  SET ${sanitizedSettables}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, where, values, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.updateOne::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.updateOne:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.deleteMany = async function (dataType, { where }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.deleteMany\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const query = [\n                `# Delete many query:`,\n                `DELETE`,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, where, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.deleteMany::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.deleteMany:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.deleteOne = async function (dataType, { where }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.deleteOne\");\n            const sanitizedTable = dataType;\n            const sanitizedWhere = RestUtils.fromWhereToSQL(where);\n            const querySelectOne = [\n                `# Select one query (in order to delete one):`,\n                `SELECT * `,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const [selectionReport] = await this.connection.proxifiedQuery(querySelectOne);\n            if (selectionReport.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.deleteOne»\");\n            } else if (selectionReport.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByMySQL.prototype.deleteOne»\");\n            }\n            const query = [\n                `# Delete one query:`,\n                `DELETE`,\n                `  FROM ${sanitizedTable}`,\n                `  WHERE 1 = 1`,\n                sanitizedWhere,\n            ].join(\"\\n\");\n            const results = await this.connection.proxifiedQuery(query);\n            const [unsanitizedReport] = results;\n            const sanitizedReport = {\n                rows: unsanitizedReport.affectedRows,\n            };\n            const context = { dataType, where, authentication, query, results, sanitizedReport };\n            await this.server.hooks.useHook(\"api://rest.deleteOne::after\", { context });\n            await this.server.hooks.useHook(\"api://rest.deleteOne:\" + dataType + \"::after\", { context });\n            return sanitizedReport;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.getFile = async function (dataType, { id, column }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.getFile\");\n            // @TODO...\n            // @TODO...\n            // @TODO...\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.setFile = async function (dataType, { id, column, file }, authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.setFile\");\n            // @TODO...\n            // @TODO...\n            // @TODO...\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByMySQL.prototype.resetDatabase = async function (authentication) {\n        try {\n            trace(\"RestByMySQL.prototype.resetDatabase\");\n            await this.connection.proxifiedQuery([\n                `DROP DATABASE IF EXISTS ${this.credentials.database};`\n            ].join(\"\\n\"));\n            await this.connection.proxifiedQuery([\n                `CREATE DATABASE ${this.credentials.database};`\n            ].join(\"\\n\"));\n            await this.connection.proxifiedQuery([\n                `USE ${this.credentials.database};`\n            ].join(\"\\n\"));\n            if (this.server.auth && this.server.auth.resetAuth) {\n                await this.server.auth.resetAuth();\n            }\n            const allServices = this.server.services;\n            for (let indexService = 0; indexService < allServices.length; indexService++) {\n                const serviceClass = allServices[indexService];\n                await (async (serviceClass) => {\n                    if (typeof serviceClass.creationScript === \"string\") {\n                        await this.connection.proxifiedQuery(serviceClass.creationScript);\n                    }\n                })(serviceClass);\n            }\n            if (typeof this.seeder === \"function\") {\n                await this.seeder(authentication);\n            }\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////\n    // 10. AuthByMySQL class:\n    const AuthByMySQL = function (options, extensions = {}) {\n        trace(\"AuthByMySQL.constructor\");\n        if (typeof options !== \"object\") {\n            throw new Error(\"Required parameter «options» to be an object in order to «AuthByMySQL.constructor»\");\n        }\n        if (typeof options.credentials !== \"object\") {\n            throw new Error(\"Required parameter «options.credentials» to be an object in order to «AuthByMySQL.constructor»\");\n        }\n        if (typeof extensions !== \"object\") {\n            throw new Error(\"Required parameter «extensions» to be an object in order to «AuthByMySQL.constructor»\");\n        }\n        this.credentials = options.credentials;\n        Object.assign(this, extensions);\n        return this;\n    };\n    Object.assign(AuthByMySQL.prototype, { ...AuthInterface });\n    AuthByMySQL.prototype.initialize = async function () {\n        try {\n            trace(\"AuthByMySQL.prototype.initialize\");\n            // @TODO...\n            // @TODO...\n            // @TODO...\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onRespond = function (context) {\n        trace(\"AuthByMySQL.prototype.onRespond\");\n        return RestUtils.respondContext(context);\n    };\n    AuthByMySQL.prototype.dispatch = async function (request, response, fallback = RestUtils.basicControllerFallback) {\n        trace(\"AuthByMySQL.prototype.dispatch\");\n        const parsedUrl = RestUtils.require(\"url\").parse(request.url);\n        if (parsedUrl.pathname.startsWith(this.server.basePathForAuth)) {\n            const actionPath = parsedUrl.pathname.replace(this.server.basePathForAuth, \"\").replace(this.constructor.path, \"\");\n            if (false) {\n                return false;\n            } else if (actionPath === \"/register\") {\n                return this.dispatchRegister(request, response);\n            } else if (actionPath === \"/confirm\") {\n                return this.dispatchConfirm(request, response);\n            } else if (actionPath === \"/login\") {\n                return this.dispatchLogin(request, response);\n            } else if (actionPath === \"/logout\") {\n                return this.dispatchLogout(request, response);\n            } else if (actionPath === \"/forgot\") {\n                return this.dispatchForgot(request, response);\n            } else if (actionPath === \"/recover\") {\n                return this.dispatchRecover(request, response);\n            } else if (actionPath === \"/unregister\") {\n                return this.dispatchUnregister(request, response);\n            } else if (actionPath === \"/modify\") {\n                return this.dispatchModify(request, response);\n            } else {\n                return this.onDispatchError(new Error(\"Required action path to be valid (and «\" + actionPath + \"» is not valid as auth service) in order to «dispatch»\"), request, response);\n            }\n        }\n        return fallback(request, response);\n    };\n    AuthByMySQL.prototype.generateContext = RestUtils.generateContextByRequestResponseFactory(\"AuthByMySQL.prototype.generateContext\");\n    AuthByMySQL.prototype.authenticate = async function (token) {\n        try {\n            trace(\"AuthByMySQL.prototype.authenticate\");\n            const sanitizedToken = RestUtils.sanitize(token);\n            const [matchedSessions] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_sessions WHERE token = ${sanitizedToken};`\n            ].join(\"\\n\"));\n            if (matchedSessions.length === 0) {\n                throw new Error(\"Required parameter «session_token» to be session a session token in order to «authenticate»\");\n            } else if (matchedSessions.length !== 1) {\n                throw new Error(\"Data corrupted by duplication of session token\");\n            }\n            const [matchedSession] = matchedSessions;\n            const sanitizedUserId = RestUtils.sanitize(matchedSession.id_user);\n            const [matchedUsers] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE id = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            if (matchedUsers.length === 0) {\n                throw new Error(\"Required parameter «session_token» to be session a session token in order to «authenticate»\");\n            } else if (matchedUsers.length !== 1) {\n                throw new Error(\"Data corrupted by duplication of session token\");\n            }\n            const [matchedUser] = matchedUsers;\n            let matchedGroups = undefined;\n            let matchedPrivileges = undefined;\n            const [matchedGroups1] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_groups WHERE auth_groups.id IN (SELECT DISTINCT id_group FROM auth_groups_of_users WHERE auth_groups_of_users.id_user IN (${sanitizedUserId}));`\n            ].join(\"\\n\"));\n            matchedGroups = matchedGroups1;\n            if (matchedGroups.length) {\n                const sanitizedGroupIds = matchedGroups.map(item => RestUtils.sanitize(item.id)).join(\", \");\n                const [matchedPrivileges1] = await this.server.rest.connection.proxifiedQuery([\n                    `SELECT * FROM auth_privileges WHERE auth_privileges.id IN (SELECT DISTINCT id_privilege FROM auth_privileges_of_groups WHERE auth_privileges_of_groups.id_group IN (${sanitizedGroupIds}));`\n                ].join(\"\\n\"));\n                matchedPrivileges = matchedPrivileges1;\n            }\n            return {\n                session: matchedSession,\n                user: matchedUser,\n                groups: matchedGroups,\n                privileges: matchedPrivileges,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.dispatchRegister = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchRegister\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForRegister(context);\n            context.state.operationResults = await this.onRegister(context);\n            await this.onFormatOutputForRegister(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchConfirm = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchConfirm\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForConfirm(context);\n            context.state.operationResults = await this.onConfirm(context);\n            await this.onFormatOutputForConfirm(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchLogin = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchLogin\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForLogin(context);\n            context.state.operationResults = await this.onLogin(context);\n            await this.onFormatOutputForLogin(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchLogout = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchLogout\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForLogout(context);\n            context.state.operationResults = await this.onLogout(context);\n            await this.onFormatOutputForLogout(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchForgot = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchForgot\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForForgot(context);\n            context.state.operationResults = await this.onForgot(context);\n            await this.onFormatOutputForForgot(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchRecover = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchRecover\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForRecover(context);\n            context.state.operationResults = await this.onRecover(context);\n            await this.onFormatOutputForRecover(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchUnregister = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchUnregister\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForUnregister(context);\n            context.state.operationResults = await this.onUnregister(context);\n            await this.onFormatOutputForUnregister(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.dispatchModify = async function (request, response) {\n        try {\n            trace(\"AuthByMySQL.prototype.dispatchModify\");\n            const context = this.generateContext(request, response);\n            await this.onFormatParametersForModify(context);\n            context.state.operationResults = await this.onModify(context);\n            await this.onFormatOutputForModify(context);\n            await this.onRespond(context);\n        } catch (error) {\n            this.onDispatchError(error, request, response);\n        }\n    };\n    AuthByMySQL.prototype.onRegister = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onRegister\");\n            return await this.register(context.parameters.user, context.parameters.password, context.parameters.email);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onConfirm = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onConfirm\");\n            return await this.confirm(context.parameters.confirmationToken);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onLogin = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onLogin\");\n            return await this.login(context.parameters.user, context.parameters.password);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onLogout = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onLogout\");\n            return await this.logout(context.parameters.session_token);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onForgot = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onForgot\");\n            return await this.forgot(context.parameters.user);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onRecover = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onRecover\");\n            return await this.recover(context.parameters.recovery_token);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onUnregister = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onUnregister\");\n            return await this.unregister(context.parameters.session_token, context.parameters.user, context.parameters.password);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onModify = async function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onModify\");\n            return await this.modify(context.parameters.session_token, context.parameters.user, context.parameters.password);\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatParametersForRegister = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForRegister\");\n            context.parameters.user = context.input.query.user;\n            context.parameters.password = context.input.query.password;\n            context.parameters.email = context.input.query.email;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForRegister = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForRegister\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/register\",\n                    action: \"/register\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForConfirm = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForConfirm\");\n            context.parameters.confirmationToken = context.input.query.confirmation_token;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForConfirm = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForConfirm\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/confirm\",\n                    action: \"/confirm\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForLogin = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForLogin\");\n            context.parameters.user = context.input.query.user;\n            context.parameters.password = context.input.query.password;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForLogin = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForLogin\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/login\",\n                    action: \"/login\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForLogout = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForLogout\");\n            context.parameters.session_token = context.input.query.session_token;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForLogout = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForLogout\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/logout\",\n                    action: \"/logout\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForForgot = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForForgot\");\n            context.parameters.user = context.input.query.user;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForForgot = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForForgot\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/forgot\",\n                    action: \"/forgot\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForRecover = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForRecover\");\n            context.parameters.recovery_token = context.input.query.recovery_token;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForRecover = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForRecover\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/recover\",\n                    action: \"/recover\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForUnregister = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForUnregister\");\n            context.parameters.user = context.input.query.user;\n            context.parameters.password = context.input.query.password;\n            context.parameters.session_token = context.input.query.session_token;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForUnregister = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForUnregister\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/unregister\",\n                    action: \"/unregister\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    AuthByMySQL.prototype.onFormatParametersForModify = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatParametersForModify\");\n            context.parameters.session_token = context.input.query.session_token;\n            context.parameters.user = context.input.query.user;\n            context.parameters.password = context.input.query.password;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.onFormatOutputForModify = function (context) {\n        try {\n            trace(\"AuthByMySQL.prototype.onFormatOutputForModify\");\n            context.output = {\n                data: context.state.operationResults,\n                metadata: {\n                    path: this.server.basePathForAuth + \"/modify\",\n                    action: \"/modify\",\n                }\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.register = async function (user, password, email) {\n        try {\n            trace(\"AuthByMySQL.prototype.register\");\n            if (typeof user !== \"string\") {\n                throw new Error(\"Required parameter «user» to be a «string» in order to «register»\");\n            }\n            if (typeof password !== \"string\") {\n                throw new Error(\"Required parameter «password» to be a «string» in order to «register»\");\n            }\n            if (typeof email !== \"string\") {\n                throw new Error(\"Required parameter «email» to be a «string» in order to «register»\");\n            }\n            const sanitizedUser = RestUtils.sanitize(user);\n            const sanitizedEmail = RestUtils.sanitize(email);\n            const [coincidentNames] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE name = ${sanitizedUser};`\n            ].join(\"\\n\"));\n            if (coincidentNames.length) {\n                throw new Error(\"Required parameter «name» to be unique in order to «register»\");\n            }\n            const [coincidentEmails] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE email = ${sanitizedEmail};`\n            ].join(\"\\n\"));\n            if (coincidentEmails.length) {\n                throw new Error(\"Required parameter «email» to be unique in order to «register»\");\n            }\n            const sanitizedPassword = RestUtils.sanitize(password);\n            const confirmationToken = RestUtils.generateRandomToken(20);\n            const sanitizedConfirmationToken = RestUtils.sanitize(confirmationToken);\n            const [{ insertId }] = await this.server.rest.connection.proxifiedQuery([\n                `INSERT INTO auth_pending_users (name, password, email, confirmation_token) VALUES (${sanitizedUser},${sanitizedPassword},${sanitizedEmail},${sanitizedConfirmationToken});`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully registered\",\n                // pending_user_id: insertId,\n                confirmation_token: confirmationToken,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.confirm = async function (confirmationToken) {\n        try {\n            trace(\"AuthByMySQL.prototype.confirm\");\n            if (typeof confirmationToken !== \"string\") {\n                throw new Error(\"Required parameter «confirmation_token» to be a «string» in order to «confirm»\");\n            }\n            const sanitizedConfirmationToken = RestUtils.sanitize(confirmationToken);\n            const [pendingUsers] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_pending_users WHERE 1=1 AND confirmation_token = ${sanitizedConfirmationToken};`\n            ].join(\"\\n\"));\n            if (pendingUsers.length === 0) {\n                throw new Error(\"Required parameter «confirmation_token» to match an existing pending users confirmation token in order to «confirm»\");\n            } else if (pendingUsers.length !== 1) {\n                throw new Error(\"Data corrupted by duplication of confirmation_token of user\");\n            }\n            const [userData] = pendingUsers;\n            const sanitizedName = RestUtils.sanitize(userData.name);\n            const sanitizedPassword = RestUtils.sanitize(userData.password);\n            const sanitizedEmail = RestUtils.sanitize(userData.email);\n            await this.server.rest.connection.proxifiedQuery([\n                `INSERT INTO auth_users (name, password, email) VALUES (${sanitizedName},${sanitizedPassword},${sanitizedEmail});`\n            ].join(\"\\n\"));\n            const sanitizedId = RestUtils.sanitize(userData.id);\n            await this.server.rest.connection.proxifiedQuery([\n                `DELETE FROM auth_pending_users WHERE id = ${sanitizedId};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully confirmed\"\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.login = async function (user, password) {\n        try {\n            trace(\"AuthByMySQL.prototype.login\");\n            // @TODO......................................\n            let sessionToken = undefined;\n            if (typeof user !== \"string\") {\n                throw new Error(\"Required parameter «user» to be a «string» in order to «login»\");\n            }\n            if (typeof password !== \"string\") {\n                throw new Error(\"Required parameter «password» to be a «string» in order to «login»\");\n            }\n            const sanitizedUser = RestUtils.sanitize(user);\n            const [users] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE 1=1 AND name = ${sanitizedUser};`\n            ].join(\"\\n\"));\n            if (users.length === 0) {\n                throw new Error(\"Required parameter «user» to match an existing user in order to «login»\");\n            } else if (users.length !== 1) {\n                throw new Error(\"Data corrupted by duplication of name of user\");\n            }\n            const [matchedUser] = users;\n            if (matchedUser.password !== password) {\n                throw new Error(\"Required parameter «password» to be the user password in order to «login»\");\n            }\n            const userId = matchedUser.id;\n            const sanitizedUserId = RestUtils.sanitize(userId);\n            const [sessionsResults] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_sessions WHERE 1=1 AND id_user = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            if (sessionsResults.length === 0) {\n                sessionToken = RestUtils.generateRandomToken(20);\n                const sanitizedSessionToken = RestUtils.sanitize(sessionToken);\n                await this.server.rest.connection.proxifiedQuery([\n                    `INSERT INTO auth_sessions (id_user, token) VALUES (${sanitizedUserId}, ${sanitizedSessionToken});`\n                ].join(\"\\n\"));\n            } else {\n                sessionToken = sessionsResults[0].token;\n            }\n            const authentication = await this.authenticate(sessionToken);\n            return {\n                message: \"user successfully logged in\",\n                session_token: sessionToken,\n                authentication,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.logout = async function (sessionToken) {\n        try {\n            trace(\"AuthByMySQL.prototype.logout\");\n            const sanitizedSessionToken = RestUtils.sanitize(sessionToken);\n            const [sessionsResults] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_sessions WHERE 1=1 AND token = ${sanitizedSessionToken};`\n            ].join(\"\\n\"));\n            if (sessionsResults.length === 0) {\n                throw new Error(\"Required parameter «session_token» to be a session token in order to «logout»\");\n            } else if (sessionsResults.length !== 1) {\n                throw new Error(\"Data corrupted by session token duplication\");\n            }\n            const [matchedSession] = sessionsResults;\n            const sanitizedSessionId = RestUtils.sanitize(matchedSession.id);\n            await this.server.rest.connection.proxifiedQuery([\n                `DELETE FROM auth_sessions WHERE 1=1 AND id = ${sanitizedSessionId};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully logged out\",\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.forgot = async function (user) {\n        try {\n            trace(\"AuthByMySQL.prototype.forgot\");\n            const token = RestUtils.generateRandomToken(20);\n            const sanitizedUser = RestUtils.sanitize(user);\n            const sanitizedToken = RestUtils.sanitize(token);\n            await this.server.rest.connection.proxifiedQuery([\n                `UPDATE auth_users SET recovery_token = ${sanitizedToken} WHERE 1=1 AND name = ${sanitizedUser};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully notified with recovery email\",\n                recovery_token: configurations.environment !== \"test\" ? \"unknown\" : token\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.recover = async function (recovery_token) {\n        try {\n            trace(\"AuthByMySQL.prototype.recover\");\n            const sanitizedToken = RestUtils.sanitize(recovery_token);\n            const [matchedUsers] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE recovery_token = ${sanitizedToken};`\n            ].join(\"\\n\"));\n            if (matchedUsers.length === 0) {\n                throw new Error(\"Required parameter «recovery_token» to be a recovery token in order to «recover»\");\n            } else if (matchedUsers.length !== 1) {\n                throw new Error(\"Required user «recovery_token» to be active in order to «recover»\");\n            }\n            const [userData] = matchedUsers;\n            const token = RestUtils.generateRandomToken(20);\n            const sanitizedUserId = RestUtils.sanitize(userData.id);\n            await this.server.rest.connection.proxifiedQuery([\n                `UPDATE auth_users SET recovery_token = NULL WHERE 1=1 AND id = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully recovered\",\n                password: userData.password\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.unregister = async function (session_token, user, password) {\n        try {\n            trace(\"AuthByMySQL.prototype.unregister\");\n            const sanitizedToken = RestUtils.sanitize(session_token);\n            const [matchedSessions] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_sessions WHERE token = ${sanitizedToken};`\n            ].join(\"\\n\"));\n            if (matchedSessions.length === 0) {\n                throw new Error(\"Required parameters «session_token» to be a session token in order to «unregister»\");\n            } else if (matchedSessions.length !== 1) {\n                matchedSessions\n                throw new Error(\"Data corrupted by session duplication on unregister\");\n            }\n            const [matchedSession] = matchedSessions;\n            const sanitizedUserId = RestUtils.sanitize(matchedSession.id_user);\n            const [[matchedUser]] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_users WHERE id = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            const isValidUser = (matchedUser.name === user) && (matchedUser.password === password);\n            if (!isValidUser) {\n                throw new Error(\"Required parameters «user» and «password» to match in order to «unregister»\")\n            }\n            const sanitizedSessionId = RestUtils.sanitize(matchedSession.id);\n            await this.server.rest.connection.proxifiedQuery([\n                `DELETE FROM auth_sessions WHERE 1=1 AND id = ${sanitizedSessionId};`\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                `DELETE FROM auth_users WHERE 1=1 AND id = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully unregistered\",\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.modify = async function (sessionToken, user, password) {\n        try {\n            trace(\"AuthByMySQL.prototype.modify\");\n            const sanitizedToken = RestUtils.sanitize(sessionToken);\n            const [matchedSessions] = await this.server.rest.connection.proxifiedQuery([\n                `SELECT * FROM auth_sessions WHERE token = ${sanitizedToken};`\n            ].join(\"\\n\"));\n            if (matchedSessions.length === 0) {\n                throw new Error(\"Required parameters «session_token» to be a session token in order to «modify»\");\n            } else if (matchedSessions.length !== 1) {\n                matchedSessions\n                throw new Error(\"Data corrupted by session duplication on modify\");\n            }\n            const [matchedSession] = matchedSessions;\n            const sanitizedUserId = RestUtils.sanitize(matchedSession.id_user);\n            const sanitizedUser = RestUtils.sanitize(user || \"\");\n            const sanitizedPassword = RestUtils.sanitize(password || \"\");\n            let sanitizedValues = \"\";\n            sanitizedValues += user ? (\"name = \" + sanitizedUser) : \"\";\n            sanitizedValues += ((user && password) ? \", \" : \"\") + (password ? (\"password = \" + sanitizedPassword) : \"\");\n            const [updateResults] = await this.server.rest.connection.proxifiedQuery([\n                `UPDATE auth_users SET ${sanitizedValues} WHERE id = ${sanitizedUserId};`\n            ].join(\"\\n\"));\n            return {\n                message: \"user successfully modified\",\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.resetAuth = async function () {\n        try {\n            trace(\"AuthByMySQL.prototype.resetAuth\");\n            // ENTITIES:\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_pending_users (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  name VARCHAR(100),\",\n                \"  password VARCHAR(100),\",\n                \"  email VARCHAR(100),\",\n                \"  confirmation_token VARCHAR(100)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_users (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  name VARCHAR(100),\",\n                \"  password VARCHAR(100),\",\n                \"  email VARCHAR(100),\",\n                \"  recovery_token VARCHAR(100),\",\n                \"  description VARCHAR(200)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_groups (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  name VARCHAR(100),\",\n                \"  description VARCHAR(200)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_privileges (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  name VARCHAR(100),\",\n                \"  description VARCHAR(200)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_sessions (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  id_user INT,\",\n                \"  token VARCHAR(100),\",\n                \"  FOREIGN KEY (id_user) REFERENCES auth_users(id)\",\n                \");\"\n            ].join(\"\\n\"));\n            // RELATIONS:\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_groups_of_users (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  id_user INT,\",\n                \"  id_group INT,\",\n                \"  FOREIGN KEY (id_user) REFERENCES auth_users(id),\",\n                \"  FOREIGN KEY (id_group) REFERENCES auth_groups(id)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"CREATE TABLE auth_privileges_of_groups (\",\n                \"  id INT PRIMARY KEY AUTO_INCREMENT,\",\n                \"  id_privilege INT,\",\n                \"  id_group INT,\",\n                \"  FOREIGN KEY (id_privilege) REFERENCES auth_privileges(id),\",\n                \"  FOREIGN KEY (id_group) REFERENCES auth_groups(id)\",\n                \");\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"INSERT INTO auth_users (name, password, email) VALUES ('administrator', 'administrator', 'carlcarlsonc18@gmail.com');\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"INSERT INTO auth_groups (name, description) VALUES ('administrators', 'the administration');\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"INSERT INTO auth_privileges (name, description) VALUES ('to administrate', 'to administrate');\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"INSERT INTO auth_groups_of_users (id_user, id_group) VALUES ('1', '1');\"\n            ].join(\"\\n\"));\n            await this.server.rest.connection.proxifiedQuery([\n                \"INSERT INTO auth_privileges_of_groups (id_group, id_privilege) VALUES ('1', '1');\"\n            ].join(\"\\n\"));\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    AuthByMySQL.prototype.hasAuthorizationFor = async function (privilegeName, authentication) {\n        try {\n            trace(\"AuthByMySQL.prototype.hasAuthorizationFor\");\n            if (typeof privilegeName !== \"string\") {\n                throw new Error(\"Required parameter «privilegeName» to be a string in order to «hasAuthorizationFor»\");\n            }\n            if (typeof authentication !== \"object\") {\n                throw new Error(\"Required parameter «authentication» to be a string in order to «hasAuthorizationFor»\");\n            }\n            const matchedPrivileges = authentication.privileges.filter(privilege => privilege.name === privilegeName);\n            return matchedPrivileges.length;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    let RestByDexie = function (options, extensions = {}) {\n        trace(\"RestByDexie.constructor\");\n        if (typeof options !== \"object\") {\n            throw new Error(\"Required parameter «options» to be an object in order to «RestByDexie.constructor»\");\n        }\n        if (typeof options.credentials !== \"object\") {\n            throw new Error(\"Required parameter «options.credentials» to be an object in order to «RestByDexie.constructor»\");\n        }\n        if (typeof extensions !== \"object\") {\n            throw new Error(\"Required parameter «extensions» to be an object in order to «RestByDexie.constructor»\");\n        }\n        this.credentials = options.credentials;\n        Object.assign(this, extensions);\n        return this;\n    };\n    RestByDexie = Object.assign(RestByDexie, { ...RestByMySQL });\n    RestByDexie.prototype = Object.assign(RestByDexie.prototype, { ...RestByMySQL.prototype });\n    RestByDexie.prototype.initialize = async function () {\n        try {\n            trace(\"RestByDexie.prototype.initialize\");\n            const versionSchema = {};\n            const allServices = this.server.services;\n            for (let indexService = 0; indexService < allServices.length; indexService++) {\n                const serviceClass = allServices[indexService];\n                if (typeof serviceClass.creationScript === \"string\") {\n                    versionSchema[serviceClass.table] = serviceClass.creationScript;\n                    // await this.connection.proxifiedQuery(serviceClass.creationScript);\n                }\n            }\n            if (typeof this.seeder === \"function\") {\n                await this.seeder(authentication);\n            }\n            this.connection = await RanasDB.connect(\"main_app_id\", [[versionSchema, () => { }]]);\n            this.connection = RestUtils.expandConnection(this.connection);\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.resetDatabase = async function (authentication) {\n        try {\n            trace(\"RestByDexie.prototype.resetDatabase\");\n            await RanasDB.dropDatabaseIfExists(\"main_app_id\");\n            await this.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.selectOne = async function (dataType, { where }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.selectOne\");\n            await this.server.hooks.useHook(\"api://rest.selectOne::before\", { dataType, where, authentication });\n            await this.server.hooks.useHook(\"api://rest.selectOne:\" + dataType + \"::before\", { dataType, where, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const allResults = await this.connection.dexieDB[dataType].filter(tfilter).toArray();\n            if (allResults.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.selectOne»\");\n            } else if (allResults.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.selectOne»\");\n            }\n            const result = allResults[0];\n            await this.server.hooks.useHook(\"api://rest.selectOne::after\", { dataType, where, authentication, result });\n            await this.server.hooks.useHook(\"api://rest.selectOne:\" + dataType + \"::after\", { dataType, where, authentication, result });\n            return result;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.selectMany = async function (dataType, { where = [], order = [], group = [], pagination = [] }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.selectMany\");\n            await this.server.hooks.useHook(\"api://rest.selectMany::before\", { dataType, where, order, group, pagination, authentication });\n            await this.server.hooks.useHook(\"api://rest.selectMany:\" + dataType + \"::before\", { dataType, where, order, group, pagination, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const transaction = await this.connection.dexieDB[dataType].filter(tfilter);\n            const [page = 1, items = 20] = pagination;\n            const offset = (page - 1) * items;\n            const finalOrder = ((!Array.isArray(order)) || (order.length === 0)) ? \":id\" : order[0].startsWith(\"!\") ? order[0].substr(1) : order[0];\n            if (order[0].startsWith(\"!\")) {\n                transaction.reverse();\n            }\n            transaction.offset(offset).limit(items);\n            const result = await transaction.sortBy(...finalOrder);\n            await this.server.hooks.useHook(\"api://rest.selectMany::after\", { dataType, where, order, group, pagination, result, authentication });\n            await this.server.hooks.useHook(\"api://rest.selectMany:\" + dataType + \"::after\", { dataType, where, order, group, pagination, result, authentication });\n            return result;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.insertOne = async function (dataType, { item }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.insertOne\");\n            await this.server.hooks.useHook(\"api://rest.insertOne::before\", { dataType, item, authentication });\n            await this.server.hooks.useHook(\"api://rest.insertOne:\" + dataType + \"::before\", { dataType, item, authentication });\n            const result = await this.connection.dexieDB[dataType].add(item);\n            await this.server.hooks.useHook(\"api://rest.insertOne::after\", { dataType, item, authentication });\n            await this.server.hooks.useHook(\"api://rest.insertOne:\" + dataType + \"::after\", { dataType, item, authentication });\n            return {\n                rows: 1,\n                id: result\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.insertMany = async function (dataType, { items }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.insertMany\");\n            await this.server.hooks.useHook(\"api://rest.insertMany::before\", { dataType, items, authentication });\n            await this.server.hooks.useHook(\"api://rest.insertMany:\" + dataType + \"::before\", { dataType, items, authentication });\n            const result = await this.connection.dexieDB[dataType].bulkAdd(items);\n            await this.server.hooks.useHook(\"api://rest.insertMany::after\", { dataType, items, authentication });\n            await this.server.hooks.useHook(\"api://rest.insertMany:\" + dataType + \"::after\", { dataType, items, authentication });\n            return {\n                rows: items.length,\n                id: result\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.updateOne = async function (dataType, { where, values }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.updateOne\");\n            await this.server.hooks.useHook(\"api://rest.updateOne::before\", { dataType, where, values, authentication });\n            await this.server.hooks.useHook(\"api://rest.updateOne:\" + dataType + \"::before\", { dataType, where, values, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const transaction = await this.connection.dexieDB[dataType].filter(tfilter);\n            const allResults = await transaction.toArray();\n            if (allResults.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.updateOne»\");\n            } else if (allResults.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.updateOne»\");\n            }\n            await transaction.modify(item => {\n                Object.assign(item, values);\n            });\n            await this.server.hooks.useHook(\"api://rest.updateOne::after\", { dataType, where, values, authentication });\n            await this.server.hooks.useHook(\"api://rest.updateOne:\" + dataType + \"::after\", { dataType, where, values, authentication });\n            return {\n                rows: allResults.length,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.updateMany = async function (dataType, { where, values }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.updateMany\");\n            await this.server.hooks.useHook(\"api://rest.updateMany::before\", { dataType, where, values, authentication });\n            await this.server.hooks.useHook(\"api://rest.updateMany:\" + dataType + \"::before\", { dataType, where, values, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const transaction = await this.connection.dexieDB[dataType].filter(tfilter);\n            const allResults = await transaction.toArray();\n            await transaction.modify(item => {\n                Object.assign(item, values);\n            });\n            await this.server.hooks.useHook(\"api://rest.updateMany::after\", { dataType, where, values, authentication });\n            await this.server.hooks.useHook(\"api://rest.updateMany:\" + dataType + \"::after\", { dataType, where, values, authentication });\n            return {\n                rows: allResults.length,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.deleteOne = async function (dataType, { where }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.deleteOne\");\n            await this.server.hooks.useHook(\"api://rest.deleteOne::before\", { dataType, where, authentication });\n            await this.server.hooks.useHook(\"api://rest.deleteOne:\" + dataType + \"::before\", { dataType, where, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const transaction = await this.connection.dexieDB[dataType].filter(tfilter);\n            const allResults = await transaction.toArray();\n            if (allResults.length === 0) {\n                throw new Error(\"No items were found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.deleteOne»\");\n            } else if (allResults.length !== 1) {\n                throw new Error(\"More than 1 item was found on «\" + dataType + \"» by using the specified filters on «RestByDexie.prototype.deleteOne»\");\n            }\n            await transaction.delete();\n            await this.server.hooks.useHook(\"api://rest.deleteOne::after\", { dataType, where, authentication });\n            await this.server.hooks.useHook(\"api://rest.deleteOne:\" + dataType + \"::after\", { dataType, where, authentication });\n            return {\n                rows: allResults.length,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.deleteMany = async function (dataType, { where }, authentication) {\n        try {\n            trace(\"RestByDexie.prototype.deleteMany\");\n            await this.server.hooks.useHook(\"api://rest.deleteMany::before\", { dataType, where, authentication });\n            await this.server.hooks.useHook(\"api://rest.deleteMany:\" + dataType + \"::before\", { dataType, where, authentication });\n            const tfilter = RestUtils.fromWhereToFilterFunction(where);\n            const transaction = await this.connection.dexieDB[dataType].filter(tfilter);\n            const allResults = await transaction.toArray();\n            await transaction.delete();\n            await this.server.hooks.useHook(\"api://rest.deleteMany::after\", { dataType, where, authentication });\n            await this.server.hooks.useHook(\"api://rest.deleteMany:\" + dataType + \"::after\", { dataType, where, authentication });\n            return {\n                rows: allResults.length,\n            };\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.getFile = async function (table) {\n        try {\n            trace(\"RestByDexie.prototype.getFile\");\n            console.log(table);\n            return 600;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    RestByDexie.prototype.setFile = async function (table) {\n        try {\n            trace(\"RestByDexie.prototype.setFile\");\n            console.log(table);\n            return 600;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    let AuthByDexie = function (options, extensions = {}) {\n        trace(\"AuthByDexie.constructor\");\n        if (typeof options !== \"object\") {\n            throw new Error(\"Required parameter «options» to be an object in order to «AuthByDexie.constructor»\");\n        }\n        if (typeof options.credentials !== \"object\") {\n            throw new Error(\"Required parameter «options.credentials» to be an object in order to «AuthByDexie.constructor»\");\n        }\n        if (typeof extensions !== \"object\") {\n            throw new Error(\"Required parameter «extensions» to be an object in order to «AuthByDexie.constructor»\");\n        }\n        this.credentials = options.credentials;\n        Object.assign(this, extensions);\n        return this;\n    };\n    AuthByDexie = Object.assign(AuthByDexie, { ...AuthByMySQL });\n    AuthByDexie.prototype = Object.assign(AuthByDexie.prototype, { ...AuthByMySQL.prototype });\n    AuthByDexie.prototype.authenticate = function () { };\n    AuthByDexie.prototype.login = function () { };\n    AuthByDexie.prototype.logout = function () { };\n    AuthByDexie.prototype.refresh = function () { };\n    AuthByDexie.prototype.register = function () { };\n    AuthByDexie.prototype.confirm = function () { };\n    AuthByDexie.prototype.forgot = function () { };\n    AuthByDexie.prototype.recover = function () { };\n    AuthByDexie.prototype.unregister = function () { };\n    AuthByDexie.prototype.hasAuthorizationFor = function () { };\n    AuthByDexie.prototype.resetAuth = function () { };\n\n    const VirtualDataService = function (dynamicInterface = {}) {\n        trace(\"VirtualDataService.constructor\");\n        Object.assign(this, dynamicInterface);\n        return this;\n    };\n    Object.assign(VirtualDataService, { ...DataService });\n    Object.assign(VirtualDataService.prototype, { ...DataService.prototype });\n\n    VirtualDataService.prototype.resetDatabase = async function () {\n        trace(\"VirtualDataService.prototype.resetDatabase\");\n        try {\n            await RanasDB.dropDatabaseIfExists(this.credentials.database);\n            return await this.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    VirtualDataService.prototype.initialize = async function () {\n        trace(\"VirtualDataService.prototype.initialize\");\n        try {\n            this.connection = await RanasDB.connect(this.credentials.database, this.versionation);\n            return this;\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n\n    const VirtualQueryService = function () {\n        trace(\"VirtualQueryService.constructor\");\n    };\n    Object.assign(VirtualQueryService, { ...QueryService });\n    Object.assign(VirtualQueryService.prototype, { ...QueryService.prototype });\n\n    const VirtualProcessService = function () {\n        trace(\"VirtualProcessService.constructor\");\n    };\n    Object.assign(VirtualProcessService, { ...ProcessService });\n    Object.assign(VirtualProcessService.prototype, { ...ProcessService.prototype });\n    // VirtualProcessService.prototype.dispatch = function (request, response) { };\n\n    const VirtualDataServer = function (dynamicInterface = {}) {\n        trace(\"VirtualDataServer.constructor\");\n        Object.assign(this, dynamicInterface);\n        if (!this.adapter) this.adapter = \"dexie\";\n        this.rest = undefined;\n        this.auth = undefined;\n        this.services = [];\n        this.queries = [];\n        this.processes = [];\n        this.hooks = Hooks.create();\n        this.basePathForData = \"/rest/api/v1\";\n        this.basePathForAuth = \"/auth/api/v1\";\n        this.basePathForQuery = \"/query/api/v1\";\n        this.basePathForProcess = \"/process/api/v1\";\n        return this;\n    };\n    Object.assign(VirtualDataServer, { ...DataServer });\n    Object.assign(VirtualDataServer.prototype, { ...DataServer.prototype });\n    VirtualDataServer.prototype.initializeRest = async function () {\n        try {\n            trace(\"VirtualDataServer.prototype.initializeRest\");\n            let restAdapter = undefined;\n            if (typeof this.adapter !== \"string\") {\n                this.adapter = \"dexie\";\n            }\n            // @TOCONTINUE: continue adding other REST adapters on the following conditional:\n            if (this.adapter === \"dexie\") {\n                restAdapter = new RestByDexie({\n                    credentials: this.credentials || {},\n                }, {\n                    ...this.restExtension,\n                    server: this,\n                });\n            } else {\n                throw new Error(\"Required configuration «this.adapter» to be a valid option in order to «initializeRest»\");\n            }\n            // @OK!\n            this.rest = await restAdapter.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    VirtualDataServer.prototype.initializeAuth = async function () {\n        try {\n            trace(\"VirtualDataServer.prototype.initializeAuth\");\n            let authAdapter = undefined;\n            if (typeof this.adapter !== \"string\") {\n                this.adapter = \"dexie\";\n            }\n            // @TOCONTINUE: continue adding other AUTH adapters on the following conditional:\n            if (this.adapter === \"dexie\") {\n                authAdapter = new AuthByDexie({\n                    credentials: this.credentials,\n                }, {\n                    ...this.authExtension,\n                    server: this,\n                });\n            } else {\n                throw new Error(\"Required parameter «adapter» to be a valid option in order to «initializeRest»\");\n            }\n            // @OK!\n            this.auth = await authAdapter.initialize();\n        } catch (error) {\n            this.onError(error);\n        }\n    };\n    VirtualDataServer.prototype.addService = function (...args) {\n        trace(\"VirtualDataServer.prototype.addService\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicServiceFactory()\n        const service = constructorFunction;\n        Object.assign(service, { ...VirtualDataService }, { ...staticInterface });\n        Object.assign(service.prototype, { ...VirtualDataService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticServiceInterface(service);\n        RestUtils.validateDynamicServiceInterface(service.prototype);\n        this.services.push(service);\n        return this;\n    };\n    VirtualDataServer.prototype.addQuery = function (...args) {\n        trace(\"VirtualDataServer.prototype.addQuery\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicQueryFactory()\n        const queryClass = constructorFunction;\n        Object.assign(queryClass, { ...VirtualQueryService }, { ...staticInterface });\n        Object.assign(queryClass.prototype, { ...VirtualQueryService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticQueryInterface(queryClass);\n        RestUtils.validateDynamicQueryInterface(queryClass.prototype);\n        this.queries.push(queryClass);\n        return this;\n    };\n    VirtualDataServer.prototype.addProcess = function (...args) {\n        trace(\"VirtualDataServer.prototype.addProcess\");\n        const [staticInterface = {}, dynamicInterface = {}, constructorFunctionParameter = undefined] = args;\n        const constructorFunction = constructorFunctionParameter ? constructorFunctionParameter : RestUtils.basicProcessFactory()\n        const processClass = constructorFunction;\n        Object.assign(processClass, { ...VirtualProcessService }, { ...staticInterface });\n        Object.assign(processClass.prototype, { ...VirtualProcessService.prototype }, { ...dynamicInterface }, {\n            server: this\n        });\n        RestUtils.validateStaticProcessInterface(processClass);\n        RestUtils.validateDynamicProcessInterface(processClass.prototype);\n        this.processes.push(processClass);\n        return this;\n    };\n    VirtualDataServer.prototype.dispatchSelf = function (method = \"get\", url = \"/\", requestArgs = {}, responseArgs = {}) {\n        trace(\"VirtualDataServer.prototype.dispatchSelf\");\n        trace(\"METHOD: \" + method);\n        trace(\"   URL: \" + url);\n        const parsedUrl = RestUtils.require(\"url\").parse(url);\n        const request = new RequestPolyfill(method, url, requestArgs);\n        const response = new ResponsePolyfill(responseArgs);\n        if (parsedUrl.pathname.startsWith(this.basePathForData)) {\n            const [model, operation, quantifier] = parsedUrl.pathname.replace(this.basePathForData, \"\").split(\"/\").filter(it => it !== \"\");\n            this.dispatch(request, response);\n            return response.response_promise.then(VirtualDataServer.throwOnErrorStatus);\n        } else if (parsedUrl.pathname.startsWith(this.basePathForAuth)) {\n            const [operation] = parsedUrl.pathname.replace(this.basePathForAuth, \"\").split(\"/\").filter(it => it !== \"\");\n            this.dispatch(request, response);\n            return response.response_promise.then(VirtualDataServer.throwOnErrorStatus);\n        } else if (parsedUrl.pathname.startsWith(this.basePathForProcess)) {\n            const [processId] = parsedUrl.pathname.replace(this.basePathForProcess, \"\").split(\"/\").filter(it => it !== \"\");\n            this.dispatch(request, response);\n            return response.response_promise.then(VirtualDataServer.throwOnErrorStatus);\n        } else if (parsedUrl.pathname.startsWith(this.basePathForQuery)) {\n            const [queryId] = parsedUrl.pathname.replace(this.basePathForQuery, \"\").split(\"/\").filter(it => it !== \"\");\n            this.dispatch(request, response);\n            return response.response_promise.then(VirtualDataServer.throwOnErrorStatus);\n        }\n        throw new Error(\"Request not valid: domain out of bounds\");\n    };\n    VirtualDataServer.throwOnErrorStatus = function (data) {\n        if (data.status >= 200 && data.status <= 400) {\n            data.response = Object.assign({}, data, {\n                statusText: \"OK\"\n            });\n            return data;\n        }\n        throw data;\n    };\n    /*\n    VirtualDataServer.prototype.dispatch = function () {};\n    VirtualDataServer.prototype.createDispatcher = function() {};\n    VirtualDataServer.prototype.createHttpServerController = function() {};\n    VirtualDataServer.prototype.createHttpServer = function() {};\n    VirtualDataServer.prototype.listen = function() {};\n    VirtualDataServer.prototype.stopDatabaseConnection = function() {};\n    VirtualDataServer.prototype.stopHttpServer = function() {};\n    VirtualDataServer.prototype.resetDatabase = function() {};\n    VirtualDataServer.prototype.resetAuth = function() {};\n    //*/\n\n    ////////////////////////////////////////////////////////////////////////\n    // 12. Common traits:\n    RestByMySQL.prototype.onError = RestUtils.generateOnErrorFunction(\"RestByMySQL.prototype.onError\");\n    RestByMySQL.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"RestByMySQL.prototype.onDispatchError\");\n    AuthByMySQL.prototype.onError = RestUtils.generateOnErrorFunction(\"AuthByMySQL.prototype.onError\");\n    AuthByMySQL.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"AuthByMySQL.prototype.onDispatchError\");\n    DataService.prototype.onError = RestUtils.generateOnErrorFunction(\"DataService.prototype.onError\");\n    DataService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"DataService.prototype.onDispatchError\");\n    DataServer.prototype.onError = RestUtils.generateOnErrorFunction(\"DataServer.prototype.onError\");\n    DataServer.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"DataServer.prototype.onDispatchError\");\n    Hooks.prototype.onError = RestUtils.generateOnErrorFunction(\"Hooks.prototype.onError\");\n    Hooks.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"Hooks.prototype.onDispatchError\");\n    QueryService.prototype.onError = RestUtils.generateOnErrorFunction(\"QueryService.prototype.onError\");\n    QueryService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"QueryService.prototype.onDispatchError\");\n    ProcessService.prototype.onError = RestUtils.generateOnErrorFunction(\"ProcessService.prototype.onError\");\n    ProcessService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"ProcessService.prototype.onDispatchError\");\n\n    RestByDexie.prototype.onError = RestUtils.generateOnErrorFunction(\"RestByDexie.prototype.onError\");\n    RestByDexie.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"RestByDexie.prototype.onDispatchError\");\n    AuthByDexie.prototype.onError = RestUtils.generateOnErrorFunction(\"AuthByDexie.prototype.onError\");\n    AuthByDexie.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"AuthByDexie.prototype.onDispatchError\");\n    VirtualDataService.prototype.onError = RestUtils.generateOnErrorFunction(\"VirtualDataService.prototype.onError\");\n    VirtualDataService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"VirtualDataService.prototype.onDispatchError\");\n    VirtualDataServer.prototype.onError = RestUtils.generateOnErrorFunction(\"VirtualDataServer.prototype.onError\");\n    VirtualDataServer.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"VirtualDataServer.prototype.onDispatchError\");\n\n    VirtualQueryService.prototype.onError = RestUtils.generateOnDispatchErrorFunction(\"VirtualQueryService.prototype.onError\");\n    VirtualQueryService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"VirtualQueryService.prototype.onDispatchError\");\n    VirtualProcessService.prototype.onError = RestUtils.generateOnDispatchErrorFunction(\"VirtualProcessService.prototype.onError\");\n    VirtualProcessService.prototype.onDispatchError = RestUtils.generateOnDispatchErrorFunction(\"VirtualProcessService.prototype.onDispatchError\");\n\n    ////////////////////////////////////////////////////////////////////////\n    // 99. Export internal interfaces from DataServer:\n    DataServer.RestInterface = RestInterface;\n    DataServer.RestByMySQL = RestByMySQL;\n    DataServer.AuthInterface = AuthInterface;\n    DataServer.AuthByMySQL = AuthByMySQL;\n    DataServer.DataService = DataService;\n    DataServer.RestUtils = RestUtils;\n    DataServer.Hooks = Hooks;\n    DataServer.RestByDexie = RestByDexie;\n    DataServer.AuthByDexie = AuthByDexie;\n    DataServer.VirtualDataServer = VirtualDataServer;\n    DataServer.VirtualDataService = VirtualDataService;\n\n    ////////////////////////////////////////////////////////////////////////\n    const finalAPI = {\n        // Public API:\n        DataServer,\n        VirtualDataServer,\n        DataService,\n        Hooks,\n        // Internal (but exposed) API:\n        RestInterface,\n        RestByMySQL,\n        AuthInterface,\n        AuthByMySQL,\n        RestUtils,\n        RestByDexie,\n        AuthByDexie,\n        VirtualDataService,\n    };\n    finalAPI.default = finalAPI;\n    return finalAPI;\n\n});\n\n//Included:lib/014.jquery-v3.3.1.part.js\n// ~$ npm install jquery@3.3.1\n\n/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */\nif(typeof window !== \"undefined\") {\n\n!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(e,t){\"use strict\";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function e(t){return\"function\"==typeof t&&\"number\"!=typeof t.nodeType},y=function e(t){return null!=t&&t===t.window},v={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement(\"script\");if(o.text=e,n)for(i in v)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?l[c.call(e)]||\"object\":typeof e}var b=\"3.3.1\",w=function(e,t){return new w.fn.init(e,t)},T=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;w.fn=w.prototype={jquery:\"3.3.1\",constructor:w,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=w.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return w.each(this,e)},map:function(e){return this.pushStack(w.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(o.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:n.sort,splice:n.splice},w.extend=w.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||g(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],a!==(r=e[t])&&(l&&r&&(w.isPlainObject(r)||(i=Array.isArray(r)))?(i?(i=!1,o=n&&Array.isArray(n)?n:[]):o=n&&w.isPlainObject(n)?n:{},a[t]=w.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},w.extend({expando:\"jQuery\"+(\"3.3.1\"+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==c.call(e))&&(!(t=i(e))||\"function\"==typeof(n=f.call(t,\"constructor\")&&t.constructor)&&p.call(n)===d)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e){m(e)},each:function(e,t){var n,r=0;if(C(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?\"\":(e+\"\").replace(T,\"\")},makeArray:function(e,t){var n=t||[];return null!=e&&(C(Object(e))?w.merge(n,\"string\"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:u.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,a=e.length,s=!n;o<a;o++)(r=!t(e[o],o))!==s&&i.push(e[o]);return i},map:function(e,t,n){var r,i,o=0,s=[];if(C(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&s.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&s.push(i);return a.apply([],s)},guid:1,support:h}),\"function\"==typeof Symbol&&(w.fn[Symbol.iterator]=n[Symbol.iterator]),w.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){l[\"[object \"+t+\"]\"]=t.toLowerCase()});function C(e){var t=!!e&&\"length\"in e&&e.length,n=x(e);return!g(e)&&!y(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&t>0&&t-1 in e)}var E=function(e){var t,n,r,i,o,a,s,u,l,c,f,p,d,h,g,y,v,m,x,b=\"sizzle\"+1*new Date,w=e.document,T=0,C=0,E=ae(),k=ae(),S=ae(),D=function(e,t){return e===t&&(f=!0),0},N={}.hasOwnProperty,A=[],j=A.pop,q=A.push,L=A.push,H=A.slice,O=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},P=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",R=\"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",I=\"\\\\[\"+M+\"*(\"+R+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+R+\"))|)\"+M+\"*\\\\]\",W=\":(\"+R+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+I+\")*)|.*)\\\\)|)\",$=new RegExp(M+\"+\",\"g\"),B=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),F=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),_=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),z=new RegExp(\"=\"+M+\"*([^\\\\]'\\\"]*?)\"+M+\"*\\\\]\",\"g\"),X=new RegExp(W),U=new RegExp(\"^\"+R+\"$\"),V={ID:new RegExp(\"^#(\"+R+\")\"),CLASS:new RegExp(\"^\\\\.(\"+R+\")\"),TAG:new RegExp(\"^(\"+R+\"|[*])\"),ATTR:new RegExp(\"^\"+I),PSEUDO:new RegExp(\"^\"+W),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+P+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},G=/^(?:input|select|textarea|button)$/i,Y=/^h\\d$/i,Q=/^[^{]+\\{\\s*\\[native \\w/,J=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,K=/[+~]/,Z=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+M+\"?|(\"+M+\")|.)\",\"ig\"),ee=function(e,t,n){var r=\"0x\"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},te=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ne=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},re=function(){p()},ie=me(function(e){return!0===e.disabled&&(\"form\"in e||\"label\"in e)},{dir:\"parentNode\",next:\"legend\"});try{L.apply(A=H.call(w.childNodes),w.childNodes),A[w.childNodes.length].nodeType}catch(e){L={apply:A.length?function(e,t){q.apply(e,H.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function oe(e,t,r,i){var o,s,l,c,f,h,v,m=t&&t.ownerDocument,T=t?t.nodeType:9;if(r=r||[],\"string\"!=typeof e||!e||1!==T&&9!==T&&11!==T)return r;if(!i&&((t?t.ownerDocument||t:w)!==d&&p(t),t=t||d,g)){if(11!==T&&(f=J.exec(e)))if(o=f[1]){if(9===T){if(!(l=t.getElementById(o)))return r;if(l.id===o)return r.push(l),r}else if(m&&(l=m.getElementById(o))&&x(t,l)&&l.id===o)return r.push(l),r}else{if(f[2])return L.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return L.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!S[e+\" \"]&&(!y||!y.test(e))){if(1!==T)m=t,v=e;else if(\"object\"!==t.nodeName.toLowerCase()){(c=t.getAttribute(\"id\"))?c=c.replace(te,ne):t.setAttribute(\"id\",c=b),s=(h=a(e)).length;while(s--)h[s]=\"#\"+c+\" \"+ve(h[s]);v=h.join(\",\"),m=K.test(e)&&ge(t.parentNode)||t}if(v)try{return L.apply(r,m.querySelectorAll(v)),r}catch(e){}finally{c===b&&t.removeAttribute(\"id\")}}}return u(e.replace(B,\"$1\"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+\" \")>r.cacheLength&&delete t[e.shift()],t[n+\" \"]=i}return t}function se(e){return e[b]=!0,e}function ue(e){var t=d.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function le(e,t){var n=e.split(\"|\"),i=n.length;while(i--)r.attrHandle[n[i]]=t}function ce(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function fe(e){return function(t){return\"input\"===t.nodeName.toLowerCase()&&t.type===e}}function pe(e){return function(t){var n=t.nodeName.toLowerCase();return(\"input\"===n||\"button\"===n)&&t.type===e}}function de(e){return function(t){return\"form\"in t?t.parentNode&&!1===t.disabled?\"label\"in t?\"label\"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ie(t)===e:t.disabled===e:\"label\"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function ge(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}n=oe.support={},o=oe.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&\"HTML\"!==t.nodeName},p=oe.setDocument=function(e){var t,i,a=e?e.ownerDocument||e:w;return a!==d&&9===a.nodeType&&a.documentElement?(d=a,h=d.documentElement,g=!o(d),w!==d&&(i=d.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener(\"unload\",re,!1):i.attachEvent&&i.attachEvent(\"onunload\",re)),n.attributes=ue(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),n.getElementsByTagName=ue(function(e){return e.appendChild(d.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),n.getElementsByClassName=Q.test(d.getElementsByClassName),n.getById=ue(function(e){return h.appendChild(e).id=b,!d.getElementsByName||!d.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){return e.getAttribute(\"id\")===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){var n=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return n&&n.value===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),r.find.TAG=n.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&g)return t.getElementsByClassName(e)},v=[],y=[],(n.qsa=Q.test(d.querySelectorAll))&&(ue(function(e){h.appendChild(e).innerHTML=\"<a id='\"+b+\"'></a><select id='\"+b+\"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&y.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||y.push(\"\\\\[\"+M+\"*(?:value|\"+P+\")\"),e.querySelectorAll(\"[id~=\"+b+\"-]\").length||y.push(\"~=\"),e.querySelectorAll(\":checked\").length||y.push(\":checked\"),e.querySelectorAll(\"a#\"+b+\"+*\").length||y.push(\".#.+[+~]\")}),ue(function(e){e.innerHTML=\"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\";var t=d.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&y.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&y.push(\":enabled\",\":disabled\"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&y.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),y.push(\",.*:\")})),(n.matchesSelector=Q.test(m=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ue(function(e){n.disconnectedMatch=m.call(e,\"*\"),m.call(e,\"[s!='']:x\"),v.push(\"!=\",W)}),y=y.length&&new RegExp(y.join(\"|\")),v=v.length&&new RegExp(v.join(\"|\")),t=Q.test(h.compareDocumentPosition),x=t||Q.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e===d||e.ownerDocument===w&&x(w,e)?-1:t===d||t.ownerDocument===w&&x(w,t)?1:c?O(c,e)-O(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===d?-1:t===d?1:i?-1:o?1:c?O(c,e)-O(c,t):0;if(i===o)return ce(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?ce(a[r],s[r]):a[r]===w?-1:s[r]===w?1:0},d):d},oe.matches=function(e,t){return oe(e,null,null,t)},oe.matchesSelector=function(e,t){if((e.ownerDocument||e)!==d&&p(e),t=t.replace(z,\"='$1']\"),n.matchesSelector&&g&&!S[t+\" \"]&&(!v||!v.test(t))&&(!y||!y.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return oe(t,d,null,[e]).length>0},oe.contains=function(e,t){return(e.ownerDocument||e)!==d&&p(e),x(e,t)},oe.attr=function(e,t){(e.ownerDocument||e)!==d&&p(e);var i=r.attrHandle[t.toLowerCase()],o=i&&N.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},oe.escape=function(e){return(e+\"\").replace(te,ne)},oe.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},oe.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(D),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return c=null,e},i=oe.getText=function(e){var t,n=\"\",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=oe.selectors={cacheLength:50,createPseudo:se,match:V,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(Z,ee),e[3]=(e[3]||e[4]||e[5]||\"\").replace(Z,ee),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||oe.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&oe.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return V.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=a(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(Z,ee).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&E(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(e,t,n){return function(r){var i=oe.attr(r,e);return null==i?\"!=\"===t:!t||(i+=\"\",\"=\"===t?i===n:\"!=\"===t?i!==n:\"^=\"===t?n&&0===i.indexOf(n):\"*=\"===t?n&&i.indexOf(n)>-1:\"$=\"===t?n&&i.slice(-n.length)===n:\"~=\"===t?(\" \"+i.replace($,\" \")+\" \").indexOf(n)>-1:\"|=\"===t&&(i===n||i.slice(0,n.length+1)===n+\"-\"))}},CHILD:function(e,t,n,r,i){var o=\"nth\"!==e.slice(0,3),a=\"last\"!==e.slice(-4),s=\"of-type\"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?\"nextSibling\":\"previousSibling\",y=t.parentNode,v=s&&t.nodeName.toLowerCase(),m=!u&&!s,x=!1;if(y){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g=\"only\"===e&&!h&&\"nextSibling\"}return!0}if(h=[a?y.firstChild:y.lastChild],a&&m){x=(d=(l=(c=(f=(p=y)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1])&&l[2],p=d&&y.childNodes[d];while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if(1===p.nodeType&&++x&&p===t){c[e]=[T,d,x];break}}else if(m&&(x=d=(l=(c=(f=(p=t)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1]),!1===x)while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===v:1===p.nodeType)&&++x&&(m&&((c=(f=p[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]=[T,x]),p===t))break;return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||oe.error(\"unsupported pseudo: \"+e);return i[b]?i(t):i.length>1?(n=[e,e,\"\",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),a=o.length;while(a--)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,\"$1\"));return r[b]?se(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||\"\")||oe.error(\"unsupported lang: \"+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return(n=n.toLowerCase())===e||0===n.indexOf(e+\"-\")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:he(function(){return[0]}),last:he(function(e,t){return[t-1]}),eq:he(function(e,t,n){return[n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq;for(t in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=fe(t);for(t in{submit:!0,reset:!0})r.pseudos[t]=pe(t);function ye(){}ye.prototype=r.filters=r.pseudos,r.setFilters=new ye,a=oe.tokenize=function(e,t){var n,i,o,a,s,u,l,c=k[e+\" \"];if(c)return t?0:c.slice(0);s=e,u=[],l=r.preFilter;while(s){n&&!(i=F.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),n=!1,(i=_.exec(s))&&(n=i.shift(),o.push({value:n,type:i[0].replace(B,\" \")}),s=s.slice(n.length));for(a in r.filter)!(i=V[a].exec(s))||l[a]&&!(i=l[a](i))||(n=i.shift(),o.push({value:n,type:a,matches:i}),s=s.slice(n.length));if(!n)break}return t?s.length:s?oe.error(e):k(e,u).slice(0)};function ve(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function me(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&\"parentNode\"===o,s=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||a)return e(t,n,i);return!1}:function(t,n,u){var l,c,f,p=[T,s];if(u){while(t=t[r])if((1===t.nodeType||a)&&e(t,n,u))return!0}else while(t=t[r])if(1===t.nodeType||a)if(f=t[b]||(t[b]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===T&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}return!1}}function xe(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function be(e,t,n){for(var r=0,i=t.length;r<i;r++)oe(e,t[r],n);return n}function we(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Te(e,t,n,r,i,o){return r&&!r[b]&&(r=Te(r)),i&&!i[b]&&(i=Te(i,o)),se(function(o,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=o||be(t||\"*\",s.nodeType?[s]:s,[]),y=!e||!o&&t?g:we(g,p,e,s,u),v=n?i||(o?e:h||r)?[]:a:y;if(n&&n(y,v,s,u),r){l=we(v,d),r(l,[],s,u),c=l.length;while(c--)(f=l[c])&&(v[d[c]]=!(y[d[c]]=f))}if(o){if(i||e){if(i){l=[],c=v.length;while(c--)(f=v[c])&&l.push(y[c]=f);i(null,v=[],l,u)}c=v.length;while(c--)(f=v[c])&&(l=i?O(o,f):p[c])>-1&&(o[l]=!(a[l]=f))}}else v=we(v===a?v.splice(h,v.length):v),i?i(null,a,v,u):L.apply(a,v)})}function Ce(e){for(var t,n,i,o=e.length,a=r.relative[e[0].type],s=a||r.relative[\" \"],u=a?1:0,c=me(function(e){return e===t},s,!0),f=me(function(e){return O(t,e)>-1},s,!0),p=[function(e,n,r){var i=!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):f(e,n,r));return t=null,i}];u<o;u++)if(n=r.relative[e[u].type])p=[me(xe(p),n)];else{if((n=r.filter[e[u].type].apply(null,e[u].matches))[b]){for(i=++u;i<o;i++)if(r.relative[e[i].type])break;return Te(u>1&&xe(p),u>1&&ve(e.slice(0,u-1).concat({value:\" \"===e[u-2].type?\"*\":\"\"})).replace(B,\"$1\"),n,u<i&&Ce(e.slice(u,i)),i<o&&Ce(e=e.slice(i)),i<o&&ve(e))}p.push(n)}return xe(p)}function Ee(e,t){var n=t.length>0,i=e.length>0,o=function(o,a,s,u,c){var f,h,y,v=0,m=\"0\",x=o&&[],b=[],w=l,C=o||i&&r.find.TAG(\"*\",c),E=T+=null==w?1:Math.random()||.1,k=C.length;for(c&&(l=a===d||a||c);m!==k&&null!=(f=C[m]);m++){if(i&&f){h=0,a||f.ownerDocument===d||(p(f),s=!g);while(y=e[h++])if(y(f,a||d,s)){u.push(f);break}c&&(T=E)}n&&((f=!y&&f)&&v--,o&&x.push(f))}if(v+=m,n&&m!==v){h=0;while(y=t[h++])y(x,b,a,s);if(o){if(v>0)while(m--)x[m]||b[m]||(b[m]=j.call(u));b=we(b)}L.apply(u,b),c&&!o&&b.length>0&&v+t.length>1&&oe.uniqueSort(u)}return c&&(T=E,l=w),x};return n?se(o):o}return s=oe.compile=function(e,t){var n,r=[],i=[],o=S[e+\" \"];if(!o){t||(t=a(e)),n=t.length;while(n--)(o=Ce(t[n]))[b]?r.push(o):i.push(o);(o=S(e,Ee(i,r))).selector=e}return o},u=oe.select=function(e,t,n,i){var o,u,l,c,f,p=\"function\"==typeof e&&e,d=!i&&a(e=p.selector||e);if(n=n||[],1===d.length){if((u=d[0]=d[0].slice(0)).length>2&&\"ID\"===(l=u[0]).type&&9===t.nodeType&&g&&r.relative[u[1].type]){if(!(t=(r.find.ID(l.matches[0].replace(Z,ee),t)||[])[0]))return n;p&&(t=t.parentNode),e=e.slice(u.shift().value.length)}o=V.needsContext.test(e)?0:u.length;while(o--){if(l=u[o],r.relative[c=l.type])break;if((f=r.find[c])&&(i=f(l.matches[0].replace(Z,ee),K.test(u[0].type)&&ge(t.parentNode)||t))){if(u.splice(o,1),!(e=i.length&&ve(u)))return L.apply(n,i),n;break}}}return(p||s(e,d))(i,t,!g,n,!t||K.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split(\"\").sort(D).join(\"\")===b,n.detectDuplicates=!!f,p(),n.sortDetached=ue(function(e){return 1&e.compareDocumentPosition(d.createElement(\"fieldset\"))}),ue(function(e){return e.innerHTML=\"<a href='#'></a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||le(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),n.attributes&&ue(function(e){return e.innerHTML=\"<input/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||le(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ue(function(e){return null==e.getAttribute(\"disabled\")})||le(P,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),oe}(e);w.find=E,w.expr=E.selectors,w.expr[\":\"]=w.expr.pseudos,w.uniqueSort=w.unique=E.uniqueSort,w.text=E.getText,w.isXMLDoc=E.isXML,w.contains=E.contains,w.escapeSelector=E.escape;var k=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&w(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},D=w.expr.match.needsContext;function N(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var A=/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;function j(e,t,n){return g(t)?w.grep(e,function(e,r){return!!t.call(e,r,e)!==n}):t.nodeType?w.grep(e,function(e){return e===t!==n}):\"string\"!=typeof t?w.grep(e,function(e){return u.call(t,e)>-1!==n}):w.filter(t,e,n)}w.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?w.find.matchesSelector(r,e)?[r]:[]:w.find.matches(e,w.grep(t,function(e){return 1===e.nodeType}))},w.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(w(e).filter(function(){for(t=0;t<r;t++)if(w.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)w.find(e,i[t],n);return r>1?w.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&D.test(e)?w(e):e||[],!1).length}});var q,L=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;(w.fn.init=function(e,t,n){var i,o;if(!e)return this;if(n=n||q,\"string\"==typeof e){if(!(i=\"<\"===e[0]&&\">\"===e[e.length-1]&&e.length>=3?[null,e,null]:L.exec(e))||!i[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(i[1]){if(t=t instanceof w?t[0]:t,w.merge(this,w.parseHTML(i[1],t&&t.nodeType?t.ownerDocument||t:r,!0)),A.test(i[1])&&w.isPlainObject(t))for(i in t)g(this[i])?this[i](t[i]):this.attr(i,t[i]);return this}return(o=r.getElementById(i[2]))&&(this[0]=o,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):g(e)?void 0!==n.ready?n.ready(e):e(w):w.makeArray(e,this)}).prototype=w.fn,q=w(r);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};w.fn.extend({has:function(e){var t=w(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(w.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&w(e);if(!D.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&w.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?w.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?u.call(w(e),this[0]):u.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(w.uniqueSort(w.merge(this.get(),w(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}w.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return k(e,\"parentNode\")},parentsUntil:function(e,t,n){return k(e,\"parentNode\",n)},next:function(e){return P(e,\"nextSibling\")},prev:function(e){return P(e,\"previousSibling\")},nextAll:function(e){return k(e,\"nextSibling\")},prevAll:function(e){return k(e,\"previousSibling\")},nextUntil:function(e,t,n){return k(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return k(e,\"previousSibling\",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return N(e,\"iframe\")?e.contentDocument:(N(e,\"template\")&&(e=e.content||e),w.merge([],e.childNodes))}},function(e,t){w.fn[e]=function(n,r){var i=w.map(this,t,n);return\"Until\"!==e.slice(-5)&&(r=n),r&&\"string\"==typeof r&&(i=w.filter(r,i)),this.length>1&&(O[e]||w.uniqueSort(i),H.test(e)&&i.reverse()),this.pushStack(i)}});var M=/[^\\x20\\t\\r\\n\\f]+/g;function R(e){var t={};return w.each(e.match(M)||[],function(e,n){t[n]=!0}),t}w.Callbacks=function(e){e=\"string\"==typeof e?R(e):w.extend({},e);var t,n,r,i,o=[],a=[],s=-1,u=function(){for(i=i||e.once,r=t=!0;a.length;s=-1){n=a.shift();while(++s<o.length)!1===o[s].apply(n[0],n[1])&&e.stopOnFalse&&(s=o.length,n=!1)}e.memory||(n=!1),t=!1,i&&(o=n?[]:\"\")},l={add:function(){return o&&(n&&!t&&(s=o.length-1,a.push(n)),function t(n){w.each(n,function(n,r){g(r)?e.unique&&l.has(r)||o.push(r):r&&r.length&&\"string\"!==x(r)&&t(r)})}(arguments),n&&!t&&u()),this},remove:function(){return w.each(arguments,function(e,t){var n;while((n=w.inArray(t,o,n))>-1)o.splice(n,1),n<=s&&s--}),this},has:function(e){return e?w.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=a=[],o=n=\"\",this},disabled:function(){return!o},lock:function(){return i=a=[],n||t||(o=n=\"\"),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=[e,(n=n||[]).slice?n.slice():n],a.push(n),t||u()),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!r}};return l};function I(e){return e}function W(e){throw e}function $(e,t,n,r){var i;try{e&&g(i=e.promise)?i.call(e).done(t).fail(n):e&&g(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}w.extend({Deferred:function(t){var n=[[\"notify\",\"progress\",w.Callbacks(\"memory\"),w.Callbacks(\"memory\"),2],[\"resolve\",\"done\",w.Callbacks(\"once memory\"),w.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",w.Callbacks(\"once memory\"),w.Callbacks(\"once memory\"),1,\"rejected\"]],r=\"pending\",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},\"catch\":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return w.Deferred(function(t){w.each(n,function(n,r){var i=g(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&g(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+\"With\"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){var o=0;function a(t,n,r,i){return function(){var s=this,u=arguments,l=function(){var e,l;if(!(t<o)){if((e=r.apply(s,u))===n.promise())throw new TypeError(\"Thenable self-resolution\");l=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,g(l)?i?l.call(e,a(o,n,I,i),a(o,n,W,i)):(o++,l.call(e,a(o,n,I,i),a(o,n,W,i),a(o,n,I,n.notifyWith))):(r!==I&&(s=void 0,u=[e]),(i||n.resolveWith)(s,u))}},c=i?l:function(){try{l()}catch(e){w.Deferred.exceptionHook&&w.Deferred.exceptionHook(e,c.stackTrace),t+1>=o&&(r!==W&&(s=void 0,u=[e]),n.rejectWith(s,u))}};t?c():(w.Deferred.getStackHook&&(c.stackTrace=w.Deferred.getStackHook()),e.setTimeout(c))}}return w.Deferred(function(e){n[0][3].add(a(0,e,g(i)?i:I,e.notifyWith)),n[1][3].add(a(0,e,g(t)?t:I)),n[2][3].add(a(0,e,g(r)?r:W))}).promise()},promise:function(e){return null!=e?w.extend(e,i):i}},o={};return w.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+\"With\"](this===o?void 0:this,arguments),this},o[t[0]+\"With\"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=o.call(arguments),a=w.Deferred(),s=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?o.call(arguments):n,--t||a.resolveWith(r,i)}};if(t<=1&&($(e,a.done(s(n)).resolve,a.reject,!t),\"pending\"===a.state()||g(i[n]&&i[n].then)))return a.then();while(n--)$(i[n],s(n),a.reject);return a.promise()}});var B=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;w.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&B.test(t.name)&&e.console.warn(\"jQuery.Deferred exception: \"+t.message,t.stack,n)},w.readyException=function(t){e.setTimeout(function(){throw t})};var F=w.Deferred();w.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){w.readyException(e)}),this},w.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--w.readyWait:w.isReady)||(w.isReady=!0,!0!==e&&--w.readyWait>0||F.resolveWith(r,[w]))}}),w.ready.then=F.then;function _(){r.removeEventListener(\"DOMContentLoaded\",_),e.removeEventListener(\"load\",_),w.ready()}\"complete\"===r.readyState||\"loading\"!==r.readyState&&!r.documentElement.doScroll?e.setTimeout(w.ready):(r.addEventListener(\"DOMContentLoaded\",_),e.addEventListener(\"load\",_));var z=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===x(n)){i=!0;for(s in n)z(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,g(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(w(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},X=/^-ms-/,U=/-([a-z])/g;function V(e,t){return t.toUpperCase()}function G(e){return e.replace(X,\"ms-\").replace(U,V)}var Y=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Q(){this.expando=w.expando+Q.uid++}Q.uid=1,Q.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Y(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[G(t)]=n;else for(r in t)i[G(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][G(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(G):(t=G(t))in r?[t]:t.match(M)||[]).length;while(n--)delete r[t[n]]}(void 0===t||w.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!w.isEmptyObject(t)}};var J=new Q,K=new Q,Z=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,ee=/[A-Z]/g;function te(e){return\"true\"===e||\"false\"!==e&&(\"null\"===e?null:e===+e+\"\"?+e:Z.test(e)?JSON.parse(e):e)}function ne(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(ee,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=te(n)}catch(e){}K.set(e,t,n)}else n=void 0;return n}w.extend({hasData:function(e){return K.hasData(e)||J.hasData(e)},data:function(e,t,n){return K.access(e,t,n)},removeData:function(e,t){K.remove(e,t)},_data:function(e,t,n){return J.access(e,t,n)},_removeData:function(e,t){J.remove(e,t)}}),w.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=K.get(o),1===o.nodeType&&!J.get(o,\"hasDataAttrs\"))){n=a.length;while(n--)a[n]&&0===(r=a[n].name).indexOf(\"data-\")&&(r=G(r.slice(5)),ne(o,r,i[r]));J.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof e?this.each(function(){K.set(this,e)}):z(this,function(t){var n;if(o&&void 0===t){if(void 0!==(n=K.get(o,e)))return n;if(void 0!==(n=ne(o,e)))return n}else this.each(function(){K.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){K.remove(this,e)})}}),w.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=J.get(e,t),n&&(!r||Array.isArray(n)?r=J.access(e,t,w.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=w.queue(e,t),r=n.length,i=n.shift(),o=w._queueHooks(e,t),a=function(){w.dequeue(e,t)};\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return J.get(e,n)||J.access(e,n,{empty:w.Callbacks(\"once memory\").add(function(){J.remove(e,[t+\"queue\",n])})})}}),w.fn.extend({queue:function(e,t){var n=2;return\"string\"!=typeof e&&(t=e,e=\"fx\",n--),arguments.length<n?w.queue(this[0],e):void 0===t?this:this.each(function(){var n=w.queue(this,e,t);w._queueHooks(this,e),\"fx\"===e&&\"inprogress\"!==n[0]&&w.dequeue(this,e)})},dequeue:function(e){return this.each(function(){w.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=w.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=J.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var re=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,ie=new RegExp(\"^(?:([+-])=|)(\"+re+\")([a-z%]*)$\",\"i\"),oe=[\"Top\",\"Right\",\"Bottom\",\"Left\"],ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&w.contains(e.ownerDocument,e)&&\"none\"===w.css(e,\"display\")},se=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i};function ue(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return w.css(e,t,\"\")},u=s(),l=n&&n[3]||(w.cssNumber[t]?\"\":\"px\"),c=(w.cssNumber[t]||\"px\"!==l&&+u)&&ie.exec(w.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)w.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,w.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var le={};function ce(e){var t,n=e.ownerDocument,r=e.nodeName,i=le[r];return i||(t=n.body.appendChild(n.createElement(r)),i=w.css(t,\"display\"),t.parentNode.removeChild(t),\"none\"===i&&(i=\"block\"),le[r]=i,i)}function fe(e,t){for(var n,r,i=[],o=0,a=e.length;o<a;o++)(r=e[o]).style&&(n=r.style.display,t?(\"none\"===n&&(i[o]=J.get(r,\"display\")||null,i[o]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(i[o]=ce(r))):\"none\"!==n&&(i[o]=\"none\",J.set(r,\"display\",n)));for(o=0;o<a;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}w.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?w(this).show():w(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i,he=/^$|^module$|\\/(?:java|ecma)script/i,ge={option:[1,\"<select multiple='multiple'>\",\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;function ye(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&N(e,t)?w.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)J.set(e[n],\"globalEval\",!t||J.get(t[n],\"globalEval\"))}var me=/<|&#?\\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===x(o))w.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+w.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;w.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&w.inArray(o,r)>-1)i&&i.push(o);else if(l=w.contains(o.ownerDocument,o),a=ye(f.appendChild(o),\"script\"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}!function(){var e=r.createDocumentFragment().appendChild(r.createElement(\"div\")),t=r.createElement(\"input\");t.setAttribute(\"type\",\"radio\"),t.setAttribute(\"checked\",\"checked\"),t.setAttribute(\"name\",\"t\"),e.appendChild(t),h.checkClone=e.cloneNode(!0).cloneNode(!0).lastChild.checked,e.innerHTML=\"<textarea>x</textarea>\",h.noCloneChecked=!!e.cloneNode(!0).lastChild.defaultValue}();var be=r.documentElement,we=/^key/,Te=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ce=/^([^.]*)(?:\\.(.+)|)/;function Ee(){return!0}function ke(){return!1}function Se(){try{return r.activeElement}catch(e){}}function De(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){\"string\"!=typeof n&&(r=r||n,n=void 0);for(s in t)De(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=ke;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return w().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=w.guid++)),e.each(function(){w.event.add(this,t,i,r,n)})}w.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=J.get(e);if(y){n.handler&&(n=(o=n).handler,i=o.selector),i&&w.find.matchesSelector(be,i),n.guid||(n.guid=w.guid++),(u=y.events)||(u=y.events={}),(a=y.handle)||(a=y.handle=function(t){return\"undefined\"!=typeof w&&w.event.triggered!==t.type?w.event.dispatch.apply(e,arguments):void 0}),l=(t=(t||\"\").match(M)||[\"\"]).length;while(l--)d=g=(s=Ce.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=w.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=w.event.special[d]||{},c=w.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&w.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(e,r,h,a)||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),w.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=J.hasData(e)&&J.get(e);if(y&&(u=y.events)){l=(t=(t||\"\").match(M)||[\"\"]).length;while(l--)if(s=Ce.exec(t[l])||[],d=g=s[1],h=(s[2]||\"\").split(\".\").sort(),d){f=w.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||w.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)w.event.remove(e,d+t[l],n,r,!0);w.isEmptyObject(u)&&J.remove(e,\"handle events\")}},dispatch:function(e){var t=w.event.fix(e),n,r,i,o,a,s,u=new Array(arguments.length),l=(J.get(this,\"events\")||{})[t.type]||[],c=w.event.special[t.type]||{};for(u[0]=t,n=1;n<arguments.length;n++)u[n]=arguments[n];if(t.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,t)){s=w.event.handlers.call(this,t,l),n=0;while((o=s[n++])&&!t.isPropagationStopped()){t.currentTarget=o.elem,r=0;while((a=o.handlers[r++])&&!t.isImmediatePropagationStopped())t.rnamespace&&!t.rnamespace.test(a.namespace)||(t.handleObj=a,t.data=a.data,void 0!==(i=((w.event.special[a.origType]||{}).handle||a.handler).apply(o.elem,u))&&!1===(t.result=i)&&(t.preventDefault(),t.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,t),t.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&e.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?w(i,this).index(l)>-1:w.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(e,t){Object.defineProperty(w.Event.prototype,e,{enumerable:!0,configurable:!0,get:g(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[w.expando]?e:new w.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==Se()&&this.focus)return this.focus(),!1},delegateType:\"focusin\"},blur:{trigger:function(){if(this===Se()&&this.blur)return this.blur(),!1},delegateType:\"focusout\"},click:{trigger:function(){if(\"checkbox\"===this.type&&this.click&&N(this,\"input\"))return this.click(),!1},_default:function(e){return N(e.target,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},w.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},w.Event=function(e,t){if(!(this instanceof w.Event))return new w.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ee:ke,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&w.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[w.expando]=!0},w.Event.prototype={constructor:w.Event,isDefaultPrevented:ke,isPropagationStopped:ke,isImmediatePropagationStopped:ke,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ee,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ee,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ee,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},w.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&we.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Te.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},w.event.addProp),w.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,t){w.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||w.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),w.fn.extend({on:function(e,t,n,r){return De(this,e,t,n,r)},one:function(e,t,n,r){return De(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,w(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=ke),this.each(function(){w.event.remove(this,e,n,t)})}});var Ne=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,Ae=/<script|<style|<link/i,je=/checked\\s*(?:[^=]|=\\s*.checked.)/i,qe=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function Le(e,t){return N(e,\"table\")&&N(11!==t.nodeType?t:t.firstChild,\"tr\")?w(e).children(\"tbody\")[0]||e:e}function He(e){return e.type=(null!==e.getAttribute(\"type\"))+\"/\"+e.type,e}function Oe(e){return\"true/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Pe(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(J.hasData(e)&&(o=J.access(e),a=J.set(t,o),l=o.events)){delete a.handle,a.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)w.event.add(t,i,l[i][n])}K.hasData(e)&&(s=K.access(e),u=w.extend({},s),K.set(t,u))}}function Me(e,t){var n=t.nodeName.toLowerCase();\"input\"===n&&pe.test(e.type)?t.checked=e.checked:\"input\"!==n&&\"textarea\"!==n||(t.defaultValue=e.defaultValue)}function Re(e,t,n,r){t=a.apply([],t);var i,o,s,u,l,c,f=0,p=e.length,d=p-1,y=t[0],v=g(y);if(v||p>1&&\"string\"==typeof y&&!h.checkClone&&je.test(y))return e.each(function(i){var o=e.eq(i);v&&(t[0]=y.call(this,i,o.html())),Re(o,t,n,r)});if(p&&(i=xe(t,e[0].ownerDocument,!1,e,r),o=i.firstChild,1===i.childNodes.length&&(i=o),o||r)){for(u=(s=w.map(ye(i,\"script\"),He)).length;f<p;f++)l=i,f!==d&&(l=w.clone(l,!0,!0),u&&w.merge(s,ye(l,\"script\"))),n.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,w.map(s,Oe),f=0;f<u;f++)l=s[f],he.test(l.type||\"\")&&!J.access(l,\"globalEval\")&&w.contains(c,l)&&(l.src&&\"module\"!==(l.type||\"\").toLowerCase()?w._evalUrl&&w._evalUrl(l.src):m(l.textContent.replace(qe,\"\"),c,l))}return e}function Ie(e,t,n){for(var r,i=t?w.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||w.cleanData(ye(r)),r.parentNode&&(n&&w.contains(r.ownerDocument,r)&&ve(ye(r,\"script\")),r.parentNode.removeChild(r));return e}w.extend({htmlPrefilter:function(e){return e.replace(Ne,\"<$1></$2>\")},clone:function(e,t,n){var r,i,o,a,s=e.cloneNode(!0),u=w.contains(e.ownerDocument,e);if(!(h.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||w.isXMLDoc(e)))for(a=ye(s),r=0,i=(o=ye(e)).length;r<i;r++)Me(o[r],a[r]);if(t)if(n)for(o=o||ye(e),a=a||ye(s),r=0,i=o.length;r<i;r++)Pe(o[r],a[r]);else Pe(e,s);return(a=ye(s,\"script\")).length>0&&ve(a,!u&&ye(e,\"script\")),s},cleanData:function(e){for(var t,n,r,i=w.event.special,o=0;void 0!==(n=e[o]);o++)if(Y(n)){if(t=n[J.expando]){if(t.events)for(r in t.events)i[r]?w.event.remove(n,r):w.removeEvent(n,r,t.handle);n[J.expando]=void 0}n[K.expando]&&(n[K.expando]=void 0)}}}),w.fn.extend({detach:function(e){return Ie(this,e,!0)},remove:function(e){return Ie(this,e)},text:function(e){return z(this,function(e){return void 0===e?w.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Re(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Le(this,e).appendChild(e)})},prepend:function(){return Re(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Le(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Re(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Re(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(w.cleanData(ye(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return w.clone(this,e,t)})},html:function(e){return z(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!Ae.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=w.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(w.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return Re(this,arguments,function(t){var n=this.parentNode;w.inArray(this,e)<0&&(w.cleanData(ye(this)),n&&n.replaceChild(t,this))},e)}}),w.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,t){w.fn[e]=function(e){for(var n,r=[],i=w(e),o=i.length-1,a=0;a<=o;a++)n=a===o?this:this.clone(!0),w(i[a])[t](n),s.apply(r,n.get());return this.pushStack(r)}});var We=new RegExp(\"^(\"+re+\")(?!px)[a-z%]+$\",\"i\"),$e=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)},Be=new RegExp(oe.join(\"|\"),\"i\");!function(){function t(){if(c){l.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",c.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",be.appendChild(l).appendChild(c);var t=e.getComputedStyle(c);i=\"1%\"!==t.top,u=12===n(t.marginLeft),c.style.right=\"60%\",s=36===n(t.right),o=36===n(t.width),c.style.position=\"absolute\",a=36===c.offsetWidth||\"absolute\",be.removeChild(l),c=null}}function n(e){return Math.round(parseFloat(e))}var i,o,a,s,u,l=r.createElement(\"div\"),c=r.createElement(\"div\");c.style&&(c.style.backgroundClip=\"content-box\",c.cloneNode(!0).style.backgroundClip=\"\",h.clearCloneStyle=\"content-box\"===c.style.backgroundClip,w.extend(h,{boxSizingReliable:function(){return t(),o},pixelBoxStyles:function(){return t(),s},pixelPosition:function(){return t(),i},reliableMarginLeft:function(){return t(),u},scrollboxSize:function(){return t(),a}}))}();function Fe(e,t,n){var r,i,o,a,s=e.style;return(n=n||$e(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||w.contains(e.ownerDocument,e)||(a=w.style(e,t)),!h.pixelBoxStyles()&&We.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}var ze=/^(none|table(?!-c[ea]).+)/,Xe=/^--/,Ue={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Ve={letterSpacing:\"0\",fontWeight:\"400\"},Ge=[\"Webkit\",\"Moz\",\"ms\"],Ye=r.createElement(\"div\").style;function Qe(e){if(e in Ye)return e;var t=e[0].toUpperCase()+e.slice(1),n=Ge.length;while(n--)if((e=Ge[n]+t)in Ye)return e}function Je(e){var t=w.cssProps[e];return t||(t=w.cssProps[e]=Qe(e)||e),t}function Ke(e,t,n){var r=ie.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Ze(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=w.css(e,n+oe[a],!0,i)),r?(\"content\"===n&&(u-=w.css(e,\"padding\"+oe[a],!0,i)),\"margin\"!==n&&(u-=w.css(e,\"border\"+oe[a]+\"Width\",!0,i))):(u+=w.css(e,\"padding\"+oe[a],!0,i),\"padding\"!==n?u+=w.css(e,\"border\"+oe[a]+\"Width\",!0,i):s+=w.css(e,\"border\"+oe[a]+\"Width\",!0,i));return!r&&o>=0&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))),u}function et(e,t,n){var r=$e(e),i=Fe(e,t,r),o=\"border-box\"===w.css(e,\"boxSizing\",!1,r),a=o;if(We.test(i)){if(!n)return i;i=\"auto\"}return a=a&&(h.boxSizingReliable()||i===e.style[t]),(\"auto\"===i||!parseFloat(i)&&\"inline\"===w.css(e,\"display\",!1,r))&&(i=e[\"offset\"+t[0].toUpperCase()+t.slice(1)],a=!0),(i=parseFloat(i)||0)+Ze(e,t,n||(o?\"border\":\"content\"),a,r,i)+\"px\"}w.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Fe(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=G(t),u=Xe.test(t),l=e.style;if(u||(t=Je(s)),a=w.cssHooks[t]||w.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"==(o=typeof n)&&(i=ie.exec(n))&&i[1]&&(n=ue(e,t,i),o=\"number\"),null!=n&&n===n&&(\"number\"===o&&(n+=i&&i[3]||(w.cssNumber[s]?\"\":\"px\")),h.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=G(t);return Xe.test(t)||(t=Je(s)),(a=w.cssHooks[t]||w.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Fe(e,t,r)),\"normal\"===i&&t in Ve&&(i=Ve[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),w.each([\"height\",\"width\"],function(e,t){w.cssHooks[t]={get:function(e,n,r){if(n)return!ze.test(w.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?et(e,t,r):se(e,Ue,function(){return et(e,t,r)})},set:function(e,n,r){var i,o=$e(e),a=\"border-box\"===w.css(e,\"boxSizing\",!1,o),s=r&&Ze(e,t,r,a,o);return a&&h.scrollboxSize()===o.position&&(s-=Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-parseFloat(o[t])-Ze(e,t,\"border\",!1,o)-.5)),s&&(i=ie.exec(n))&&\"px\"!==(i[3]||\"px\")&&(e.style[t]=n,n=w.css(e,t)),Ke(e,n,s)}}}),w.cssHooks.marginLeft=_e(h.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Fe(e,\"marginLeft\"))||e.getBoundingClientRect().left-se(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),w.each({margin:\"\",padding:\"\",border:\"Width\"},function(e,t){w.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o=\"string\"==typeof n?n.split(\" \"):[n];r<4;r++)i[e+oe[r]+t]=o[r]||o[r-2]||o[0];return i}},\"margin\"!==e&&(w.cssHooks[e+t].set=Ke)}),w.fn.extend({css:function(e,t){return z(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=$e(e),i=t.length;a<i;a++)o[t[a]]=w.css(e,t[a],!1,r);return o}return void 0!==n?w.style(e,t,n):w.css(e,t)},e,t,arguments.length>1)}});function tt(e,t,n,r,i){return new tt.prototype.init(e,t,n,r,i)}w.Tween=tt,tt.prototype={constructor:tt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||w.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(w.cssNumber[n]?\"\":\"px\")},cur:function(){var e=tt.propHooks[this.prop];return e&&e.get?e.get(this):tt.propHooks._default.get(this)},run:function(e){var t,n=tt.propHooks[this.prop];return this.options.duration?this.pos=t=w.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):tt.propHooks._default.set(this),this}},tt.prototype.init.prototype=tt.prototype,tt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=w.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){w.fx.step[e.prop]?w.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[w.cssProps[e.prop]]&&!w.cssHooks[e.prop]?e.elem[e.prop]=e.now:w.style(e.elem,e.prop,e.now+e.unit)}}},tt.propHooks.scrollTop=tt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},w.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:\"swing\"},w.fx=tt.prototype.init,w.fx.step={};var nt,rt,it=/^(?:toggle|show|hide)$/,ot=/queueHooks$/;function at(){rt&&(!1===r.hidden&&e.requestAnimationFrame?e.requestAnimationFrame(at):e.setTimeout(at,w.fx.interval),w.fx.tick())}function st(){return e.setTimeout(function(){nt=void 0}),nt=Date.now()}function ut(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=oe[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function lt(e,t,n){for(var r,i=(pt.tweeners[t]||[]).concat(pt.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ct(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=J.get(e,\"fxshow\");n.queue||(null==(a=w._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,w.queue(e,\"fx\").length||a.empty.fire()})}));for(r in t)if(i=t[r],it.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||w.style(e,r)}if((u=!w.isEmptyObject(t))||!w.isEmptyObject(d)){f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=J.get(e,\"display\")),\"none\"===(c=w.css(e,\"display\"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=w.css(e,\"display\"),fe([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===w.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1;for(r in d)u||(y?\"hidden\"in y&&(g=y.hidden):y=J.access(e,\"fxshow\",{display:l}),o&&(y.hidden=!g),g&&fe([e],!0),p.done(function(){g||fe([e]),J.remove(e,\"fxshow\");for(r in d)w.style(e,r,d[r])})),u=lt(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}}function ft(e,t){var n,r,i,o,a;for(n in e)if(r=G(n),i=t[r],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=w.cssHooks[r])&&\"expand\"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function pt(e,t,n){var r,i,o=0,a=pt.prefilters.length,s=w.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=nt||st(),n=Math.max(0,l.startTime+l.duration-t),r=1-(n/l.duration||0),o=0,a=l.tweens.length;o<a;o++)l.tweens[o].run(r);return s.notifyWith(e,[l,r,n]),r<1&&a?n:(a||s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:w.extend({},t),opts:w.extend(!0,{specialEasing:{},easing:w.easing._default},n),originalProperties:t,originalOptions:n,startTime:nt||st(),duration:n.duration,tweens:[],createTween:function(t,n){var r=w.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(ft(c,l.opts.specialEasing);o<a;o++)if(r=pt.prefilters[o].call(l,e,c,l.opts))return g(r.stop)&&(w._queueHooks(l.elem,l.opts.queue).stop=r.stop.bind(r)),r;return w.map(c,lt,l),g(l.opts.start)&&l.opts.start.call(e,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),w.fx.timer(w.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l}w.Animation=w.extend(pt,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return ue(n.elem,e,ie.exec(t),n),n}]},tweener:function(e,t){g(e)?(t=e,e=[\"*\"]):e=e.match(M);for(var n,r=0,i=e.length;r<i;r++)n=e[r],pt.tweeners[n]=pt.tweeners[n]||[],pt.tweeners[n].unshift(t)},prefilters:[ct],prefilter:function(e,t){t?pt.prefilters.unshift(e):pt.prefilters.push(e)}}),w.speed=function(e,t,n){var r=e&&\"object\"==typeof e?w.extend({},e):{complete:n||!n&&t||g(e)&&e,duration:e,easing:n&&t||t&&!g(t)&&t};return w.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in w.fx.speeds?r.duration=w.fx.speeds[r.duration]:r.duration=w.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){g(r.old)&&r.old.call(this),r.queue&&w.dequeue(this,r.queue)},r},w.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=w.isEmptyObject(e),o=w.speed(t,n,r),a=function(){var t=pt(this,w.extend({},e),o);(i||J.get(this,\"finish\"))&&t.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return\"string\"!=typeof e&&(n=t,t=e,e=void 0),t&&!1!==e&&this.queue(e||\"fx\",[]),this.each(function(){var t=!0,i=null!=e&&e+\"queueHooks\",o=w.timers,a=J.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&ot.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||w.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||\"fx\"),this.each(function(){var t,n=J.get(this),r=n[e+\"queue\"],i=n[e+\"queueHooks\"],o=w.timers,a=r?r.length:0;for(n.finish=!0,w.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<a;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),w.each([\"toggle\",\"show\",\"hide\"],function(e,t){var n=w.fn[t];w.fn[t]=function(e,r,i){return null==e||\"boolean\"==typeof e?n.apply(this,arguments):this.animate(ut(t,!0),e,r,i)}}),w.each({slideDown:ut(\"show\"),slideUp:ut(\"hide\"),slideToggle:ut(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,t){w.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),w.timers=[],w.fx.tick=function(){var e,t=0,n=w.timers;for(nt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||w.fx.stop(),nt=void 0},w.fx.timer=function(e){w.timers.push(e),w.fx.start()},w.fx.interval=13,w.fx.start=function(){rt||(rt=!0,at())},w.fx.stop=function(){rt=null},w.fx.speeds={slow:600,fast:200,_default:400},w.fn.delay=function(t,n){return t=w.fx?w.fx.speeds[t]||t:t,n=n||\"fx\",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=r.createElement(\"input\"),t=r.createElement(\"select\").appendChild(r.createElement(\"option\"));e.type=\"checkbox\",h.checkOn=\"\"!==e.value,h.optSelected=t.selected,(e=r.createElement(\"input\")).value=\"t\",e.type=\"radio\",h.radioValue=\"t\"===e.value}();var dt,ht=w.expr.attrHandle;w.fn.extend({attr:function(e,t){return z(this,w.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){w.removeAttr(this,e)})}}),w.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?w.prop(e,t,n):(1===o&&w.isXMLDoc(e)||(i=w.attrHooks[t.toLowerCase()]||(w.expr.match.bool.test(t)?dt:void 0)),void 0!==n?null===n?void w.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=w.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!h.radioValue&&\"radio\"===t&&N(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(M);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),dt={set:function(e,t,n){return!1===t?w.removeAttr(e,n):e.setAttribute(n,n),n}},w.each(w.expr.match.bool.source.match(/\\w+/g),function(e,t){var n=ht[t]||w.find.attr;ht[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=ht[a],ht[a]=i,i=null!=n(e,t,r)?a:null,ht[a]=o),i}});var gt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;w.fn.extend({prop:function(e,t){return z(this,w.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[w.propFix[e]||e]})}}),w.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&w.isXMLDoc(e)||(t=w.propFix[t]||t,i=w.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=w.find.attr(e,\"tabindex\");return t?parseInt(t,10):gt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),h.optSelected||(w.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),w.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){w.propFix[this.toLowerCase()]=this});function vt(e){return(e.match(M)||[]).join(\" \")}function mt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function xt(e){return Array.isArray(e)?e:\"string\"==typeof e?e.match(M)||[]:[]}w.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){w(this).addClass(e.call(this,t,mt(this)))});if((t=xt(e)).length)while(n=this[u++])if(i=mt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=t[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){w(this).removeClass(e.call(this,t,mt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((t=xt(e)).length)while(n=this[u++])if(i=mt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=t[a++])while(r.indexOf(\" \"+o+\" \")>-1)r=r.replace(\" \"+o+\" \",\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(e,t){var n=typeof e,r=\"string\"===n||Array.isArray(e);return\"boolean\"==typeof t&&r?t?this.addClass(e):this.removeClass(e):g(e)?this.each(function(n){w(this).toggleClass(e.call(this,n,mt(this),t),t)}):this.each(function(){var t,i,o,a;if(r){i=0,o=w(this),a=xt(e);while(t=a[i++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else void 0!==e&&\"boolean\"!==n||((t=mt(this))&&J.set(this,\"__className__\",t),this.setAttribute&&this.setAttribute(\"class\",t||!1===e?\"\":J.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&(\" \"+vt(mt(n))+\" \").indexOf(t)>-1)return!0;return!1}});var bt=/\\r/g;w.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=g(e),this.each(function(n){var i;1===this.nodeType&&(null==(i=r?e.call(this,n,w(this).val()):e)?i=\"\":\"number\"==typeof i?i+=\"\":Array.isArray(i)&&(i=w.map(i,function(e){return null==e?\"\":e+\"\"})),(t=w.valHooks[this.type]||w.valHooks[this.nodeName.toLowerCase()])&&\"set\"in t&&void 0!==t.set(this,i,\"value\")||(this.value=i))});if(i)return(t=w.valHooks[i.type]||w.valHooks[i.nodeName.toLowerCase()])&&\"get\"in t&&void 0!==(n=t.get(i,\"value\"))?n:\"string\"==typeof(n=i.value)?n.replace(bt,\"\"):null==n?\"\":n}}}),w.extend({valHooks:{option:{get:function(e){var t=w.find.attr(e,\"value\");return null!=t?t:vt(w.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!N(n.parentNode,\"optgroup\"))){if(t=w(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=w.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=w.inArray(w.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),w.each([\"radio\",\"checkbox\"],function(){w.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=w.inArray(w(e).val(),t)>-1}},h.checkOn||(w.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),h.focusin=\"onfocusin\"in e;var wt=/^(?:focusinfocus|focusoutblur)$/,Tt=function(e){e.stopPropagation()};w.extend(w.event,{trigger:function(t,n,i,o){var a,s,u,l,c,p,d,h,v=[i||r],m=f.call(t,\"type\")?t.type:t,x=f.call(t,\"namespace\")?t.namespace.split(\".\"):[];if(s=h=u=i=i||r,3!==i.nodeType&&8!==i.nodeType&&!wt.test(m+w.event.triggered)&&(m.indexOf(\".\")>-1&&(m=(x=m.split(\".\")).shift(),x.sort()),c=m.indexOf(\":\")<0&&\"on\"+m,t=t[w.expando]?t:new w.Event(m,\"object\"==typeof t&&t),t.isTrigger=o?2:3,t.namespace=x.join(\".\"),t.rnamespace=t.namespace?new RegExp(\"(^|\\\\.)\"+x.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,t.result=void 0,t.target||(t.target=i),n=null==n?[t]:w.makeArray(n,[t]),d=w.event.special[m]||{},o||!d.trigger||!1!==d.trigger.apply(i,n))){if(!o&&!d.noBubble&&!y(i)){for(l=d.delegateType||m,wt.test(l+m)||(s=s.parentNode);s;s=s.parentNode)v.push(s),u=s;u===(i.ownerDocument||r)&&v.push(u.defaultView||u.parentWindow||e)}a=0;while((s=v[a++])&&!t.isPropagationStopped())h=s,t.type=a>1?l:d.bindType||m,(p=(J.get(s,\"events\")||{})[t.type]&&J.get(s,\"handle\"))&&p.apply(s,n),(p=c&&s[c])&&p.apply&&Y(s)&&(t.result=p.apply(s,n),!1===t.result&&t.preventDefault());return t.type=m,o||t.isDefaultPrevented()||d._default&&!1!==d._default.apply(v.pop(),n)||!Y(i)||c&&g(i[m])&&!y(i)&&((u=i[c])&&(i[c]=null),w.event.triggered=m,t.isPropagationStopped()&&h.addEventListener(m,Tt),i[m](),t.isPropagationStopped()&&h.removeEventListener(m,Tt),w.event.triggered=void 0,u&&(i[c]=u)),t.result}},simulate:function(e,t,n){var r=w.extend(new w.Event,n,{type:e,isSimulated:!0});w.event.trigger(r,null,t)}}),w.fn.extend({trigger:function(e,t){return this.each(function(){w.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return w.event.trigger(e,t,n,!0)}}),h.focusin||w.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){var n=function(e){w.event.simulate(t,e.target,w.event.fix(e))};w.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=J.access(r,t);i||r.addEventListener(e,n,!0),J.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=J.access(r,t)-1;i?J.access(r,t,i):(r.removeEventListener(e,n,!0),J.remove(r,t))}}});var Ct=e.location,Et=Date.now(),kt=/\\?/;w.parseXML=function(t){var n;if(!t||\"string\"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,\"text/xml\")}catch(e){n=void 0}return n&&!n.getElementsByTagName(\"parsererror\").length||w.error(\"Invalid XML: \"+t),n};var St=/\\[\\]$/,Dt=/\\r?\\n/g,Nt=/^(?:submit|button|image|reset|file)$/i,At=/^(?:input|select|textarea|keygen)/i;function jt(e,t,n,r){var i;if(Array.isArray(t))w.each(t,function(t,i){n||St.test(e)?r(e,i):jt(e+\"[\"+(\"object\"==typeof i&&null!=i?t:\"\")+\"]\",i,n,r)});else if(n||\"object\"!==x(t))r(e,t);else for(i in t)jt(e+\"[\"+i+\"]\",t[i],n,r)}w.param=function(e,t){var n,r=[],i=function(e,t){var n=g(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(Array.isArray(e)||e.jquery&&!w.isPlainObject(e))w.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join(\"&\")},w.fn.extend({serialize:function(){return w.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=w.prop(this,\"elements\");return e?w.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!w(this).is(\":disabled\")&&At.test(this.nodeName)&&!Nt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=w(this).val();return null==n?null:Array.isArray(n)?w.map(n,function(e){return{name:t.name,value:e.replace(Dt,\"\\r\\n\")}}):{name:t.name,value:n.replace(Dt,\"\\r\\n\")}}).get()}});var qt=/%20/g,Lt=/#.*$/,Ht=/([?&])_=[^&]*/,Ot=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,Pt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Mt=/^(?:GET|HEAD)$/,Rt=/^\\/\\//,It={},Wt={},$t=\"*/\".concat(\"*\"),Bt=r.createElement(\"a\");Bt.href=Ct.href;function Ft(e){return function(t,n){\"string\"!=typeof t&&(n=t,t=\"*\");var r,i=0,o=t.toLowerCase().match(M)||[];if(g(n))while(r=o[i++])\"+\"===r[0]?(r=r.slice(1)||\"*\",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function _t(e,t,n,r){var i={},o=e===Wt;function a(s){var u;return i[s]=!0,w.each(e[s]||[],function(e,s){var l=s(t,n,r);return\"string\"!=typeof l||o||i[l]?o?!(u=l):void 0:(t.dataTypes.unshift(l),a(l),!1)}),u}return a(t.dataTypes[0])||!i[\"*\"]&&a(\"*\")}function zt(e,t){var n,r,i=w.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&w.extend(!0,e,r),e}function Xt(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}function Ut(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}w.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ct.href,type:\"GET\",isLocal:Pt.test(Ct.protocol),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":$t,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/\\bxml\\b/,html:/\\bhtml/,json:/\\bjson\\b/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":w.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,w.ajaxSettings),t):zt(w.ajaxSettings,e)},ajaxPrefilter:Ft(It),ajaxTransport:Ft(Wt),ajax:function(t,n){\"object\"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=w.ajaxSetup({},n),g=h.context||h,y=h.context&&(g.nodeType||g.jquery)?w(g):w.event,v=w.Deferred(),m=w.Callbacks(\"once memory\"),x=h.statusCode||{},b={},T={},C=\"canceled\",E={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s){s={};while(t=Ot.exec(a))s[t[1].toLowerCase()]=t[2]}t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=T[e.toLowerCase()]=T[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)E.always(e[E.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||C;return i&&i.abort(t),k(0,t),this}};if(v.promise(E),h.url=((t||h.url||Ct.href)+\"\").replace(Rt,Ct.protocol+\"//\"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||\"*\").toLowerCase().match(M)||[\"\"],null==h.crossDomain){l=r.createElement(\"a\");try{l.href=h.url,l.href=l.href,h.crossDomain=Bt.protocol+\"//\"+Bt.host!=l.protocol+\"//\"+l.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&\"string\"!=typeof h.data&&(h.data=w.param(h.data,h.traditional)),_t(It,h,n,E),c)return E;(f=w.event&&h.global)&&0==w.active++&&w.event.trigger(\"ajaxStart\"),h.type=h.type.toUpperCase(),h.hasContent=!Mt.test(h.type),o=h.url.replace(Lt,\"\"),h.hasContent?h.data&&h.processData&&0===(h.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&(h.data=h.data.replace(qt,\"+\")):(d=h.url.slice(o.length),h.data&&(h.processData||\"string\"==typeof h.data)&&(o+=(kt.test(o)?\"&\":\"?\")+h.data,delete h.data),!1===h.cache&&(o=o.replace(Ht,\"$1\"),d=(kt.test(o)?\"&\":\"?\")+\"_=\"+Et+++d),h.url=o+d),h.ifModified&&(w.lastModified[o]&&E.setRequestHeader(\"If-Modified-Since\",w.lastModified[o]),w.etag[o]&&E.setRequestHeader(\"If-None-Match\",w.etag[o])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&E.setRequestHeader(\"Content-Type\",h.contentType),E.setRequestHeader(\"Accept\",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+(\"*\"!==h.dataTypes[0]?\", \"+$t+\"; q=0.01\":\"\"):h.accepts[\"*\"]);for(p in h.headers)E.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,E,h)||c))return E.abort();if(C=\"abort\",m.add(h.complete),E.done(h.success),E.fail(h.error),i=_t(Wt,h,n,E)){if(E.readyState=1,f&&y.trigger(\"ajaxSend\",[E,h]),c)return E;h.async&&h.timeout>0&&(u=e.setTimeout(function(){E.abort(\"timeout\")},h.timeout));try{c=!1,i.send(b,k)}catch(e){if(c)throw e;k(-1,e)}}else k(-1,\"No Transport\");function k(t,n,r,s){var l,p,d,b,T,C=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||\"\",E.readyState=t>0?4:0,l=t>=200&&t<300||304===t,r&&(b=Xt(h,E,r)),b=Ut(h,b,E,l),l?(h.ifModified&&((T=E.getResponseHeader(\"Last-Modified\"))&&(w.lastModified[o]=T),(T=E.getResponseHeader(\"etag\"))&&(w.etag[o]=T)),204===t||\"HEAD\"===h.type?C=\"nocontent\":304===t?C=\"notmodified\":(C=b.state,p=b.data,l=!(d=b.error))):(d=C,!t&&C||(C=\"error\",t<0&&(t=0))),E.status=t,E.statusText=(n||C)+\"\",l?v.resolveWith(g,[p,C,E]):v.rejectWith(g,[E,C,d]),E.statusCode(x),x=void 0,f&&y.trigger(l?\"ajaxSuccess\":\"ajaxError\",[E,h,l?p:d]),m.fireWith(g,[E,C]),f&&(y.trigger(\"ajaxComplete\",[E,h]),--w.active||w.event.trigger(\"ajaxStop\")))}return E},getJSON:function(e,t,n){return w.get(e,t,n,\"json\")},getScript:function(e,t){return w.get(e,void 0,t,\"script\")}}),w.each([\"get\",\"post\"],function(e,t){w[t]=function(e,n,r,i){return g(n)&&(i=i||r,r=n,n=void 0),w.ajax(w.extend({url:e,type:t,dataType:i,data:n,success:r},w.isPlainObject(e)&&e))}}),w._evalUrl=function(e){return w.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,\"throws\":!0})},w.fn.extend({wrapAll:function(e){var t;return this[0]&&(g(e)&&(e=e.call(this[0])),t=w(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return g(e)?this.each(function(t){w(this).wrapInner(e.call(this,t))}):this.each(function(){var t=w(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=g(e);return this.each(function(n){w(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){w(this).replaceWith(this.childNodes)}),this}}),w.expr.pseudos.hidden=function(e){return!w.expr.pseudos.visible(e)},w.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},w.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(e){}};var Vt={0:200,1223:204},Gt=w.ajaxSettings.xhr();h.cors=!!Gt&&\"withCredentials\"in Gt,h.ajax=Gt=!!Gt,w.ajaxTransport(function(t){var n,r;if(h.cors||Gt&&!t.crossDomain)return{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i[\"X-Requested-With\"]||(i[\"X-Requested-With\"]=\"XMLHttpRequest\");for(a in i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.ontimeout=s.onreadystatechange=null,\"abort\"===e?s.abort():\"error\"===e?\"number\"!=typeof s.status?o(0,\"error\"):o(s.status,s.statusText):o(Vt[s.status]||s.status,s.statusText,\"text\"!==(s.responseType||\"text\")||\"string\"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=s.ontimeout=n(\"error\"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n(\"abort\");try{s.send(t.hasContent&&t.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}}),w.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),w.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/\\b(?:java|ecma)script\\b/},converters:{\"text script\":function(e){return w.globalEval(e),e}}}),w.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),w.ajaxTransport(\"script\",function(e){if(e.crossDomain){var t,n;return{send:function(i,o){t=w(\"<script>\").prop({charset:e.scriptCharset,src:e.url}).on(\"load error\",n=function(e){t.remove(),n=null,e&&o(\"error\"===e.type?404:200,e.type)}),r.head.appendChild(t[0])},abort:function(){n&&n()}}}});var Yt=[],Qt=/(=)\\?(?=&|$)|\\?\\?/;w.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Yt.pop()||w.expando+\"_\"+Et++;return this[e]=!0,e}}),w.ajaxPrefilter(\"json jsonp\",function(t,n,r){var i,o,a,s=!1!==t.jsonp&&(Qt.test(t.url)?\"url\":\"string\"==typeof t.data&&0===(t.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Qt.test(t.data)&&\"data\");if(s||\"jsonp\"===t.dataTypes[0])return i=t.jsonpCallback=g(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(Qt,\"$1\"+i):!1!==t.jsonp&&(t.url+=(kt.test(t.url)?\"&\":\"?\")+t.jsonp+\"=\"+i),t.converters[\"script json\"]=function(){return a||w.error(i+\" was not called\"),a[0]},t.dataTypes[0]=\"json\",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?w(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,Yt.push(i)),a&&g(o)&&o(a[0]),a=o=void 0}),\"script\"}),h.createHTMLDocument=function(){var e=r.implementation.createHTMLDocument(\"\").body;return e.innerHTML=\"<form></form><form></form>\",2===e.childNodes.length}(),w.parseHTML=function(e,t,n){if(\"string\"!=typeof e)return[];\"boolean\"==typeof t&&(n=t,t=!1);var i,o,a;return t||(h.createHTMLDocument?((i=(t=r.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=r.location.href,t.head.appendChild(i)):t=r),o=A.exec(e),a=!n&&[],o?[t.createElement(o[1])]:(o=xe([e],t,a),a&&a.length&&w(a).remove(),w.merge([],o.childNodes))},w.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return s>-1&&(r=vt(e.slice(s)),e=e.slice(0,s)),g(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),a.length>0&&w.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?w(\"<div>\").append(w.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},w.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){w.fn[t]=function(e){return this.on(t,e)}}),w.expr.pseudos.animated=function(e){return w.grep(w.timers,function(t){return e===t.elem}).length},w.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l,c=w.css(e,\"position\"),f=w(e),p={};\"static\"===c&&(e.style.position=\"relative\"),s=f.offset(),o=w.css(e,\"top\"),u=w.css(e,\"left\"),(l=(\"absolute\"===c||\"fixed\"===c)&&(o+u).indexOf(\"auto\")>-1)?(a=(r=f.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),g(t)&&(t=t.call(e,n,w.extend({},s))),null!=t.top&&(p.top=t.top-s.top+a),null!=t.left&&(p.left=t.left-s.left+i),\"using\"in t?t.using.call(e,p):f.css(p)}},w.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){w.offset.setOffset(this,e,t)});var t,n,r=this[0];if(r)return r.getClientRects().length?(t=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:t.top+n.pageYOffset,left:t.left+n.pageXOffset}):{top:0,left:0}},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===w.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===w.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=w(e).offset()).top+=w.css(e,\"borderTopWidth\",!0),i.left+=w.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-w.css(r,\"marginTop\",!0),left:t.left-i.left-w.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===w.css(e,\"position\"))e=e.offsetParent;return e||be})}}),w.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(e,t){var n=\"pageYOffset\"===t;w.fn[e]=function(r){return z(this,function(e,r,i){var o;if(y(e)?o=e:9===e.nodeType&&(o=e.defaultView),void 0===i)return o?o[t]:e[r];o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i},e,r,arguments.length)}}),w.each([\"top\",\"left\"],function(e,t){w.cssHooks[t]=_e(h.pixelPosition,function(e,n){if(n)return n=Fe(e,t),We.test(n)?w(e).position()[t]+\"px\":n})}),w.each({Height:\"height\",Width:\"width\"},function(e,t){w.each({padding:\"inner\"+e,content:t,\"\":\"outer\"+e},function(n,r){w.fn[r]=function(i,o){var a=arguments.length&&(n||\"boolean\"!=typeof i),s=n||(!0===i||!0===o?\"margin\":\"border\");return z(this,function(t,n,i){var o;return y(t)?0===r.indexOf(\"outer\")?t[\"inner\"+e]:t.document.documentElement[\"client\"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body[\"scroll\"+e],o[\"scroll\"+e],t.body[\"offset\"+e],o[\"offset\"+e],o[\"client\"+e])):void 0===i?w.css(t,n,s):w.style(t,n,i,s)},t,a?i:void 0,a)}})}),w.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,t){w.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),w.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),w.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)}}),w.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),g(e))return r=o.call(arguments,2),i=function(){return e.apply(t||this,r.concat(o.call(arguments)))},i.guid=e.guid=e.guid||w.guid++,i},w.holdReady=function(e){e?w.readyWait++:w.ready(!0)},w.isArray=Array.isArray,w.parseJSON=JSON.parse,w.nodeName=N,w.isFunction=g,w.isWindow=y,w.camelCase=G,w.type=x,w.now=Date.now,w.isNumeric=function(e){var t=w.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return w});var Jt=e.jQuery,Kt=e.$;return w.noConflict=function(t){return e.$===w&&(e.$=Kt),t&&e.jQuery===w&&(e.jQuery=Jt),w},t||(e.jQuery=e.$=w),w});\n\n}\n\n//Included:lib/300.castelog.v1.inicializacion.part.js\n/*lib:castelog@0.0.1*/\nCastelog = (function(factory, scope) {\n    const output = factory.call(scope);\n    if(typeof window === \"object\") {\n        window[\"Castelog\"] = output;\n    }\n    if(typeof global === \"object\") {\n        global[\"Castelog\"] = output;\n    }\n    if(typeof module === \"object\") {\n        module.exports = output;\n    }\n    return output;\n})(function() {\n    if((typeof(window) !== \"undefined\") && (typeof(window.Castelog) !== \"undefined\")) {\n        return window.Castelog;\n    }\n    if((typeof(global) !== \"undefined\") && (typeof(global.Castelog) !== \"undefined\")) {\n        return global.Castelog;\n    }\n    \n    const globalmente = (typeof(window) !== \"undefined\") ? window : (typeof(global) !== \"undefined\") ? global : this;\n    const Castelog = {\n        globalmente,\n        metodos: {},\n        modulos: {},\n        variables: {\n            noop: function() {},\n            mysql2: undefined,\n            Automatic_http_rest_api_interface: Automatic_http_rest_api_interface,\n            RanasDB: typeof globalmente.RanasDB !== \"undefined\" ? globalmente.RanasDB : undefined,\n            SimplestDB: globalmente.SimplestDB,\n            axios: typeof window !== \"object\" ? require(\"axios\") : globalmente.axios,\n            ejs: globalmente.ejs,\n            globales: {\n                entorno: \"development\"\n            },\n            alfabeto_ingles: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\"\"),\n            Entorno_de_testeo: function(parametros = {}) {\n                Object.assign(this, parametros);\n                return this;\n            }\n        },\n        compilacion: {\n  \"ruta_del_sistema\": \"/home/carlos/Escritorio/Nuevo/Castelog/castelog-ultimo\",\n  \"sistema_operativo\": \"\",\n  \"fecha\": \"2023/20/23 15:49.90.282\"\n}\n    };\n\n    return Castelog;\n}, this);\n\n//Included:lib/320.castelog.v1.metodos.un_filtrado_por.js\nCastelog.metodos.un_filtrado_por = function(lista, filtro) {\n    if(typeof lista === \"object\") {\n        if(Array.isArray(lista)) {\n            return lista.reduce((output, value, index) => {\n                const otherValue = filtro(value, index, index, output, lista);\n                if (otherValue === true) {\n                    output.push(value);\n                }\n                return output;\n            }, []);\n        } else {\n            const keys = Object.keys(lista);\n            return lista.reduce((output, key, index) => {\n                const value = lista[key];\n                if(filtro(value, key, index, output, lista)) {\n                    output[key] = value;\n                }\n                return output;\n            }, {});\n        }\n    } else throw new Error(\"Required argument «lista» to be an array in order to «Castelog.metodos.un_filtrado_por»\")\n};\n\n//Included:lib/321.castelog.v1.metodos.un_mapeado_por.js\nCastelog.metodos.un_mapeado_por = function (lista, mapeo) {\n    if (typeof lista === \"object\") {\n        if (Array.isArray(lista)) {\n            return lista.reduce((output, value, index) => {\n                const otherValue = mapeo(value, index, index, output, lista);\n                if (typeof otherValue !== \"undefined\") {\n                    output.push(value);\n                }\n                return output;\n            }, []);\n        } else {\n            const keys = Object.keys(lista);\n            return keys.reduce((output, key, index) => {\n                const value = lista[key];\n                const otherValue = mapeo(value, key, index, output, lista);\n                if (typeof otherValue !== \"undefined\") {\n                    output[key] = value;\n                }\n                return output;\n            }, {});\n        }\n    } else throw new Error(\"Required argument «lista» to be an array in order to «Castelog.metodos.un_mapeado_por»\")\n};\n\n//Included:lib/322.castelog.v1.metodos.un_reducido_por.js\nCastelog.metodos.un_reducido_por = function (lista, reduccion, base = false) {\n    if (typeof lista === \"object\") {\n        if (Array.isArray(lista)) {\n            return lista.reduce((output, value, index) => {\n                const otherValue = reduccion(value, output, index, index, lista);\n                if (typeof otherValue !== \"undefined\") {\n                    output = otherValue;\n                }\n                return output;\n            }, base || []);\n        } else {\n            const keys = Object.keys(lista);\n            return keys.reduce((output, key, index) => {\n                const value = lista[key];\n                const otherValue = reduccion(value, output, key, index, lista);\n                if (typeof otherValue !== \"undefined\") {\n                    output = otherValue;\n                }\n                return output;\n            }, base || {});\n        }\n    } else throw new Error(\"Required argument «lista» to be an array in order to «Castelog.metodos.un_reducido_por»\")\n};\n\n//Included:lib/402.castelog.v1.variables.un_servidor_activo_de_control_remoto.part.js\nCastelog.variables.ServidorActivoDeControlRemoto = class {\n    constructor(configurations, directory) {\n        this.activos = [];\n        this.pasivos = [];\n        Object.assign(this, { configurations, directory });\n    }\n    async start() {\n        try {\n            this.on_initialize_configurations();\n            this.on_initialize_http_server();\n            this.on_initialize_socket_io_server();\n            await this.on_run_http_server();\n        } catch(error) {\n            console.log(\"Error en «Castelog.variables.ServidorActivoDeControlRemoto.prototype.start»:\", error)\n            throw error;\n        }\n    }\n    on_initialize_configurations() {\n        // @TOREVIEW...\n        Object.assign(this.configurations, {\n            \"nativo.socket.host\": \"127.0.0.1\",\n            \"nativo.socket.port\": \"9989\",\n            \"nativo.socket.path\": \"/centralita/de/control/remoto\"\n        }, this.configurations);\n    }\n    on_initialize_http_server() {\n        // @TOREVIEW...\n        this.http_server = undefined;\n        if(typeof this.configurations[\"nativo.http.server\"] !== \"undefined\") {\n            this.http_server = this.configurations[\"nativo.http.server\"];\n        } else {\n            this.http_server = require(\"http\").createServer((...args) => this.on_respond_request(...args));\n        }\n    }\n    on_initialize_socket_io_server() {\n        // @TOREVIEW...\n        this.socket_server = require(\"socket.io\").io(this.http_server);\n        this.socket_server.on(\"connect\", socket_client => {\n            if(this.configurations[\"nativo.socket.events\"]) {\n                const allEvents = this.configurations[\"nativo.socket.events\"];\n                const eventsKeys = Object.keys(allEvents);\n                for(let indexEvent = 0; indexEvent < eventsKeys.length; indexEvent++) {\n                    const eventKey = eventsKeys[indexEvent];\n                    const eventValue = allEvents[eventKey];\n                    const [ event_id, event_function ] = eventValue;\n                    socket_client.on(event_id, event_function);\n                }\n            }\n            socket_client.on(\"unregister passive device\", (data) => {\n                const { user, password } = data;\n                // filter socket_server.?getAllConnections\n                // so you can get the user+password key checked\n                // then return assigned passive devices\n                socket_client.emit(\"unregister passive device response\", { error: \"not yet available\" });\n            });\n            socket_client.on(\"register passive device\", (data) => {\n                const { user, password } = data;\n                // filter socket_server.?getAllConnections\n                // so you can get the user+password key checked\n                // then return assigned passive devices\n                socket_client.emit(\"register passive device response\", { error: \"not yet available\" });\n            });\n            socket_client.on(\"list passive devices\", (data) => {\n                const { } = data;\n                // filter socket_server.?getAllConnections\n                // so you can get the user+password key checked\n                // then return assigned passive devices\n                socket_client.emit(\"list passive devices response\", { error: \"not yet available\" });\n            });\n            socket_client.on(\"execute on passive devices\", (data) => {\n                const { targets, code } = data;\n                // filter socket_server.?getAllConnections\n                // so you can get the user+password key checked\n                // then return assigned passive devices\n                socket_client.emit(\"execute on passive devices response\", { error: \"not yet available\" });\n            });\n        });\n    }\n    on_run_http_server() {\n        // @TOREVIEW...\n        const port = this.configurations[\"nativo.socket.port\"] || 9989;\n        const host = this.configurations[\"nativo.socket.host\"] || \"127.0.0.1\";\n        const path = this.configurations[\"nativo.socket.path\"] || \"/\";\n        return new Promise((ok, fail) => {\n            try {\n                this.http_server.listen(port, host, () => {\n                    const socket_url = \"ws://\" + host + \":\" + port + path;\n                    console.log(\"Un servidor activo de control remoto en:\\n  - \" + socket_url);\n                    return ok({ http_server: this.http_server, socket_io: this.socket_server, socket_url });\n                });\n            } catch (error) {\n                return fail(error);\n            }\n        });\n    }\n    on_respond_request(request, response) {\n        // @TOREVIEW...\n        response.write(\"This an active remote control server of Castelog.\");\n        return response.end();\n    }\n};\n\n//Included:lib/403.castelog.v1.variables.un_cliente_activo_de_control_remoto.part.js\nCastelog.variables.ClienteActivoDeControlRemoto = class {\n    constructor(configuraciones, directorio) {\n        Object.assign(this, { configuraciones, directorio });\n    }\n    async start() {\n        try {\n            this.on_initialize_configurations();\n            this.on_initialize_connection();\n        } catch (error) {\n            console.log(\"Error en «Castelog.variables.ClienteActivoDeControlRemoto.prototype.start»:\", error)\n            throw error;\n        }\n    }\n    on_initialize_configurations() {\n        Object.assign(this.configurations, {\n            \"nativo.socket.host\": \"127.0.0.1\",\n            \"nativo.socket.port\": \"9985\",\n            \"nativo.socket.path\": \"/centralita/de/control/remoto\"\n        }, this.configurations);\n    }\n    on_initialize_connection() {\n        try {\n            // @TOREVIEW...\n            if(this.connection) {\n                return this.connection;\n            }\n            const socket_port = this.configurations[\"nativo.socket.port\"] || 9989;\n            const socket_host = this.configurations[\"nativo.socket.host\"] || \"127.0.0.1\";\n            const socket_path = this.configurations[\"nativo.socket.path\"] || \"/\";\n            const socket_url = \"ws://\" + socket_host + \":\" + socket_port + socket_path\n            this.connection = require(\"socket.io-client\").io(socket_url);\n            this.connection.on(\"list passive devices response\", (parameters) => {\n                console.log(\"list passive devices response\", parameters);\n            });\n            this.connection.on(\"execute on passive device response\", (parameters) => {\n                console.log(\"execute on passive device response\", parameters);\n            });\n        } catch (error) {\n            console.log(\"Error en «Castelog.variables.ClienteActivoDeControlRemoto.prototype.on_initialize_connection»:\", error)\n            throw error;\n        }\n    }\n    async command_to_list_passive_devices(self_id, self_password) {\n        try {\n            // @TODO...\n        } catch(error) {\n            \n        }\n    }\n    async command_to_execute_on_passive_device(target_id, target_password, target_code, target_metadata) {\n        try {\n            // @TODO...\n        } catch (error) {\n            // @TODO...\n        }\n    }\n\n};\n\n//Included:lib/404.castelog.v1.variables.un_cliente_pasivo_de_control_remoto.part.js\nCastelog.variables.ClientePasivoDeControlRemoto = class {\n    constructor(configuraciones, directorio) {\n        Object.assign(this, { configuraciones, directorio });\n    }\n    async start() {\n        try {\n            this.on_initialize_configurations();\n            this.on_initialize_connection();\n        } catch (error) {\n            console.log(\"Error en «Castelog.variables.ClientePasivoDeControlRemoto.prototype.start»:\", error)\n            throw error;\n        }\n    }\n    on_initialize_configurations() {\n        Object.assign(this.configurations, {\n            \"nativo.socket.host\": \"127.0.0.1\",\n            \"nativo.socket.port\": \"9985\",\n            \"nativo.socket.path\": \"/centralita/de/control/remoto\"\n        }, this.configurations);\n    }\n    on_initialize_connection() {\n        try {\n            // @TOREVIEW...\n            if(this.connection) {\n                return this.connection;\n            }\n            const socket_port = this.configurations[\"nativo.socket.port\"] || 9989;\n            const socket_host = this.configurations[\"nativo.socket.host\"] || \"127.0.0.1\";\n            const socket_path = this.configurations[\"nativo.socket.path\"] || \"/\";\n            const socket_url = \"ws://\" + socket_host + \":\" + socket_port + socket_path;\n            const socket_id = \"abcdef\";\n            this.connection = require(\"socket.io-client\").io(socket_url);\n            this.connection.on(\"connect\", (parameters) => {\n                console.log(\"connect\", parameters);\n                this.connection.emit(\"register passive device\", { name: socket_id, password: socket_id });\n            });\n            this.connection.on(\"disconnect\", (parameters) => {\n                console.log(\"disconnect\", parameters);\n                this.connection.emit(\"unregister passive device\", { name: socket_id, password: socket_id });\n            });\n            this.connection.on(\"register passive device response\", () => {\n                console.log(\"ok: current device was registered as passive device\");\n            });\n            this.connection.on(\"unregister passive device response\", () => {\n                console.log(\"ok: current device was unregistered as passive device\");\n            });\n            this.connection.on(\"execute on passive device remotely\", (parameters) => {\n                console.log(\"execute on passive device remotely\", parameters);\n            });\n        } catch (error) {\n            console.log(\"Error en «Castelog.variables.ClientePasivoDeControlRemoto.prototype.on_initialize_connection»:\", error)\n            throw error;\n        }\n    }\n};\n\n//Included:lib/405.castelog.v1.variables.un_servidor_pasivo_de_control_remoto.part.js\nCastelog.variables.ServidorPasivoDeControlRemoto = class {\n    constructor(configurations, directory) {\n        this.activos = [];\n        this.pasivos = [];\n        Object.assign(this, { configurations, directory });\n    }\n    async start() {\n        try {\n            this.on_initialize_configurations();\n            this.on_initialize_http_server();\n            this.on_initialize_socket_io_server();\n            await this.on_run_http_server();\n        } catch(error) {\n            this.log(\"Error en «Castelog.variables.ServidorPasivoDeControlRemoto.prototype.start»:\", error)\n            throw error;\n        }\n    }\n    on_initialize_configurations() {\n        Object.assign(this.configurations, {\n            \"nativo.socket.host\": \"127.0.0.1\",\n            \"nativo.socket.port\": \"9985\",\n            \"nativo.socket.path\": \"/centralita/de/control/remoto\",\n            \"nativo.socket.log\": true,\n            \"nativo.server.host\": \"127.0.0.1\",\n            \"nativo.server.port\": \"9987\",\n            \"nativo.server.path\": \"/centralita/de/control/remoto\",\n            \"nativo.server.log\": true,\n        }, this.configurations);\n    }\n    on_initialize_http_server() {\n        this.http_server = undefined;\n        if(typeof this.configurations[\"nativo.http.server\"] !== \"undefined\") {\n            this.http_server = this.configurations[\"nativo.http.server\"];\n        } else {\n            this.http_server = require(\"http\").createServer((...args) => this.on_respond_request(...args));\n        }\n    }\n    on_initialize_socket_io_server() {\n        this.socket_server = require(\"socket.io\").io(this.http_server);\n        this.socket_server.on(\"connect\", socket_client => {\n            if(this.configurations[\"nativo.socket.events\"]) {\n                const allEvents = this.configurations[\"nativo.socket.events\"];\n                const eventsKeys = Object.keys(allEvents);\n                for(let indexEvent = 0; indexEvent < eventsKeys.length; indexEvent++) {\n                    const eventKey = eventsKeys[indexEvent];\n                    const eventValue = allEvents[eventKey];\n                    const [ event_id, event_function ] = eventValue;\n                    socket_client.on(event_id, event_function);\n                }\n            }\n            socket_client.on(\"execute on passive device remotely\", (data) => {\n                const { code } = data;\n                eval(code);\n            });\n        });\n    }\n    on_run_http_server() {\n        const port = this.configurations[\"nativo.socket.port\"] || 9989;\n        const host = this.configurations[\"nativo.socket.host\"] || \"127.0.0.1\";\n        const path = this.configurations[\"nativo.socket.path\"] || \"/\";\n        return new Promise((ok, fail) => {\n            try {\n                this.http_server.listen(port, host, () => {\n                    const socket_url = \"ws://\" + host + \":\" + port + path;\n                    this.log(\"New sockets (passive) app listening on: \" + socket_url);\n                    return ok({ http_server: this.http_server, socket_io: this.socket_server, socket_url });\n                });\n            } catch (error) {\n                return fail(error);\n            }\n        });\n    }\n    on_respond_request(request, response) {\n        response.write(\"This a passive remote control server of Castelog.\");\n        return response.end();\n    }\n    log(...args) {\n        if(this.configurations[\"nativo.socket.log\"]) {\n            console.log(...args);\n        }\n    }\n};\n\n//Included:lib/406.castelog.v1.variables.una_aplicacion_sintactica_universal.part.js\nCastelog.variables.Aplicacion_sintactica_universal = class {\n    static get DEFAULT_CONFIGURATION() {\n        return {\n            separador: \".\"\n        };\n    }\n    constructor(comandos, configuracion) {\n        this.comandos = comandos;\n        this.configuracion = Object.assign({}, this.constructor.DEFAULT_CONFIGURATION, configuracion);\n    }\n    execute(command, parameters) {\n        try {\n            const command_path = command.split(this.configuracion.separador);\n            let value = this.comandos;\n            for(let index = 0; index < command_path.length; index++) {\n                const command_step = command_path[index];\n                if(!(command_step in value)) {\n                    throw new Error(\"Required command step «\" + command_step + \"» on command path «\" + command_path.splice(0, index).join(this.configuracion.separador) + \"» in order to «Castelog.variables.Aplicacion_sintactica_universal.execute» with command «\" + command + \"»\");\n                }\n                value = value[command_step];\n            }\n            if(!(value instanceof Castelog.variables.Punto_sintactico_universal)) {\n                throw new Error(\"Required command path «\" + command + \"» to be a «Castelog.variables.Punto_sintactico_universal» in order to «Castelog.variables.Aplicacion_sintactica_universal.execute» with command «\" + command + \"»\");\n            }\n            return value.run(parameters);\n        } catch(error) {\n            return this.onError(error, command, parameters);\n        }\n    }\n    onError(error, command, parameters) {\n        console.log(\"Error ejecutando comando «\" + command + \"» de aplicación sintáctica universal:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/407.castelog.v1.variables.un_punto_sintactico_universal.part.js\nCastelog.variables.Punto_sintactico_universal = class {\n    constructor(comando, onError) {\n        this.comando = comando;\n        this.onError = onError ? onError : (error, command, parameters) => {\n            console.log(\"Error ejecutando comando de punto sintáctico universal «\" + command + \"»:\", error);\n            throw error;\n        };\n    }\n    run(parametros) {\n        try {\n            return this.comando(parametros);\n        } catch(error) {\n            return this.onError(error, command, parameters);\n        }\n    }\n};\n\n//Included:lib/408.01.castelog.v1.variables.un_utilities_helper_para_mysql2.part.js\nCastelog.variables.un_utilities_helper_para_mysql2 = class {\n    constructor() {}\n    escapeValue(text) {\n        if (typeof text !== \"string\") throw new Error(\"Required text to be a string in order to «escapeValue«\");\n        return require(\"mysql2\").escape(text);\n    }\n    escapeId(id) {\n        if (typeof id !== \"string\") throw new Error(\"Required id to be a string in order to «escapeId«\");\n        return require(\"mysql2\").escapeId(id);\n    }\n    escapeToOperator(operator) {\n        const validOperators = {\n            \"<\": \" < \",\n            \"es menos que\": \" < \",\n            \">\": \" > \",\n            \"es más que\": \" > \",\n            \"<=\": \" <= \",\n            \"es menos o igual que\": \" <= \",\n            \">=\": \" >= \",\n            \"es más o igual que\": \" >= \",\n            \"=\": \" = \",\n            \"es igual que\": \" = \",\n            \"!=\": \" != \",\n            \"no es igual que\": \" != \"\n        };\n        if(operator in validOperators) {\n            return validOperators[operator];\n        }\n        throw new Error(\"Required «operator» to be a valid known operator in order to «escapeToOperator»\");\n    }\n    escapeToWhereExpression(list) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToWhereExpression»\");\n        const mysql2 = require(\"mysql2\");\n        let out = \"\";\n        out += \"WHERE 1 = 1\";\n        for(let index = 0; index < list.length; index++) {\n            const item = list[index];\n            const [ subject, operator, predicate, predicateOptions = { as: \"value\" } ] = item;\n            out += \"\\n  AND \";\n            out += mysql2.escapeId(subject);\n            out += this.escapeToOperator(operator);\n            if(!(\"as\" in predicateOptions)) {\n                predicateOptions.as = \"value\";\n            }\n            if(predicateOptions.as === \"value\") {\n                out += this.escapeValue(predicate);\n            } else if (predicateOptions.as === \"id\") {\n                out += this.escapeId(predicate);\n            } else if (predicateOptions.as === \"list\") {\n                out += this.escapeToValuesExpression(predicate);\n            } else if (predicateOptions.as === \"null\") {\n                out += \"null\";\n            } else throw new Error(\"Required predicateOption to be a valid known predicate option for as property in order to «escapeToWhereExpression»\");\n        }\n        return out;\n    }\n    escapeToFieldsExpression(list) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToFieldsExpression«\");\n        let out = \"(\";\n        for (let index = 0; index < list.length; index++) {\n            const item = list[index];\n            out += (index !== 0) ? \", \" : \"\";\n            out += this.escapeId(item);\n        }\n        out += \")\";\n        return out;\n    }\n    escapeToValuesExpression(list) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToValuesExpression«\");\n        let out = \"(\";\n        for(let index = 0; index < list.length; index++) {\n            const item = list[index];\n            out += (index !== 0) ? \", \" : \"\";\n            out += this.escapeValue(item);\n        }\n        out += \")\";\n        return out;\n    }\n    escapeToSetValuesExpression(values) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToSetValuesExpression«\");\n        const list = Object.keys(values);\n        for (let index = 0; index < list.length; index++) {\n            const key = list[index];\n            const value = values[key];\n            out += (index !== 0) ? \", \" : \"\";\n            out += this.escapeId(key);\n            out += \" = \";\n            out += this.escapeValue(value);\n        }\n        return out;\n    }\n    escapeToIdsArray(list) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToIdsArray«\");\n        return list.map(item => require(\"mysql2\").escapeId(item));\n    }\n    escapeToValuesArray(list) {\n        if (!Array.isArray(list)) throw new Error(\"Required list to be an array in order to «escapeToValuesArray«\");\n        return list.map(item => require(\"mysql2\").escape(item));\n    }\n};\n\n//Included:lib/408.02.castelog.v1.variables.un_proxy_de_pool_de_conexiones_para_mysql2.part.js\nCastelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2 = class extends Castelog.variables.un_utilities_helper_para_mysql2 {\n    constructor(pool, options = {}) {\n        super();\n        this.pool = pool;\n        Object.assign(this, options);\n    }\n    getConnection() {\n        return this.pool.getConnection();\n    }\n    create(options) {\n        return new Castelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2(this.pool, options);\n    }\n    // Schema:\n    async getSchema() {\n        try {\n            return this.schema;\n        } catch (error) {\n            throw error;\n        }\n    }\n    buildSelectQuery(modelo, filtrando, ordenando, agrupando, paginando, db, objetivo) {\n        let query = \"\";\n        query += \"SELECT * FROM \";\n        query += this.escapeId(modelo);\n        query += \"\\n\";\n        query += this.escapeToWhereExpression(filtrando);\n        if(Array.isArray(ordenando) && ordenando.length) {\n            query += \"\\n  ORDER BY \";\n            for(let index = 0; index < ordenando.length; index++) {\n                const orden = ordenando[index];\n                const isDesc = orden.startsWith(\"!\");\n                const columna = isDesc ? orden.substr(1) : orden;\n                if(index !== 0) {\n                    query += \", \";\n                }\n                query += \"\" + this.escapeId(columna) + (isDesc ? \" DESC\" : \" ASC\");\n            }\n        }\n        if(Array.isArray(paginando)) {\n            const [ page = 1, items = 20 ] = paginando;\n            const offset = page * (items - 1);\n            query += \"\\n  LIMIT \" + items;\n            query += \"\\n  OFFSET \" + offset;\n        }\n        return query;\n    }\n    // Select\n    async select(modelo, filtrando, ordenando, agrupando, paginando, db = \"system\", adaptador = Castelog.variables.SimplestDB, objetivo = \"a varios ítems\") {\n        try {\n            if(objetivo === \"a varios ítems\") {\n                return await this.select_many(modelo, filtrando, ordenando, agrupando, paginando, db, adaptador);\n            } else if(objetivo === \"a un ítem\") {\n                return await this.select_one(modelo, filtrando, ordenando, agrupando, paginando, db, adaptador);\n            } else if(objetivo === \"al primer ítem\") {\n                return await this.select_first(modelo, filtrando, ordenando, agrupando, paginando, db, adaptador);\n            } else if(objetivo === \"al último ítem\") {\n                return await this.select_last(modelo, filtrando, ordenando, agrupando, paginando, db, adaptador);\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n    async select_many(modelo, filtrando, ordenando, agrupando, paginando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = this.buildSelectQuery(modelo, filtrando, ordenando, agrupando, paginando, db);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async select_one(modelo, filtrando, ordenando, agrupando, paginando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = this.buildSelectQuery(modelo, filtrando, ordenando, agrupando, paginando, db);\n            const result = await connection.query(query);\n            const [ output, fields ] = result;\n            if(output.length > 1) throw new Error(\"Required output to be 1 and no more than 1 row in order to «Castelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2.select_one»\");\n            if(output.length === 0) return undefined;\n            const [row] = output;\n            return row;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async select_first(modelo, filtrando, ordenando, agrupando, paginando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = this.buildSelectQuery(modelo, filtrando, ordenando, agrupando, paginando, db);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            if (output.length === 0) return undefined;\n            const [row] = output;\n            return row;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async select_last(modelo, filtrando, ordenando, agrupando, paginando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = this.buildSelectQuery(modelo, filtrando, ordenando, agrupando, paginando, db);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            if (output.length === 0) return undefined;\n            const row = output.pop();\n            return row;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Insert\n    buildInsertManyQuery(modelo, items) {\n        if(items.length < 1) throw new Error(\"Required parameter «items» to be an array of 1 or more items in order to «buildInsertManyQuery»\");\n        const [item] = items;\n        const columnas = Object.keys(item);\n        let query = \"\";\n        query += \"INSERT INTO \";\n        query += this.escapeId(modelo);\n        query += \"\\n\";\n        query += this.escapeToFieldsExpression(columnas);\n        query += \" VALUES \\n\";\n        for(let index = 0; index < items.length; index++) {\n            const iteratedItem = items[index];\n            const values = Object.values(iteratedItem);\n            if(index !== 0) {\n                query += \",\\n\";\n            }\n            query += this.escapeToValuesExpression(values);\n        }\n        return query;\n    }\n    buildInsertOneQuery(modelo, item) {\n        const columnas = Object.keys(item);\n        const valores = Object.values(item);\n        let query = \"\";\n        query += \"INSERT INTO \";\n        query += this.escapeId(modelo);\n        query += \"\\n\";\n        query += this.escapeToFieldsExpression(columnas);\n        query += \" VALUES \\n\";\n        query += this.escapeToValuesExpression(valores);\n        return query;\n    }\n    insert(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        return Array.isArray(valor) ? this.insert_many(modelo, valor, db, adaptador) : this.insert_one(modelo, valor, db, adaptador);\n    }\n    async insert_one(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildInsertOneQuery(modelo, valor);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async insert_many(modelo, valores, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildInsertManyQuery(modelo, valores);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Update\n    async update(modelo, filtrando, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        return Array.isArray(filtrando) ? this.update_many(modelo, filtrando, valor, db, adaptador) : this.update_one(modelo, filtrando, valor, db, adaptador);\n    }\n    buildUpdateManyQuery(modelo, filtrando, valor) {\n        if (valor.length < 1) throw new Error(\"Required parameter «valor» to be an object in order to «buildUpdateManyQuery»\");\n        let query = \"\";\n        query += \"UPDATE \";\n        query += this.escapeId(modelo);\n        query += \"\\n\" + this.escapeToWhereExpression(filtrando);\n        query += \"\\nSET\\n\";\n        query += this.escapeToSetValuesExpression(valor);\n        return query;\n    }\n    buildUpdateOneQuery(modelo, filtrando, valor) {\n        if (valor.length < 1) throw new Error(\"Required parameter «valor» to be an object in order to «buildUpdateOneQuery»\");\n        let query = \"\";\n        query += \"UPDATE \";\n        query += this.escapeId(modelo);\n        query += \"\\n\" + this.escapeToWhereExpression(filtrando);\n        query += \"\\nSET\\n\";\n        query += this.escapeToSetValuesExpression(valor);\n        return query;\n    }\n    async update_one(modelo, filtrando, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildUpdateOneQuery(modelo, filtrando, valor);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async update_many(modelo, filtrando, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildUpdateManyQuery(modelo, filtrando, valor);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Delete\n    async delete(modelo, filtrando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        return Array.isArray(filtrando) ? this.delete_many(modelo, filtrando, db, adaptador) : this.delete_one(modelo, filtrando, db, adaptador);\n    }\n    buildDeleteManyQuery(modelo, filtrando) {\n        let query = \"\";\n        query += \"DELETE FROM \";\n        query += this.escapeId(modelo);\n        query += \"\\n\" + this.escapeToWhereExpression(filtrando);\n        return query;\n    }\n    buildDeleteOneQuery(modelo, filtrando) {\n        if (filtrando.length < 1) throw new Error(\"Required parameter «filtrando» to be an array of 1 or more items in order to «buildDeleteOneQuery»\");\n        let query = \"\";\n        query += \"DELETE FROM \";\n        query += this.escapeId(modelo);\n        query += \"\\n\" + this.escapeToWhereExpression(filtrando);\n        return query;\n    }\n    async delete_one(modelo, filtrando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildDeleteOneQuery(modelo, filtrando);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    async delete_many(modelo, filtrando, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            const query = await this.buildDeleteManyQuery(modelo, filtrando);\n            const result = await connection.query(query);\n            const [output, fields] = result;\n            return output;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Metacrud:\n    async add_table(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async add_column(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async add_database(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async execute_script(modelo, valor, db = \"system\", adaptador = Castelog.variables.SimplestDB) {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async alter_table() {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async alter_column() {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async drop_table() {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async drop_column() {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n    async drop_database() {\n        try {\n            const connection = await this.getConnection();\n            // @TODO...\n            return { message: \"This work is still to be done!\" };\n        } catch (error) {\n            throw error;\n        }\n    }\n};\n\n//Included:lib/408.03.castelog.v1.variables.un_proxy_de_conexion_para_mysql2.part.js\nCastelog.variables.un_proxy_de_conexion_para_mysql2 = class extends Castelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2 {\n    constructor(connection, options = {}) {\n        super();\n        this.connection = connection;\n        Object.assign(this, options);\n    }\n    getConnection() {\n        return this.connection;\n    }\n    create(options) {\n        return new Castelog.variables.un_proxy_de_conexion_para_mysql2(this.connection, options);\n    }\n};\n\n//Included:lib/501.castelog.v1.metodos.una_peticion_http.part.js\nCastelog.variables.cliente_http = Castelog.variables.axios.create();\n\nCastelog.metodos.una_peticion_http = function (url, method_p, data, headers, client = Castelog.variables.cliente_http, en_errores = console.log) {\n    const errorHandler = (typeof en_errores === \"function\") ? en_errores : error => console.log(\"Error en petición HTTP:\", error);\n    const requests_client = (typeof client === \"function\") ? client : Castelog.variables.cliente_http;\n    try {\n        const method = method_p ? method_p.toLowerCase() : \"get\";\n        return requests_client[method](url, data, { headers }).catch(errorHandler);\n    } catch (error) {\n        return errorHandler(error) || error;\n    }\n};\n\n//Included:lib/502.castelog.v1.metodos.un_cacheo.part.js\nCastelog.metodos.un_cacheo = function(clave, valor, condicion) {\n    let condicionFinal = condicion;\n    if(typeof condicion === \"function\") {\n        condicionFinal = condicion();\n    }\n    NoSeRefresca:\n    if(!condicionFinal) {\n        const cacheDB = Castelog.variables.SimplestDB.getCache();\n        const coincidencias = cacheDB.select(\"cache\", item => item.key === clave);\n        const coincidenciasIds = Object.keys(coincidencias);\n        if (coincidenciasIds.length === 0) {\n            break NoSeRefresca;\n        } else if (coincidenciasIds.length > 1) {\n            throw new Error(\"Clave de cacheo «\" + clave + \"» corrupta por concurrencia de \" + coincidenciasIds.length + \" registros (0001).\");\n        }\n        return coincidencias[coincidenciasIds[0]].value;\n    }\n    let valorFinal = valor;\n    if (typeof valor === \"function\") {\n        valorFinal = valor();\n    }\n    const cacheDB = Castelog.variables.SimplestDB.getCache();\n    const coincidencias = cacheDB.select(\"cache\", item => item.key === clave);\n    const coincidenciasIds = Object.keys(coincidencias);\n    if(coincidenciasIds.length === 0) {\n        const item = cacheDB.insert(\"cache\", { key: clave, value: valorFinal });\n        return item.value;\n    } else if(coincidenciasIds.length > 1) {\n        throw new Error(\"Clave de cacheo «\" + clave + \"» corrupta por concurrencia de \" + coincidenciasIds.length + \" registros (0002).\");\n    }\n    const coincidencia = coincidencias[coincidenciasIds[0]];\n    cacheDB.update(\"cache\", coincidencia.id, { valor: valorFinal });\n    return valorFinal;\n};\n\n//Included:lib/503.castelog.v1.metodos.un_modulo_importado.part.js\nCastelog.metodos.un_modulo_importado = function(id, file_dir = undefined, process_dir = undefined) {\n    try {\n        // console.log(\"0. iniciando importacion de: \" + id);\n        // Intento 1. De la cache propia:\n        // console.log(\"intento 1: de la cache propia\");\n        if(id in Castelog.modulos) {\n            // console.log(\"Funcionó el método 1.\");\n            return Castelog.modulos[id].value;\n        }\n        // Intento 2. Del require normal:\n        // console.log(\"intento 2: del require normal\");\n        if(typeof(Castelog.globalmente.require) === \"function\") {\n            try {\n                const modulix = Castelog.globalmente.require(id);\n                // console.log(\"Funcionó el método 2.\");\n                return modulix;\n            } catch (error) {\n                // noop.\n            }\n        }\n        // Intento 3. Cambiando las rutas + de la cache propia:\n        // console.log(\"intento 3: cambiando rutas + de la cache propia\");\n        let id2 = id;\n        if(id.startsWith(\"./\") && file_dir) {\n            id2 = id.replace(/^\\.\\//g, file_dir.replace(/\\/$/g, \"\") + \"/\");\n        } else if(id.startsWith(\"@/\") && process_dir) {\n            id2 = id.replace(/^\\.\\//g, process_dir.replace(/\\/$/g, \"\") + \"/\");\n        }\n        if(id2 in Castelog.modulos) {\n            const mod = Castelog.modulos[id2].value;\n            // console.log(\"Funcionó el método 3 con: \" + id2);\n            return mod;\n        }\n        // Intento 4. Cambiando las rutas + del require normal:\n        // console.log(\"intento 4: cambiando rutas + del require normal\");\n        if(typeof(Castelog.globalmente.require) === \"function\") {\n            try {\n                const mod = require(id2);\n                // console.log(\"Funcionó el método 4 con: \" + id2);\n                return mod;\n            } catch (error) {\n                // Ya no hay más intentos, se lanza error:\n                throw error;\n            }\n        }\n        throw new Error(`No se pudo importar módulo porque no existe «${id2}» importable con «require(...)» ni tampoco en «Castelog.modulos»`);\n    } catch (error) {\n        console.log(\"Error al importar módulo: \" + id);\n        throw error;\n    }\n};\n\n//Included:lib/503.castelog.v1.metodos.una_exportacion_de_modulo_universal_estandar.part.js\nCastelog.metodos.una_exportacion_de_modulo_universal_estandar = function(id, modulo, file_dir = undefined, process_dir = undefined) {\n    try {\n        Castelog.modulos[id] = {\n            filedir: file_dir,\n            processdir: process_dir,\n            value: modulo\n        };\n    } catch (error) {\n        console.log(\"Error al exportar módulo universal estándar: \" + id);\n        throw error;\n    }\n};\n\n//Included:lib/503.castelog.v1.metodos.una_importacion_de_modulo_universal_estandar.part.js\nCastelog.metodos.una_importacion_de_modulo_universal_estandar = function(id, errores = false) {\n    try {\n        if(!(id in Castelog.modulos)) {\n            throw new Error(\"Módulo universal estándar llamado «\" + id + \"» no fue encontrado.\");\n        }\n        return Castelog.modulos[id].value;\n    } catch (error) {\n        if(typeof errores === \"function\") {\n            const errorOutput = errores(error);\n            if(errorOutput !== \"undefined\") {\n                return errorOutput;\n            }\n        }\n        console.log(\"Error al importar módulo universal estándar: \" + id);\n        throw error;\n    }\n};\n\n//Included:lib/504.castelog.v1.metodos.un_modulo_exportado.part.js\nCastelog.metodos.un_modulo_exportado = function(id, modulo, factory = undefined, file_dir = undefined, process_dir = undefined) {\n    // console.log(\"0. iniciando exportacion de: \" + id);\n    // Persistencia 1. En la cache propia:\n    // console.log(\"1. persistencia en cache propia: \");\n    Castelog.modulos[id] = { value: modulo, factory };\n    // Persistencia 2. En el module.exports normal:\n    if(typeof(module) !== \"undefined\") {\n        // console.log(\"2. persistencia en module.exports normal: \");\n        try {\n            module.exports = modulo;\n        } catch (error) {\n            // noop.\n        }\n    }\n    // Persistencia 3. Cambiando las rutas + cache propia:\n    if(process_dir) {\n        if(id.startsWith(process_dir)) {\n            const path_relative_to_process = id.replace(process_dir, \"@/\").replace(/\\/+/g, \"/\");\n            Castelog.modulos[path_relative_to_process] = { value: modulo, factory };\n        }\n    }\n    // Ya no hay más persistencias, se retorna el módulo con ruta original:\n    return Castelog.modulos[id].value;\n};\n\n//Included:lib/504.castelog.v1.metodos.una_plantilla.js\nCastelog.variables.plantillas_config_por_defecto = {};\nCastelog.variables.plantillas_settings_por_defecto = { delimiter: \":\", async: false };\n\nCastelog.metodos.una_plantilla = function(fn, defaultConfig = {}, defaultSettings = {}) {\n    if(typeof fn === \"string\") {\n        return (config_p, settings_p) => {\n            const config = Object.assign({}, Castelog.variables.plantillas_config_por_defecto, defaultConfig, config_p);\n            const settings = Object.assign({}, Castelog.variables.plantillas_settings_por_defecto, defaultSettings, settings_p);\n            const parameters = { config };\n            return Castelog.variables.ejs.render(fn, parameters, settings);\n        };\n    } else if(typeof fn === \"function\") {\n        return (config, settings) => {\n            return fn(\n                Object.assign({}, defaultConfig, config),\n                Object.assign({}, defaultSettings, settings),\n            );\n        };\n    } else throw new Error(\"Tipo de plantilla no identificado (válidos:'string' y 'function'\");\n};\n\n//Included:lib/505.castelog.v1.metodos.una_lectura_de_fichero.js\nCastelog.metodos.una_lectura_de_fichero = function(file, codificacion = \"utf8\", modelId_ = \"fs\", fsSystem = \"simplestdb.fs\") {\n    if(fsSystem === \"simplestdb.fs\") {\n        let modelId = modelId_;\n        if(modelId_ === null) {\n            modelId = \"fs\";\n        } else if(typeof modelId_ === \"undefined\") {\n            modelId = \"fs\";\n        }\n        const sdb_fs = Castelog.variables.SimplestDB.getFS();\n        const previous_files = sdb_fs.select(modelId, item => item.path === file);\n        const keys = Object.keys(previous_files);\n        if(!keys.length) {\n            return undefined;\n        } else if(keys.length > 1) {\n            throw new Error(\"Fichero corrupto por duplicidad de ruta al leer: \" + file + \" [00909]\");\n        }\n        return previous_files[keys[0]].contents;\n    } else if(fsSystem === \"node.fs\") {\n        return require(\"fs\").readFileSync(file, codificacion);\n    } else {\n        throw new Error(\"Modalidad de sistema de ficheros «\" + fsSystem + \"» no identificada. Solo disponibles: 'simplestdb.fs' y 'node.fs'. [0001]\");\n    }\n};\n\n//Included:lib/506.castelog.v1.metodos.una_escritura_de_fichero.js\nCastelog.metodos.una_escritura_de_fichero = function (file, contents, codificacion, modelId_ = \"fs\", fsSystem = \"simplestdb.fs\") {\n    if (fsSystem === \"simplestdb.fs\") {\n        let modelId = modelId_;\n        if(modelId_ === null) {\n            modelId = \"fs\";\n        } else if(typeof modelId_ === \"undefined\") {\n            modelId = \"fs\";\n        }\n        const sdb_fs = Castelog.variables.SimplestDB.getFS();\n        const previous_files = sdb_fs.select(modelId, item => item.path === file);\n        const keys = Object.keys(previous_files);\n        if(!keys.length) {\n            return sdb_fs.insert(modelId, { path: file, contents: contents || \"\" });\n        } else if(keys.length > 1) {\n            throw new Error(\"Fichero corrupto por duplicidad de ruta al escribir: \" + file + \" [00808]\");\n        }\n        sdb_fs.update(modelId, previous_files[keys[0]].id, { contents });\n        return previous_files[keys[0]];\n    } else if (fsSystem === \"node.fs\") {\n        return require(\"fs\").writeFileSync(file, contents, codificacion);\n    } else {\n        throw new Error(\"Modalidad de sistema de ficheros «\" + fsSystem + \"» no identificada. Solo disponibles: 'simplestdb.fs' y 'node.fs'. [0002]\");\n    }\n};\n\n//Included:lib/507.castelog.v1.metodos.una_copia_de_ficheros.js\nCastelog.metodos.una_copia_de_ficheros = function (file, contents, codificacion, modelId_ = \"fs\", fsSystem = \"simplestdb.fs\") {\n    if (fsSystem === \"simplestdb.fs\") {\n        let modelId = modelId_;\n        if(modelId_ === null) {\n            modelId = \"fs\";\n        } else if(typeof modelId_ === \"undefined\") {\n            modelId = \"fs\";\n        }\n        const sdb_fs = Castelog.variables.SimplestDB.getFS();\n        // @TODO...\n    } else if (fsSystem === \"node.fs\") {\n        // @TODO...\n    } else {\n        throw new Error(\"Modalidad de sistema de ficheros «\" + fsSystem + \"» no identificada. Solo disponibles: 'simplestdb.fs' y 'node.fs'. [0003]\");\n    }\n};\n\n//Included:lib/508.01.castelog.v1.metodos.una_conexion_de_base_de_datos.js\nCastelog.metodos.una_conexion_de_base_de_datos = async function (configuraciones, tipo = \"simplestdb\", en_errores = undefined, ontologia = \"\") {\n    try {\n        const metodo_final = \"una_conexion_de_base_de_datos_tipo_\" + tipo + (ontologia ? (\"_\" + ontologia) : \"\");\n        if (!(metodo_final in Castelog.metodos)) {\n            throw new Error(\"Tipo de conexión no identificado\");\n        }\n        return await Castelog.metodos[metodo_final](configuraciones);\n    } catch(error) {\n        if(en_errores) {\n            return en_errores(error);\n        }\n        throw error;\n    }\n};\n\nCastelog.metodos.una_conexion_de_base_de_datos_tipo_rest = function(configuraciones) {\n    return Castelog.variables.Automatic_http_rest_api_interface(configuraciones);\n}\n\nCastelog.metodos.una_conexion_de_base_de_datos_tipo_simplestdb = function(configuraciones) {\n    return new SimplestDB(configuraciones.schema || {}, configuraciones.validateSchema || false);\n};\n\nCastelog.metodos.una_conexion_de_base_de_datos_tipo_ranasdb = function (configuraciones) {\n    return RanasDB.connect(configuraciones.id, configuraciones.versionado);\n};\n\nCastelog.metodos.una_conexion_de_base_de_datos_tipo_mysql2 = function (configuraciones) {\n    if(!configuraciones.database) {\n        configuraciones.database = undefined;\n    }\n    if(!configuraciones.host) {\n        configuraciones.host = \"127.0.0.1\";\n    }\n    if(!configuraciones.port) {\n        configuraciones.port = 3306;\n    }\n    if(!configuraciones.user) {\n        configuraciones.user = \"root\";\n    }\n    if(!configuraciones.password) {\n        configuraciones.password = \"\";\n    }\n    return new Promise(async (ok, fail) => {\n        try {\n            const mysql = require(\"mysql2/promise\");\n            const connection = await mysql.createConnection(configuraciones);\n            const connectionProxy = new Castelog.variables.un_proxy_de_conexion_para_mysql2(connection);\n            return ok(connectionProxy);\n        } catch(error) {\n            return fail(error);\n        }\n    });\n};\n\nCastelog.metodos.una_conexion_de_base_de_datos_tipo_mysql2_pool = function (configuraciones) {\n    if(!configuraciones.database) {\n        configuraciones.database = undefined;\n    }\n    if(!configuraciones.host) {\n        configuraciones.host = \"127.0.0.1\";\n    }\n    if(!configuraciones.port) {\n        configuraciones.port = 3306;\n    }\n    if(!configuraciones.user) {\n        configuraciones.user = \"root\";\n    }\n    if(!configuraciones.password) {\n        configuraciones.password = \"\";\n    }\n    return new Promise(async (ok, fail) => {\n        try {\n            const mysql = require(\"mysql2/promise\");\n            const pool = await mysql.createPool(configuraciones);\n            const poolProxy = new Castelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2(pool);\n            return ok(poolProxy);\n        } catch (error) {\n            return fail(error);\n        }\n    });\n};\n\n//Included:lib/508.02.castelog.v1.metodos.una_seleccion_de_base_de_datos.js\nCastelog.metodos.una_seleccion_de_base_de_datos = function (modelo, filtrando, ordenando, agrupando, paginando, bd = \"system\", adaptador = Castelog.variables.SimplestDB, objetivo = \"a varios ítems\") {\n    if(typeof adaptador === \"undefined\") {\n        throw new Error(\"Required argument «adaptador» to not be undefined in order to «Castelog.metodos.una_seleccion_de_base_de_datos»\");\n    }\n    const db = adaptador.create({ schema: bd }, true);\n    const [mysqlClass1, mysqlClass2] = [\n        Castelog.variables.un_proxy_de_conexion_para_mysql2,\n        Castelog.variables.un_proxy_de_pool_de_conexiones_para_mysql2\n    ];\n    if ((db instanceof mysqlClass1) || (db instanceof mysqlClass2)) {\n        if (objetivo === \"a un ítem\") {\n            return db.select_one(modelo, filtrando, ordenando, agrupando, paginando, bd);\n        } else if (objetivo === \"a varios ítems\") {\n            return db.select_many(modelo, filtrando, ordenando, agrupando, paginando, bd);\n        } else if (objetivo === \"al primer ítem\") {\n            return db.select_first(modelo, filtrando, ordenando, agrupando, paginando, bd);\n        } else if (objetivo === \"al último ítem\") {\n            return db.select_last(modelo, filtrando, ordenando, agrupando, paginando, bd);\n        }\n    } else if (db.instanceType === \"standard\") {\n        return db.select(modelo, filtrando, ordenando, agrupando, paginando, bd, adaptador, objetivo);\n    } else {\n        if(objetivo === \"a varios ítems\") {\n            const resultOriginal = db.select(modelo, filtrando ? filtrando : i => i);\n            let result = Object.keys(resultOriginal).reduce((output, key) => {\n                output.push([key, resultOriginal[key]]);\n                return output;\n            }, []);\n            if(agrupando) {\n                // result = result.sort(ordenando);\n            }\n            if(ordenando) {\n                if(typeof ordenando === \"function\") {\n                    result = result.sort(ordenando);\n                } else if(Array.isArray(ordenando)) {\n                    result = result.sort(function(a, b) {\n                        for(let index = 0; index < ordenando.length; index++) {\n                            const ordenacion = ordenando[index];\n                            const aHas = ordenacion in a;\n                            const bHas = ordenacion in b;\n                            if(aHas && bHas) {\n                                if(a[ordenacion] < b[ordenacion]) {\n                                    return -1;\n                                } else if(a[ordenacion] > b[ordenacion]) {\n                                    return 1;\n                                }\n                            } else if (aHas) {\n                                return -1;\n                            } else if(bHas) {\n                                return 1;\n                            }\n                        }\n                        return -1;\n                    });\n                } else {\n                    throw new Error(\"Parámetro «ordenando» debe ser una función o un array. [0001]\");\n                }\n            }\n            if(paginando) {\n                if(typeof paginando !== \"object\") {\n                    throw new Error(\"Parámetro «paginando» debe ser un objeto. [0001]\");\n                }\n                const { pagina, items } = paginando;\n                const itemsNumber = parseInt(items) || 20;\n                const paginaNumber = parseInt(pagina) || 0;\n                let indexPagina = 0;\n                let indexItem = 0;\n                let result2 = [];\n                for(let indexRow = 0; indexRow < result.length; indexRow++) {\n                    const row = result[indexRow];\n                    indexItem++;\n                    if(indexItem >= itemsNumber) {\n                        indexPagina++;\n                        indexItem = 0;\n                    }\n                    if(indexPagina === paginaNumber) {\n                        result2.push(row);\n                    }\n                }\n                result = result2;\n            }\n            if(Array.isArray(result)) {\n                result = result.reduce((output, item) => {\n                    const [ key, value ] = item;\n                    output[key] = value;\n                    return output;\n                }, {});\n            }\n            return result;\n        }\n    }\n};\n\n//Included:lib/508.03.castelog.v1.metodos.una_insercion_de_base_de_datos.js\nCastelog.metodos.una_insercion_de_base_de_datos = function (modelo, datos, bd = \"system\", adaptador = Castelog.variables.SimplestDB) {\n    if (typeof adaptador === \"undefined\") {\n        throw new Error(\"Required argument «adaptador» to not be undefined in order to «Castelog.metodos.una_insercion_de_base_de_datos»\");\n    }\n    const db = adaptador.create({ schema: bd }, true);\n    return db.insert(modelo, datos);\n};\n\n//Included:lib/508.04.castelog.v1.metodos.una_actualizacion_de_base_de_datos.js\nCastelog.metodos.una_actualizacion_de_base_de_datos = function (modelo, id, datos, bd = \"system\", adaptador = Castelog.variables.SimplestDB) {\n    if (typeof adaptador === \"undefined\") {\n        throw new Error(\"Required argument «adaptador» to not be undefined in order to «Castelog.metodos.una_actualizacion_de_base_de_datos»\");\n    }\n    const db = adaptador.create({ schema: bd }, true);\n    return db.update(modelo, id, datos);\n};\n\n//Included:lib/508.05.castelog.v1.metodos.una_eliminacion_de_base_de_datos.js\nCastelog.metodos.una_eliminacion_de_base_de_datos = function (modelo, id, bd = \"system\", adaptador = Castelog.variables.SimplestDB) {\n    if (typeof adaptador === \"undefined\") {\n        throw new Error(\"Required argument «adaptador» to not be undefined in order to «Castelog.metodos.una_eliminacion_de_base_de_datos»\");\n    }\n    const db = adaptador.create({ schema: bd }, true);\n    return db.delete(modelo, id);\n};\n\n//Included:lib/510.castelog.v1.metodos.una_notificacion.js\nCastelog.metodos.una_notificacion = function(mensaje) {\n    if (typeof window !== \"undefined\") {\n        return new Promise((ok, fail) => {\n            try {\n                const dialogDiv = document.createElement(\"div\");\n                dialogDiv.innerHTML = `<div style=\"display: block; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: white; z-index: 9999;\">\n                    <table style=\"width: 100%; height: 100%;\">\n                        <tr style=\"height: 5%;\">\n                            <td style=\"vertical-align: bottom;\">\n                                <div style=\"display: inline-block; width: auto; font-family: monospace; font-size: 10px;\" class=\"dialog_label\"></div>\n                            </td>\n                        </tr>\n                        <tr style=\"height: 50%;\">\n                            <td style=\"vertical-align: top; border-top: 1px solid #333;\">\n                                <button style=\"float: left; font-family: monospace; font-size: 10px;\" class=\"dialog_submiter\">Aceptar</button>\n                            </td>\n                        </tr>\n                    </table>\n                </div>`;\n                const dialogLabel = dialogDiv.querySelector(\".dialog_label\");\n                const dialogSubmiter = dialogDiv.querySelector(\".dialog_submiter\");\n                dialogLabel.textContent = mensaje;\n                dialogSubmiter.addEventListener(\"click\", function (event) {\n                    dialogDiv.remove();\n                    return ok(true);\n                });\n                document.body.appendChild(dialogDiv);\n                dialogSubmiter.focus();\n            } catch (error) {\n                window.alert(mensaje);\n                return fail(error);\n            }\n        });\n    } else if (typeof global === \"object\") {\n        return new Promise((ok, fail) => {\n            try {\n                const reader = require(\"readline\").createInterface({\n                    input: process.stdin,\n                    output: process.stdout,\n                });\n                reader.question(mensaje + \"\\n«Presiona enter:» \", answer => {\n                    reader.close();\n                    return ok(true);\n                });\n            } catch(error) {\n                console.log(mensaje);\n                return fail(error);\n            }\n        });\n    }\n};\n\n//Included:lib/511.castelog.v1.metodos.una_pregunta.js\nCastelog.metodos.una_pregunta = function(mensaje, defecto = \"\", es_silenciosa = false) {\n    if(typeof window === \"object\") {\n        return new Promise((ok, fail) => {\n            try {\n                const dialogDiv = document.createElement(\"div\");\n                dialogDiv.innerHTML = `<div style=\"display: block; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: white; z-index: 9999; font-family: monospace; font-size: 10px;\">\n                    <table style=\"width: 100%; height: 100%;\">\n                        <tr style=\"height: 5%;\">\n                            <td style=\"vertical-align: bottom;\">\n                                <div style=\"display: inline-block; width: auto; font-family: monospace; font-size: 10px;\" class=\"dialog_label\"></div>\n                                <button style=\"float: right; font-family: monospace; font-size: 10px;\" class=\"dialog_closer\">Salir</div>\n                            </td>\n                        </tr>\n                        <tr style=\"height: 50%;\">\n                            <td style=\"vertical-align: top; border-top: 1px solid #333;\">\n                                <textarea style=\"width: 100%; min-height: 100px; resize: vertical; box-sizing: border-box; font-family: monospace; font-size: 10px;\" class=\"dialog_textarea\"></textarea>\n                                <button style=\"float: left; font-family: monospace; font-size: 10px;\" class=\"dialog_submiter\">Aceptar</button><span>ó CTRL + ENTER pero desde el texto</span>\n                            </td>\n                        </tr>\n                    </table>\n                </div>`;\n                const dialogLabel = dialogDiv.querySelector(\".dialog_label\");\n                const dialogCloser = dialogDiv.querySelector(\".dialog_closer\");\n                const dialogTextarea = dialogDiv.querySelector(\".dialog_textarea\");\n                const dialogSubmiter = dialogDiv.querySelector(\".dialog_submiter\");\n                dialogLabel.textContent = mensaje;\n                dialogCloser.addEventListener(\"click\", function(event) {\n                    dialogDiv.remove();\n                    return ok(false);\n                });\n                dialogSubmiter.addEventListener(\"click\", function(event) {\n                    const val = dialogTextarea.value;\n                    dialogDiv.remove();\n                    return ok(val);\n                });\n                dialogTextarea.value = defecto;\n                dialogTextarea.addEventListener(\"keypress\", function(event) {\n                    if((event.code === \"Enter\") && (event.ctrlKey)) {\n                        const val = dialogTextarea.value;\n                        dialogDiv.remove();\n                        return ok(val);\n                    }\n                });\n                document.body.appendChild(dialogDiv);\n                dialogTextarea.focus();\n            } catch(error) {\n                return fail(error);\n            }\n        });\n    } else if(typeof global === \"object\") {\n        return new Promise(ok => {\n            const reader = require(\"readline\").createInterface({\n                input: process.stdin,\n                output: process.stdout,\n            });\n            if(es_silenciosa) {\n                reader.question(mensaje, answer => {\n                    reader.close();\n                    if(!answer) {\n                        return ok(defecto);\n                    }\n                    return ok(answer);\n                })\n            } else {\n                reader.question(mensaje + \"\\n«Respuesta:» \", answer => {\n                    reader.close();\n                    if(!answer) {\n                        return ok(defecto);\n                    }\n                    return ok(answer);\n                });\n            }\n        });\n    }\n};\n\n//Included:lib/512.castelog.v1.metodos.una_confirmacion.js\nCastelog.metodos.una_confirmacion = function(mensaje, defecto = false) {\n    if(typeof window === \"object\") {\n        return window.confirm(mensaje, defecto);\n    } else if(typeof global === \"object\") {\n        const readline = require(\"readline\");\n        const reader = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout,\n        });\n        return new Promise(ok => {\n            const ask = () => {\n                reader.question(mensaje + ( defecto ? \" (S/n = por defecto «sí»)\" : \" (s/N = por defecto «no»)\" ), answer => {\n                    reader.close();\n                    if(!answer) {\n                        return ok(defecto);\n                    }\n                    return ok(answer);\n                });\n            };\n            ask();\n        });\n    }\n};\n\n//Included:lib/514.castelog.v1.metodos.estoy_en.js\nCastelog.metodos.estoy_en = function(expresion, arg1) {\n    // Esta función está por completarse/parchearse.\n    // Actualmente solo determina correctamente si:\n    //   - estoy en navegador: tiene en cuenta window.\n    //   - estoy en sistema: tiene en cuenta global y require.\n    //   - estoy en windows: funciona bien en node.js solamente (en sistema).\n    //   - estoy en linux: funciona bien solo si consideras linux a todo lo que no sea windows.\n    if(expresion === \"estoy en navegador\") {\n        return (typeof window !== \"undefined\") && (typeof document !== \"undefined\");\n    } else if(expresion === \"estoy en sistema\") {\n        return (typeof global !== \"undefined\") && (typeof require !== \"undefined\");\n    } else if(expresion === \"estoy en windows\") {\n        return (typeof global !== \"undefined\") && (typeof require !== \"undefined\") && (require(\"os\").platform().indexOf(\"win\") === 0);\n    } else if(expresion === \"estoy en linux\") {\n        return (typeof global !== \"undefined\") && (typeof require !== \"undefined\") && (require(\"os\").platform().indexOf(\"win\") !== 0);\n    } else if(expresion === \"estoy en entorno\") {\n        return Castelog.variables.globales.entorno === arg1;\n    } else {\n        throw new Error(\"Expresión de detección de entorno no identificada o no disponible: \"+ expresion);\n    }\n    if(expresion === \"estoy en mac\") {\n        return undefined;\n    } else if(expresion === \"estoy en chrome\") {\n        return undefined;\n    } else if(expresion === \"estoy en firefox\") {\n        return undefined;\n    } else if(expresion === \"estoy en opera\") {\n        return undefined;\n    } else if(expresion === \"estoy en safari\") {\n        return undefined;\n    } else if(expresion === \"estoy en ios\") {\n        return undefined;\n    } else if(expresion === \"estoy en android\") {\n        return undefined;\n    } else if(expresion === \"estoy en móvil\") {\n        return undefined;\n    } else if(expresion === \"estoy en tablet\") {\n        return undefined;\n    } else if(expresion === \"estoy en ordenador\") {\n        return undefined;\n    }\n    return true;\n};\n\n//Included:lib/515.castelog.v1.metodos.un_elemento_html.js\nCastelog.metodos.un_elemento_html = function(codigo) {\n    if(typeof window === \"object\") {\n        const parent = document.createElement(\"div\");\n        parent.innerHTML = codigo;\n        return parent.children[0];\n    } else if(typeof global === \"object\") {\n        throw new Error(\"El entorno no soporta la carga de elementos HTML nativa. Suele funcionar en navegadores.\");\n    }\n};\n\n//Included:lib/516.castelog.v1.metodos.una_compilacion_estandar_de_parametros_de_consola.js\nCastelog.metodos.una_compilacion_estandar_de_parametros_de_consola = function(parametros) {\n    if(!Array.isArray(parametros)) {\n        throw new Error(\"Se requiere que «parametros» sea un array\");\n    }\n    const compilados = {};\n    let propiedadSeleccionada = \"_\";\n    for(let index = 0; index < parametros.length; index++) {\n        const parametro = parametros[index];\n        if (parametro.match(/^\\-\\-/g)) {\n            propiedadSeleccionada = parametro.replace(/^\\-\\-/g, \"\");\n        } else if(parametro.match(/^\\-/g)) {\n            propiedadSeleccionada = parametro.replace(/^\\-/g, \"\");\n        } else {\n            if (!Array.isArray(compilados[propiedadSeleccionada])) {\n                compilados[propiedadSeleccionada] = [];\n            }\n            compilados[propiedadSeleccionada].push(parametro);\n        }\n    }\n    return compilados;\n};\n\n//Included:lib/517.castelog.v1.metodos.un_servidor_http.js\nCastelog.metodos.un_servidor_http = function(controlador, opciones) {\n    if(typeof window === \"object\") {\n        return;\n    } else if(typeof global === \"object\") {\n        return require(\"http\").createServer(controlador, opciones);\n    }\n};\n\n//Included:lib/518.castelog.v1.metodos.un_servidor_https.js\nCastelog.metodos.un_servidor_https = function(controlador, opciones_seguras, opciones) {\n    if(typeof window === \"object\") {\n        return;\n    } else if(typeof global === \"object\") {\n        return require(\"https\").createServer(controlador, opciones_seguras, opciones);\n    }\n};\n\n//Included:lib/519.castelog.v1.metodos.un_servidor_socket_io.js\nCastelog.metodos.un_servidor_socket_io = function (servidor, eventos, eventos_socket, opciones_de_socket_servidor, opciones_seguras) {\n    try {\n        if (typeof window === \"object\") {\n            return;\n        } else if (typeof global === \"object\") {\n            let socket_io = undefined;\n            try {\n                socket_io = require(\"socket.io\");\n            } catch (error) {\n                console.log(error);\n                throw new Error(\"Error intentando arrancar un servidor con «socket.io» probablemente porque no se encontró la dependencia en node/npm desde \" + process.cwd());\n            }\n            if (typeof servidor === 'undefined') {\n                if (opciones_seguras) {\n                    throw new Error(\"Opciones seguras de socket.io no están implementadas todavía\");\n                } else if (servidor) {\n                    // @OK!\n                } else {\n                    servidor = require(\"http\").createServer(function (request, response) {\n                        response.writeHead(200, { \"Content-type\": \"text/plain\" });\n                        response.write(\"This is a chat server only\");\n                        return response.end();\n                    });\n                }\n            }\n            const socket_connection = new socket_io.Server(servidor, opciones_de_socket_servidor);\n            for (let indexEvento = 0; indexEvento < eventos.length; indexEvento++) {\n                const evento = eventos[indexEvento];\n                if (Array.isArray(evento) && (evento.length === 2) && (typeof evento[0] === \"string\") && (typeof evento[1] === \"function\")) {\n                    const [evento_id, evento_funcion] = evento;\n                    socket_connection.on(evento_id, (...args) => evento_funcion(args, {\n                        socket_io,\n                        io: socket_io,\n                        socket: socket_connection,\n                        evento: evento\n                    }));\n                } else if ((typeof evento === \"object\") && (evento.tipo === \"espacio de nombres\")) {\n                    const nombre_de_espacios = evento.nombre;\n                    if (typeof evento.nombre !== \"string\") {\n                        throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» on property «nombre» to be a string in order to «Castelog.metodos.un_servidor_socket_io»\");\n                    }\n                    if (!Array.isArray(evento.eventos)) {\n                        throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» on property «eventos» to be an array in order to «Castelog.metodos.un_servidor_socket_io»\");\n                    }\n                    const socket_namespaced = socket_connection.of(nombre_de_espacios);\n                    for (let indexSubevento = 0; indexSubevento < evento.eventos.length; indexSubevento++) {\n                        const subevento = evento.eventos[indexSubevento];\n                        const [subevento_id, subevento_funcion] = subevento;\n                        if (Array.isArray(subevento) && (subevento.length === 2) && (typeof subevento[0] === \"string\") && (typeof subevento[1] === \"function\")) {\n                            socket_namespaced.on(subevento_id, (...args) => subevento_funcion(args, {\n                                socket_io,\n                                io: socket_connection,\n                                socket: socket_connection,\n                                evento: evento\n                            }));\n                        } else {\n                            throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» on property «eventos» on index «\" + indexSubevento + \"» to be an array like [string, function] in order to «Castelog.metodos.un_servidor_socket_io»\")\n                        }\n                    }\n                } else {\n                    throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» to be an array like [string, function] or to be an object with «tipo» set to «espacio de nombres» in order to «Castelog.metodos.un_servidor_socket_io» (message 2)\")\n                }\n            }\n            socket_connection.on(\"connect\", (socket_subconnection) => {\n                for (let indexEvento = 0; indexEvento < eventos_socket.length; indexEvento++) {\n                    const evento = eventos_socket[indexEvento];\n                    if (Array.isArray(evento) && (evento.length === 2) && (typeof evento[0] === \"string\") && (typeof evento[1] === \"function\")) {\n                        const [evento_id, evento_funcion] = evento;\n                        socket_subconnection.on(evento_id, (...args) => evento_funcion(args, {\n                            socket_io,\n                            io: socket_connection,\n                            socket: socket_subconnection,\n                            evento: evento\n                        }));\n                    } else if ((typeof evento === \"object\") && (evento.tipo === \"espacio de nombres\")) {\n                        const nombre_de_espacios = evento.nombre;\n                        if (typeof evento.nombre !== \"string\") {\n                            throw new Error(\"Required argument «eventos_socket» on index «\" + indexEvento + \"» on property «nombre» to be a string in order to «Castelog.metodos.un_servidor_socket_io»\");\n                        }\n                        if (!Array.isArray(evento.eventos)) {\n                            throw new Error(\"Required argument «eventos_socket» on index «\" + indexEvento + \"» on property «eventos» to be an array in order to «Castelog.metodos.un_servidor_socket_io»\");\n                        }\n                        const socket_namespaced = socket_subconnection.of(nombre_de_espacios);\n                        for (let indexSubevento = 0; indexSubevento < evento.eventos.length; indexSubevento++) {\n                            const subevento = evento.eventos[indexSubevento];\n                            const [subevento_id, subevento_funcion] = subevento;\n                            if (Array.isArray(subevento) && (subevento.length === 2) && (typeof subevento[0] === \"string\") && (typeof subevento[1] === \"function\")) {\n                                socket_namespaced.on(subevento_id, (...args) => subevento_funcion(args, {\n                                    socket_io,\n                                    io: socket_connection,\n                                    socket: socket_subconnection,\n                                    evento: evento\n                                }));\n                            } else {\n                                throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» on property «eventos» on index «\" + indexSubevento + \"» to be an array like [string, function] in order to «Castelog.metodos.un_servidor_socket_io»\")\n                            }\n                        }\n                    } else {\n                        throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» to be an array like [string, function] or to be an object with «tipo» set to «espacio de nombres» in order to «Castelog.metodos.un_servidor_socket_io» (message 2)\")\n                    }\n                }\n            });\n            return socket_connection;\n        }\n    } catch (error) {\n        console.log(\"Error al intenter «un_servidor_socket_io»\", error);\n        throw error;\n    }\n};\n\n//Included:lib/520.castelog.v1.metodos.un_cliente_socket_io.js\nCastelog.metodos.un_cliente_socket_io = function (eventos, opciones) {\n    try {\n        let socket_io_client = undefined;\n        let cliente = undefined;\n        let common_io = undefined;\n        if (typeof io === \"function\") {\n            socket_io_client = io;\n            common_io = io.io;\n        } else if (typeof require === \"function\") {\n            socket_io_client = require(\"socket.io-client\");\n            common_io = socket_io_client.io;\n        } else {\n            throw new Error(\"Required dependency «socket.io-client» reachable by global or by module in order to «Castelog.metodos.un_cliente_socket»\");\n        }\n        if (typeof common_io !== \"function\") {\n            throw new Error(\"Required dependency «common_io» to be a function in order to «Castelog.metodos.un_cliente_socket»\");\n        }\n        const client_socket = common_io(opciones);\n        if (!Array.isArray(eventos)) {\n            throw new Error(\"Required parameter «eventos» to be an array in order to «Castelog.metodos.un_cliente_socket_io»\");\n        }\n        for (let indexEvento = 0; indexEvento < eventos.length; indexEvento++) {\n            const evento = eventos[indexEvento];\n            if (Array.isArray(evento) && (evento.length === 2) && (typeof evento[0] === \"string\") && (typeof evento[1] === \"function\")) {\n                const [evento_id, evento_funcion] = evento;\n                const evento_funcion_final = (() => {\n                    return (...args) => {\n                        return evento_funcion(args, {\n                            socket_io_client,\n                            io: socket_io_client.io,\n                            client: client_socket,\n                            socket: client_socket,\n                            evento: evento\n                        });\n                    }\n                })();\n                client_socket.on(evento_id, evento_funcion_final);\n            } else {\n                throw new Error(\"Required argument «eventos» on index «\" + indexEvento + \"» to be an array like [string, function] in order to «Castelog.metodos.un_cliente_socket_io»\")\n            }\n        }\n        return client_socket;\n    } catch (error) {\n        console.log(\"Error al intenter «un_cliente_socket_io»\", error);\n        throw error;\n    }\n};\n\n//Included:lib/523.castelog.v1.metodos.una_red_de_servidores_http_rest_automaticos.js\nCastelog.metodos.una_red_de_servidores_http_rest_automaticos = function (rutaDeProyectoPrototipo, deployerCallback) {\n    if (typeof global === \"object\") {\n        return new Promise((ok, fail) => {\n            try {\n                const path = require(\"path\");\n                const rutaInicial = path.resolve(rutaDeProyectoPrototipo);\n                Castelog.variables.generador_de_proyector_rest(rutaInicial);\n                const rutaGeneratorBuilder = path.resolve(rutaInicial, \"./bin/build-generator.js\");\n                require(rutaGeneratorBuilder);\n                const rutaApi = path.resolve(rutaInicial, \"./api.js\");\n                const restApi = require(rutaApi);\n                const { una_red_de_servidores_http_rest_automaticos } = restApi;\n                return una_red_de_servidores_http_rest_automaticos(deployerCallback).then(() => {\n                    console.log(\"La red de servidores http rest automáticos fue desplegada exitosamente,\");\n                    ok();\n                }).catch(error => {\n                    console.log(\"Hubo errores al intentar generar una red de servidores http rest automáticos:\", error);\n                    fail(error);\n                });\n            } catch (error) {\n                return fail(error);\n            }\n        });\n    } else {\n        console.log(\"Sintaxis de red de servidores HTTP REST automáticos no soportada en navegadores\");\n    }\n};\n\n//Included:lib/524.castelog.v1.metodos.una_superquery.js\nCastelog.metodos.una_superquery = function(esquema, cliente, base) {\n    if(typeof esquema !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «esquema» ser un objeto para «Castelog.metodos.una_superquery»\");\n    }\n    if(typeof cliente !== \"function\") {\n        throw new Error(\"Se requiere de parámetro «cliente» ser una función para «Castelog.metodos.una_superquery»\");\n    }\n    if(typeof base !== \"function\") {\n        throw new Error(\"Se requiere de parámetro «base» ser una función para «Castelog.metodos.una_superquery»\");\n    }\n    return base({ esquema, cliente });\n};\n\n//Included:lib/525.castelog.v1.metodos.una_query.js\nCastelog.metodos.una_query = function(superquery, tabla, cuyos, ordenada_por, paginada_por) {\n    if(typeof superquery !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «superquery» ser un objeto para «Castelog.metodos.una_query»\");\n    }\n    if(typeof superquery.esquema !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «superquery.esquema» ser un objeto para «Castelog.metodos.una_query»\");\n    }\n    if(typeof superquery.cliente !== \"function\") {\n        throw new Error(\"Se requiere de parámetro «superquery.cliente» ser una función para «Castelog.metodos.una_query»\");\n    }\n    if(typeof tabla !== \"string\") {\n        throw new Error(\"Se requiere de parámetro «tabla» ser un string para «Castelog.metodos.una_query»\");\n    }\n    if(typeof cuyos !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «cuyos» ser una objeto para «Castelog.metodos.una_query»\");\n    }\n    if(typeof ordenada_por !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «ordenada_por» ser una objeto para «Castelog.metodos.una_query»\");\n    }\n    if(typeof paginada_por !== \"object\") {\n        throw new Error(\"Se requiere de parámetro «paginada_por» ser una objeto para «Castelog.metodos.una_query»\");\n    }\n    const { esquema, cliente } = superquery;\n    return cliente.get(\"?\" + new URLSearchParams({\n        operation: \"select\",\n        table: tabla,\n        where: JSON.stringify(cuyos),\n        order: JSON.stringify(ordenada_por),\n        paginate: JSON.stringify(paginada_por)\n    }).toString()).then(response => {\n        return response.data.data.items;\n    });\n};\n\n//Included:lib/526.castelog.v1.metodos.un_proyecto_npm.js\nCastelog.metodos.un_proyecto_npm = async function(extensionDePackage, directorio, esAsincrono = false) {\n    try {\n        if(typeof extensionDePackage !== \"object\") {\n            throw new Error(\"Se requiere de parámetro «extensionDePackage» ser un object para «Castelog.metodos.un_proyecto_npm»\");\n        }\n        if(typeof directorio !== \"string\") {\n            throw new Error(\"Se requiere de parámetro «directorio» ser un string para «Castelog.metodos.un_proyecto_npm»\");\n        }\n        if(typeof global === \"undefined\" || typeof require !== \"function\") {\n            throw new Error(\"Se requiere de variable «global» no ser undefined y a variable «require» ser una función para  «Castelog.metodos.un_proyecto_npm»\");\n        }\n        const fs = require(\"fs\");\n        const path = require(\"path\");\n        // Sí o sí, síncrono:\n        Castelog.metodos.un_comando_de_consola(\"npm init -y\", { cwd: directorio ? directorio : process.cwd() }, false);\n        const packagePath = path.resolve(directorio, \"package.json\");\n        let packageContents = undefined;\n        if(esAsincrono) {\n            packageContents = await fs.promises.readFile(packagePath, \"utf8\")\n        } else {\n            packageContents = fs.readFileSync(packagePath, \"utf8\");\n        }\n        const packageData = JSON.parse(packageContents);\n        Object.assign(packageData, extensionDePackage);\n        if(esAsincrono) {\n            await fs.promises.writeFile(packagePath, JSON.stringify(packageData, null, 4), \"utf8\");\n        } else {\n            fs.writeFileSync(packagePath, JSON.stringify(packageData, null, 4), \"utf8\");\n        }\n        return extensionDePackage;\n    } catch (error) {\n        console.log(\"Error al desplegar proyecto npm:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/527.castelog.v1.metodos.un_comando_de_consola.js\nCastelog.metodos.un_comando_de_consola = function(comando, configuraciones, esParalelo = false) {\n    try {\n        if(esParalelo) {\n            if(!Array.isArray(comando)) {\n                throw new Error(\"Required parameter «comando» to be an array in order to «Castelog.metodos.un_comando_de_consola» in «en paralelo» mode\");\n            }\n            if (comando.length !== 2) {\n                throw new Error(\"Required parameter «comando» to be an array of 2 items in order to «Castelog.metodos.un_comando_de_consola» in «en paralelo» mode\");\n            }\n            if(typeof comando[0] !== \"string\") {\n                throw new Error(\"Required parameter «comando» on item 1 to be a string in order to «Castelog.metodos.un_comando_de_consola» in «en paralelo» mode\");\n            }\n            if(!Array.isArray(comando[1])) {\n                throw new Error(\"Required parameter «comando» on item 2 to be an array in order to «Castelog.metodos.un_comando_de_consola» in «en paralelo» mode\");\n            }\n        } else {\n            if (typeof comando !== \"string\") {\n                throw new Error(\"Required parameter «comando» to be a string in order to «Castelog.metodos.un_comando_de_consola» in «en serie» mode\");\n            } \n        }\n        if(typeof configuraciones !== \"object\") {\n            throw new Error(\"Required parameter «configuraciones» to be an object in order to «Castelog.metodos.un_comando_de_consola»\");\n        }\n        if(typeof require !== \"function\") {\n            throw new Error(\"Required global «require» to be a function in order to «Castelog.metodos.un_comando_de_consola»\");\n        }\n        if(typeof configuraciones.cwd !== \"string\") {\n            configuraciones.cwd = process.cwd();\n        }\n        if(typeof configuraciones.stdio === \"undefined\") {\n            if(!esParalelo) {\n                configuraciones.stdio = [\"inherit\", \"inherit\", \"inherit\"];\n            } else {\n                configuraciones.stdio = [\"ignore\", \"ignore\", \"ignore\"];\n            }\n        }\n        if(esParalelo) {\n            return new Promise((ok, fail) => {\n                return require(\"child_process\").spawn(comando[0], comando[1], configuraciones, (error, stdout, stderr) => {\n                    if(error) {\n                        return fail(error);\n                    }\n                    if(stderr) {\n                        return ok({ error: stderr });\n                    }\n                    if(stdout) {\n                        return ok(stdout);\n                    }\n                    return ok();\n                });\n                \n            });\n        } else {\n            return require(\"child_process\").execSync(comando, configuraciones);\n        }\n    } catch (error) {\n        console.log(\"Error al ejecutar comando de consola:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/529.castelog.v1.metodos.un_testeo.js\nCastelog.metodos.un_testeo = function (tiempo, nombre_de_testeo, nombres_de_tests, en_exito, en_error) {\n    try {\n        if(typeof tiempo !== \"number\") {\n            throw new Error(\"Required parameter «tiempo» to be a number in order to «Castelog.metodos.un_testeo»\");\n        }\n        if(!Array.isArray(nombres_de_tests)) {\n            throw new Error(\"Required parameter «nombres_de_tests» to be an array in order to «Castelog.metodos.un_testeo»\");\n        }\n        if(nombres_de_tests.length === 0) {\n            throw new Error(\"Required parameter «nombres_de_tests» to be an array with 1 or more items in order to «Castelog.metodos.un_testeo»\");\n        }\n        if (typeof en_exito === \"undefined\") {\n            // OK\n        } else if (typeof en_exito !== \"function\") {\n            throw new Error(\"Required parameter «en_exito» to be a function or undefined in order to «Castelog.metodos.un_testeo»\");\n        }\n        if(typeof en_error === \"undefined\") {\n            // OK\n        } else if(typeof en_error !== \"function\") {\n            throw new Error(\"Required parameter «en_error» to be a function or undefined in order to «Castelog.metodos.un_testeo»\");\n        }\n        const entorno_de_testeo = new Castelog.variables.Entorno_de_testeo({\n            tests_planificados: nombres_de_tests,\n            tests_completados: [],\n            tests_fallidos: [],\n            tiempo_maximo_de_testeo: tiempo,\n            estado_del_testeo: \"pendiente\", // \"completado\", \"fallido\"\n            en_error: en_error ? en_error : (error) => {\n                console.log(\"El testeo «\" + nombre_de_testeo + \"» falló con el siguiente error:\", error);\n            },\n            en_exito: en_exito ? en_exito : () => {\n                console.log(\"El testeo «\" + nombre_de_testeo + \"» se completó satisfactoriamente.\");\n            },\n        });\n        entorno_de_testeo.id_de_temporizador = setTimeout(() => {\n            // console.log(200);\n            const tests_no_completados = [];\n            for(let index = 0; index < entorno_de_testeo.tests_planificados.length; index++) {\n                // console.log(201);\n                const nombre_de_test = entorno_de_testeo.tests_planificados[index];\n                if(entorno_de_testeo.tests_completados.indexOf(nombre_de_test) === -1) {\n                    // console.log(202);\n                    tests_no_completados.push(nombre_de_test);\n                }\n            }\n            if(entorno_de_testeo.estado_del_testeo === \"pendiente\") {\n                // console.log(203);\n                entorno_de_testeo.estado_del_testeo = \"fallido\";\n                const mensaje_del_error = \"El testeo «\" + nombre_de_testeo + \"» no completó en el tiempo estipulado («\" + (tiempo/1000) + \" segundos») los siguientes (\" + tests_no_completados.length + \") tests: \" + tests_no_completados.map(t => `«${t}»`).join(\", \");\n                const error = new Error(mensaje_del_error);\n                if(typeof entorno_de_testeo.en_error === \"function\") {\n                    // console.log(204);\n                    entorno_de_testeo.en_error(error);\n                } else {\n                    // console.log(205);\n                    console.log(error);\n                    throw error;\n                }\n            }\n        }, tiempo);\n        return entorno_de_testeo;\n    } catch (error) {\n        throw error;\n    }\n};\n\n//Included:lib/530.castelog.v1.metodos.un_test.js\nCastelog.metodos.un_test = function(nombre_de_test, funcion_de_test, objeto_de_testeo, en_exito, en_error) {\n    try {\n        if(typeof nombre_de_test !== \"string\") {\n            throw new Error(\"Required parameter «nombre_de_test» to be a string in order to «Castelog.metodos.un_test»\");\n        }\n        if(typeof funcion_de_test !== \"function\") {\n            throw new Error(\"Required parameter «funcion_de_test» to be a function in order to «Castelog.metodos.un_test»\");\n        }\n        if(typeof en_exito === \"undefined\") {\n            // OK\n        } else if(typeof en_exito !== \"function\") {\n            throw new Error(\"Required parameter «en_exito» to be a function or undefined in order to «Castelog.metodos.un_test»\");\n        }\n        if(typeof en_error === \"undefined\") {\n            // OK\n        } else if(typeof en_error !== \"function\") {\n            throw new Error(\"Required parameter «en_error» to be a function or undefined in order to «Castelog.metodos.un_test»\");\n        }\n        if(typeof objeto_de_testeo === \"undefined\") {\n            // OK\n        } else if(!(objeto_de_testeo instanceof Castelog.variables.Entorno_de_testeo)) {\n            throw new Error(\"Required parameter «objeto_de_testeo» to be an object or undefined in order to «Castelog.metodos.un_test»\")\n        }\n        try {\n            // console.log(100);\n            const resultado_de_test = funcion_de_test(objeto_de_testeo, nombre_de_test);\n            if(!(resultado_de_test instanceof Promise)) {\n                throw new Error(\"Required parameter «funcion_de_test» to be a function that returns a Promise in order to «Castelog.metodos.un_test»\");\n            }\n            // console.log(101);\n            return resultado_de_test.then(resultado_final_de_test => {\n                // console.log(102);\n                let es_ultimo_test = true;\n                if(typeof objeto_de_testeo === \"object\") {\n                    // console.log(103);\n                    objeto_de_testeo.tests_completados.push(nombre_de_test);\n                    EsUltimoTest:\n                    for (let index = 0; index < objeto_de_testeo.tests_planificados.length; index++) {\n                        // console.log(104);\n                        const nombre_de_test_planificado = objeto_de_testeo.tests_planificados[index];\n                        if (objeto_de_testeo.tests_completados.indexOf(nombre_de_test_planificado) === -1) {\n                            // console.log(105);\n                            es_ultimo_test = false;\n                            break EsUltimoTest;\n                        }\n                    }\n                    if(es_ultimo_test) {\n                        // console.log(106);\n                        objeto_de_testeo.estado_del_testeo = \"completado\";\n                        clearTimeout(objeto_de_testeo.id_de_temporizador);\n                    }\n                }\n                if(typeof en_exito === \"function\") {\n                    // console.log(107);\n                    en_exito(resultado_final_de_test, objeto_de_testeo);\n                }\n                if((typeof objeto_de_testeo === \"object\") && (typeof objeto_de_testeo.en_exito === \"function\")) {\n                    // console.log(108);\n                    if (es_ultimo_test) {\n                        // console.log(109);\n                        if (typeof objeto_de_testeo.en_exito === \"function\") {\n                            // console.log(110);\n                            objeto_de_testeo.en_exito(objeto_de_testeo, nombre_de_test, resultado_final_de_test);\n                        }\n                    }\n                }\n                return resultado_final_de_test;\n            }).catch(error => {\n                // console.log(120);\n                if (typeof objeto_de_testeo === \"object\") {\n                    // console.log(121);\n                    clearTimeout(objeto_de_testeo.id_de_temporizador);\n                    objeto_de_testeo.estado_del_testeo = \"fallido\";\n                    objeto_de_testeo.tests_fallidos.push(nombre_de_test);\n                }\n                if(typeof en_error === \"function\") {\n                    // console.log(122);\n                    en_error(error, objeto_de_testeo);\n                } else {\n                    // console.log(123);\n                    console.log(\"Error en test «\" + nombre_de_test + \"»:\", error);\n                }\n                if(typeof objeto_de_testeo === \"object\") {\n                    // console.log(124);\n                    if (typeof objeto_de_testeo.en_error === \"function\") {\n                        // console.log(125);\n                        objeto_de_testeo.en_error(error, objeto_de_testeo, nombre_de_test);\n                    }\n                }\n            });\n        } catch(error) {\n            // console.log(150);\n            if (typeof objeto_de_testeo === \"object\") {\n                // console.log(151);\n                clearTimeout(objeto_de_testeo.id_de_temporizador);\n                objeto_de_testeo.estado_del_testeo = \"fallido\";\n                objeto_de_testeo.tests_fallidos.push(nombre_de_test);\n            }\n            if (typeof en_error === \"function\") {\n                // console.log(152);\n                en_error(error, objeto_de_testeo);\n            } else {\n                // console.log(153);\n                console.log(\"Error en test «\" + nombre_de_test + \"»:\", error);\n            }\n            if (typeof objeto_de_testeo === \"object\") {\n                // console.log(154);\n                if (typeof objeto_de_testeo.en_error === \"function\") {\n                    // console.log(155);\n                    objeto_de_testeo.en_error(error, nombre_de_test, objeto_de_testeo);\n                }\n            }\n        }\n    } catch (error) {\n        throw error;\n    }\n};\n\n//Included:lib/531.castelog.v1.metodos.una_descripcion_del_entorno.js\nCastelog.metodos.una_descripcion_del_entorno = function() {\n    try {\n        if(typeof require === \"function\") {\n            const os = require(\"os\");\n            return {\n                hostname: os.hostname(),\n                platform: os.platform(),\n                architecture: os.arch(),\n                type: os.type(),\n                release: os.release(),\n                endianness: os.endianness(),\n                totalmem: os.totalmem(),\n                tmpdir: os.tmpdir(),\n                homedir: os.homedir(),\n                userInfo: os.userInfo(),\n                cpus: os.cpus(),\n                networkInterfaces: os.networkInterfaces()\n            };\n        };\n    } catch (error) {\n        console.log(\"Error al hacer una descripción del entorno:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/532.castelog.v1.metodos.un_reseteo_de_directorio.js\nCastelog.metodos.un_reseteo_de_directorio = async function(directorio, esAsincrono = false) {\n    try {\n        if(typeof require === \"function\") {\n            const fs = require(\"fs\");\n            if(esAsincrono) {\n                await fs.promises.rmdir(directorio, { recursive: true });\n                await fs.promises.mkdir(directorio);\n            } else {\n                fs.rmdirSync(directorio, { recursive: true });\n                fs.mkdirSync(directorio);\n            }\n        };\n    } catch (error) {\n        console.log(\"Error al hacer un reseteo de directorio:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/533.castelog.v1.metodos.un_servicio_de_ficheros_estaticos.js\nCastelog.metodos.un_servicio_de_ficheros_estaticos = async function(parametros, errores = false, enFicherosNoEncontrados = false, enOtrosCasos = false) {\n    try {\n        if(typeof require !== \"function\") {\n            throw new Error(\"Required global «require» to be a function in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n        }\n        const fs = require(\"fs\");\n        const parse_url = (arg) => require(\"url\").parse(arg);\n        const path = require(\"path\");\n        const { directorio, request, response, url: directorio_url_original = \"/\" } = parametros;\n        const directorio_url = directorio_url_original.replace(/\\/$/g, \"\") + \"/\";\n        if(typeof directorio !== \"string\") {\n            throw new Error(\"Required parameter «directorio» to be a string in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n        }\n        if (typeof directorio_url !== \"string\") {\n            throw new Error(\"Required parameter «directorio» to be a string in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n        }\n        if(typeof request === \"undefined\") {\n            throw new Error(\"Required parameter «request» to not be undefined in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n        }\n        if(typeof response === \"undefined\") {\n            throw new Error(\"Required parameter «response» to not be undefined in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n        }\n        const requested_url = parse_url(request.url).pathname;\n        if(requested_url.startsWith(directorio_url)) {\n            const remaining_url = requested_url.replace(directorio_url, \"\").replace(/^\\//g, \"\");\n            const fichero_path = path.resolve(directorio, remaining_url);\n            if(!fichero_path.startsWith(directorio)) {\n                throw new Error(\"Required parameter «request.url» to result in a subfile of «directorio» in order to «Castelog.metodos.un_servicio_de_ficheros_estaticos»\");\n            }\n            const reader = fs.createReadStream(fichero_path);\n            reader.pipe(response);\n            reader.on(\"error\", function(error) {\n                if (typeof enFicherosNoEncontrados === \"function\") {\n                    return enFicherosNoEncontrados(error, parametros);\n                }\n            });\n        } else {\n            if (typeof enOtrosCasos === \"function\") {\n                return enOtrosCasos();\n            }\n        }\n    } catch(error) {\n        if(typeof errores === \"function\") {\n            return errores(error, parametros);\n        }\n    }\n};\n\n//Included:lib/534.castelog.v1.metodos.un_texto_aleatorio.js\nCastelog.metodos.un_texto_aleatorio = function(caracteres, alfabeto = Castelog.variables.alfabeto_ingles) {\n    if(typeof caracteres !== \"number\") {\n        throw new Error(\"Required argument «caracteres» to be a number in order to «Castelog.metodos.un_texto_aleatorio»\");\n    }\n    if(caracteres <= 0) {\n        throw new Error(\"Required argument «caracteres» to be a more than 0 in order to «Castelog.metodos.un_texto_aleatorio»\");\n    }\n    if(!Array.isArray(alfabeto)) {\n        throw new Error(\"Required argument «alfabeto» to be an array in order to «Castelog.metodos.un_texto_aleatorio»\");\n    }\n    let output = \"\";\n    for(let index = 0; index < caracteres; index++) {\n        output += alfabeto[Math.floor(Math.random() * alfabeto.length)];\n    }\n    return output;\n};\n\n//Included:lib/534.castelog.v1.metodos.un_valor_aleatorio.js\nCastelog.metodos.un_valor_aleatorio = function(lista) {\n    if(!Array.isArray(lista)) {\n        throw new Error(\"Required argument «lista» to be an array in order to «Castelog.metodos.un_valor_aleatorio«\");\n    }\n    return lista[Math.floor(Math.random() * lista.length)];\n};\n\n//Included:lib/535.castelog.v1.metodos.un_servidor_activo_de_control_remoto.js\nCastelog.metodos.un_servidor_activo_de_control_remoto = async function(configuraciones, directorio) {\n    try {\n        return new Castelog.variables.ServidorActivoDeControlRemoto(configuraciones, directorio);\n    } catch(error) {\n        console.log(\"Error al «Castelog.metodos.una_centralita_de_control_remoto()»:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/536.castelog.v1.metodos.un_servidor_pasivo_de_control_remoto.js\nCastelog.metodos.un_servidor_pasivo_de_control_remoto = async function(configuraciones, directorio) {\n    try {\n        return new Castelog.variables.ServidorPasivoDeControlRemoto(configuraciones, directorio);\n    } catch(error) {\n        console.log(\"Error al «Castelog.metodos.una_centralita_de_control_remoto()»:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/537.castelog.v1.metodos.un_cliente_activo_de_control_remoto.js\nCastelog.metodos.un_cliente_activo_de_control_remoto = async function (configuraciones, directorio) {\n    try {\n        return new Castelog.variables.ClienteActivoDeControlRemoto(configuraciones, directorio);\n    } catch (error) {\n        console.log(\"Error al «Castelog.metodos.un_cliente_activo_de_control_remoto()»:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/538.castelog.v1.metodos.un_cliente_pasivo_de_control_remoto.js\nCastelog.metodos.un_cliente_pasivo_de_control_remoto = async function (configuraciones, directorio) {\n    try {\n        return new Castelog.variables.ClientePasivoDeControlRemoto(configuraciones, directorio);\n    } catch (error) {\n        console.log(\"Error al «Castelog.metodos.un_cliente_pasivo_de_control_remoto()»:\", error);\n        throw error;\n    }\n};\n\n//Included:lib/539.castelog.v1.metodos.un_fichero_xml.js\nCastelog.metodos.un_fichero_xml = async fichero => {\n    try {\n        const fs = require(\"fs\");\n        const xml2js = require(\"xml2js\");\n        const parser = new xml2js.Parser();\n        const data = await fs.promises.readFile(fichero, \"utf8\");\n        const result = await new Promise((ok, fail) => {\n            parser.parseString(data, function (error, result) {\n                if (error) {\n                    return fail(error);\n                }\n                return ok(result);\n            });\n        });\n        return result;\n    } catch (error) {\n        console.log(\"Error al intentar «Castelog.metodos.un_fichero_xml»:\", error);\n        console.log(\"Nota específica de error (1): recuerda que para usar «Castelog.metodos.un_fichero_xml» necesitas la dependencia «xml2js» en tu «node_modules»\");\n        throw error;\n    }\n};\n\n//Included:lib/540.castelog.v1.metodos.un_escaneo_de_puertos.js\nCastelog.metodos.un_escaneo_de_puertos = async (agente = \"nmap\", opciones = {}) => {\n    try {\n        if(agente === \"nmap\") {\n            const {\n                parametros = undefined,\n                salida = \"result.xml\",\n                directorio = process.cwd()\n            } = opciones;\n            const opciones_de_comando_por_defecto = parametros ? parametros : [\n                \"-p1-65535\",\n                \"--packet-trace\",\n                \"-r\",\n                \"-vv\",\n                \"-dd\",\n                \"--reason\",\n                \"--osscan-guess\",\n                \"--script-trace\",\n                \"-sV\",\n                \"-oX\",\n                \"result.xml\",\n                \"127.0.0.1\",\n            ];\n            const opciones_de_comando = typeof opciones === \"string\" ? opciones : opciones_de_comando_por_defecto.concat(opciones);\n            await new Promise((ok, fail) => {\n                const spawn = require(\"child_process\").spawn(\"nmap\", opciones_de_comando, { cwd: directorio, stdio: [\"inherit\", \"inherit\", \"inherit\"] });\n                spawn.on(\"error\", function(error) {\n                    if(error) {\n                        return fail(error);\n                    }\n                });\n                spawn.on(\"exit\", function (code) {\n                    return ok(code);\n                });\n                spawn.on(\"data\", function (chunk) {});\n            });\n            const ruta_resultados = require(\"path\").resolve(__dirname, salida);\n            return await Castelog.metodos.un_fichero_xml(ruta_resultados);\n        } else {\n            throw new Error(\"Required argument «agente» to be a valid port scanner agent like 'nmap' in order to «Castelog.metodos.un_escaneo_de_puertos»\");\n        }\n    } catch (error) {\n        console.log(\"Error al intentar «Castelog.metodos.un_escaneo_de_puertos»:\", error);\n        console.log(\"(*) Nota específica de error (1): recuerda que para «Castelog.metodos.un_escaneo_de_puertos(...)» necesitas la dependencia «nmap» en tu sistema operativo\");\n        console.log(\"(*) Nota específica de error (2): recuerda que para «Castelog.metodos.un_escaneo_de_puertos(...)» necesitas la dependencia «xml2js» en tu «node_modules»\");\n        throw error;\n    }\n};\n\n//Included:lib/541.castelog.v1.metodos.un_monitoreo_de_red.js\nCastelog.metodos.un_monitoreo_de_red = async (agente = \"nmap\", opciones, parametros_iniciales = undefined, fichero_resultados = \"result.xml\", directorio = process.cwd()) => {\n    try {\n        if(agente === \"pcap\") {\n            \n        } else {\n            throw new Error(\"Required argument «agente» to be a valid network monirot agent like 'node:pcap' in order to «Castelog.metodos.un_monitoreo_de_red»\");\n        }\n    } catch (error) {\n        console.log(\"Error al intentar «Castelog.metodos.un_monitoreo_de_red»:\", error);\n        console.log(\"(*) Nota específica de error (1): recuerda que para «Castelog.metodos.un_monitoreo_de_red(...)» necesitas la dependencia «libpcap» en tu sistema operativo\");\n        console.log(\"(*) Nota específica de error (2): recuerda que para «Castelog.metodos.un_monitoreo_de_red(...)» necesitas la dependencia «pcap» en tu «node_modules»\");\n        console.log(\"(*) Nota específica de error (3): recuerda que para «Castelog.metodos.un_monitoreo_de_red(...)» necesitarás normalmente privilegios elevados en el dispositivo o «sudo node ~.js» debido al uso del modo promiscuo de la tarjeta de red\");\n        throw error;\n    }\n};\n\n//Included:lib/542.castelog.v1.metodos.una_propiedad_para.js\nCastelog.metodos.no_es_propietizable = objeto => (typeof objeto !== \"object\") && (typeof objeto !== \"string\") && (typeof objeto !== \"function\");\nCastelog.metodos.no_tiene_propiedad = (objeto, propiedad) => Castelog.metodos.no_es_propietizable(objeto) || (typeof propiedad !== \"string\") || (!(propiedad in objeto));\nCastelog.metodos.una_propiedad_para = async (propiedad, objeto, valor_por_defecto = undefined) => {\n    if(!Array.isArray(propiedad)) {\n        throw new Error(\"Required parameter «propiedad» to be an array in order to «Castelog.metodos.una_propiedad_para»\");\n    }\n    let valor_pivote = objeto;\n    for(let index_propiedad = 0; index_propiedad < propiedad.length; index_propiedad++) {\n        const id_de_propiedad = propiedad[index_propiedad];\n        if(Castelog.metodos.no_tiene_propiedad(valor_pivote, id_de_propiedad)) return valor_por_defecto;\n        valor_pivote = valor_pivote[id_de_propiedad];\n    }\n    return valor_pivote;\n};\n\n//Included:lib/543.castelog.v1.metodos.siendo.js\nCastelog.metodos.siendo = (base, filtros) => {\n    if(!Array.isArray(filtros)) {\n        throw new Error(\"Required parameter «filtros» to be an array in order to «Castelog.metodos.siendo»\");\n    }\n    let salida = base;\n    for(let indexFiltros = 0; indexFiltros < filtros.length; indexFiltros++) {\n        const [filtro, parametros] = filtros[indexFiltros];\n        if(!(filtro in Castelog.variables.apendices_de_siendo)) {\n            throw new Error(\"Required filter «\" + filtro + \"» to be registered on «Castelog.variables.apendices_de_siendo» in order to «Castelog.metodos.siendo@\" + filtro + \"»\");\n        }\n        const filtroFunction = Castelog.variables.apendices_de_siendo[filtro];\n        salida = filtroFunction(salida, parametros);\n    }\n    return salida;\n};\n\n//Included:lib/544.castelog.v1.metodos.una_espera_de.js\nCastelog.metodos.una_espera_de = (tiempo, bloque) => {\n    if(typeof tiempo !== \"number\") {\n        throw new Error(\"Required parameter «tiempo» to be a number in order to «Castelog.metodos.una_espera_de\");\n    }\n    if(typeof bloque !== \"function\") {\n        throw new Error(\"Required parameter «bloque» to be a function in order to «Castelog.metodos.una_espera_de\");\n    }\n    return new Promise(ok => {\n        bloque();\n        setTimeout(() => {\n            try {\n                ok();\n            } catch(error) {\n                fail(error);\n            }\n        }, tiempo);\n    })\n};\n\n//Included:lib/545.castelog.v1.metodos.una_aplicacion_sintactica_universal.js\nCastelog.metodos.una_aplicacion_sintactica_universal = (comandos, configuracion) => {\n    if(typeof comandos !== \"object\") {\n        throw new Error(\"Required parameter «comandos» to be an object in order to «Castelog.metodos.una_aplicacion_sintactica_universal»\");\n    }\n    if(typeof configuracion !== \"object\") {\n        throw new Error(\"Required parameter «configuracion» to be an object in order to «Castelog.metodos.una_aplicacion_sintactica_universal»\");\n    }\n    return new Castelog.variables.Aplicacion_sintactica_universal(comandos, configuracion);\n};\n\n//Included:lib/546.castelog.v1.metodos.un_punto_sintactico_universal.js\nCastelog.metodos.un_punto_sintactico_universal = (comando) => {\n    if (typeof comando !== \"function\") {\n        throw new Error(\"Required parameter «comando» to be an function in order to «Castelog.metodos.un_punto_sintactico_universal»\");\n    }\n    return new Castelog.variables.Punto_sintactico_universal(comando);\n};\n\n//Included:lib/547.castelog.v1.metodos.un_call_wait_map.js\nCastelog.metodos.un_call_wait_map = function(promiseMapping, defaultObject = {}, args = []) {\n\t// Collect:\n\tconst startedPromises = [];\n\tconst out = defaultObject;\n\t// Collect:\n\tfor(const prop in promiseMapping) {\n\t\ttry {\n\t\t\tconst val = promiseMapping[prop];\n\t\t\tlet result = undefined;\n\t\t\tif((typeof result === \"function\") && (result instanceof Promise)) {\n\t\t\t\tconst currentPromise = result.then(data => {\n\t\t\t\t\tout[prop] = data;\n\t\t\t\t\treturn out;\n\t\t\t\t});\n\t\t\t\tstartedPromises.push(currentPromise);\n\t\t\t} else if(typeof val === \"function\") {\n\t\t\t\tresult = val(...args);\n\t\t\t\tout[prop] = result;\n\t\t\t} else {\n\t\t\t\tresult = val;\n\t\t\t\tout[prop] = result;\n\t\t\t}\n\t\t} catch(error) {\n\t\t\tconsole.log(\"Error en «Castelog.metodos.un_call_wait_map» índice «\" + prop + \"»:\", error);\n\t\t}\n\t}\n\tif(startedPromises.length) {\n\t\treturn Promise.all(startedPromises).then(data => out).catch(error => console.log(\"Error en «Castelog.metodos.un_call_wait_map» con una función-promesa:\", error));\n\t}\n\treturn out;\n};\n\n//Included:lib/550.castelog.v1.metodos.un_abstract_factory_design_pattern.js\nCastelog.metodos.un_abstract_factory_design_pattern = function(data) {\n\t// Collect:\n\tconst dp = {};\n\tObject.assign(dp, {\n\t\tabstractFactory: (dp) => ({ build(productParams) { return productParams; } }),\n\t\tfactories: (dp) => ({}),\n\t\tproducts: (dp) => ({})\n\t}, data);\n\t// Make\n\tCastelog.metodos.un_call_wait_map([\n\t\t[\"products\", dp.products()],\n\t\t[\"factories\", dp.factories()],\n\t\t[\"abstractFactory\", dp.abstractFactory()]\n\t], dp);\n\tdp.abstractFactory.createFactory = function (factoryParams = {}) {\n\t\tif(typeof factoryParams !== \"object\") throw new Error(\"Required «factoryParams» to be an object in order to «Castelog.metodos.un_abstract_factory_design_pattern»\");\n\t\tif(typeof factoryParams.type !== \"string\") throw new Error(\"Required «factoryParams.type» to be a string in order to «Castelog.metodos.un_abstract_factory_design_pattern»\");\n\t\tif(!(factoryParams.type in dp.factories)) throw new Error(\"Required «factoryParams.type» to be a known factory class in order to «Castelog.metodos.un_abstract_factory_design_pattern»\");\n\t\tconst factoryClass = dp.factories[factoryParams.type];\n\t\tlet factoryInstance = undefined;\n\t\tif(typeof factoryClass === \"object\") { factoryInstance = Object.assign(factoryClass, factoryParams); }\n\t\telse if(typeof factoryClass === \"function\") { factoryInstance = new factoryClass(factoryParams); }\n\t\telse throw new Error(\"Required «factories.\" + factoryParams.type + \"» to be an object or a class in order to «Castelog.metodos.un_abstract_factory_design_pattern»\");\n\t\treturn factoryInstance;\n\t};\n\tdp.abstractFactory.createProduct = function (factoryParams = {}, productParams = {}) {\n\t\tconst factoryInstance = dp.abstractFactory.createFactory(factoryParams);\n\t\tif(typeof factoryInstance !== \"object\") throw new Error(\"Required «new factories.\" + factoryParams.type + \"(...)» to return an object in order to «Castelog.metodos.un_abstract_factory_design_pattern»\");\n\t\tif(typeof factoryInstance.build === \"function\") return factoryInstance.build(productParams);\n\t\treturn dp.abstractFactory.build(productParams);\n\t};\n\t// Use\n\treturn dp;\n};\n\n//Included:lib/550.castelog.v1.metodos.un_adapter_design_pattern.js\nCastelog.metodos.un_adapter_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_bridge_design_pattern.js\nCastelog.metodos.un_bridge_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_builder_design_pattern.js\nCastelog.metodos.un_builder_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_chain_of_responsability_design_pattern.js\nCastelog.metodos.un_chain_of_responsability_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_command_design_pattern.js\nCastelog.metodos.un_command_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_composite_design_pattern.js\nCastelog.metodos.un_composite_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_decorator_design_pattern.js\nCastelog.metodos.un_decorator_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_facade_design_pattern.js\nCastelog.metodos.un_facade_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_factory_method_design_pattern.js\nCastelog.metodos.un_factory_method_design_pattern = function (data) {\n\t// Collect:\n\tconst dp = {};\n\tObject.assign(dp, {\n\t\tfactory: (dp) => {\n\t\t\treturn (name = \"DefaultFactory\", parameters = {}, buildParameters = {}, usingOop = true) => {\n\t\t\t\tif(typeof name !== \"string\") throw new Error(\"Required parameter «name» to be a string in order to «Castelog.metodos.un_factory_method_design_pattern»\");\n\t\t\t\tif(typeof parameters !== \"object\") throw new Error(\"Required parameter «name» to be an object in order to «Castelog.metodos.un_factory_method_design_pattern»\");\n\t\t\t\tif(!(name in dp.classes)) throw new Error(\"Required parameter «name» to be a class known by «dp.classes» in order «Castelog.metodos.un_factory_method_design_pattern»\");\n\t\t\t\tconst clazz = dp.classes[name];\n\t\t\t\tlet instanze = undefined;\n\t\t\t\tif(usingOop === true) {\n\t\t\t\t\tinstanze = new clazz(parameters);\n\t\t\t\t} else {\n\t\t\t\t\tinstanze = clazz(parameters);\n\t\t\t\t}\n\t\t\t\tif (typeof instanze.build === \"function\") {\n\t\t\t\t\treturn instanze.build(buildParameters);\n\t\t\t\t}\n\t\t\t\treturn instanze;\n\t\t\t};\n\t\t},\n\t\tclasses: (dp) => {\n\t\t\treturn {};\n\t\t},\n\t\tproducts: (dp) => {\n\t\t\treturn {};\n\t\t}\n\t}, data);\n\t// Consume && Format\n\treturn Castelog.metodos.un_call_wait_map([\n\t\t[\"factory\", dp.factory()],\n\t\t[\"classes\", dp.classes()],\n\t\t[\"products\", dp.products()]\n\t], dp);\n};\n\n//Included:lib/550.castelog.v1.metodos.un_flyweight_design_pattern.js\nCastelog.metodos.un_flyweight_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_hooks_design_pattern.js\nCastelog.metodos.un_hooks_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_interpreter_design_pattern.js\nCastelog.metodos.un_interpreter_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_iterator_design_pattern.js\nCastelog.metodos.un_iterator_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_mediator_design_pattern.js\nCastelog.metodos.un_mediator_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_memento_design_pattern.js\nCastelog.metodos.un_memento_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_observer_design_pattern.js\nCastelog.metodos.un_observer_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_progressive_composition_design_pattern.js\nCastelog.metodos.un_progressive_composition_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_progressive_decoration_design_pattern.js\nCastelog.metodos.un_progressive_decoration_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_prototype_design_pattern.js\nCastelog.metodos.un_prototype_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_proxy_design_pattern.js\nCastelog.metodos.un_proxy_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_singleton_design_pattern.js\nCastelog.metodos.un_singleton_design_pattern = function(data) {\n\t// Collect:\n\tconst dp = {};\n\tObject.assign(dp, {\n\t\tgetter: (dp) => {\n\t\t\treturn () => {\n\t\t\t\tif(typeof dp.value === \"undefined\") {\n\t\t\t\t\tdp.setter();\n\t\t\t\t}\n\t\t\t\treturn dp.value;\n\t\t\t};\n\t\t},\n\t\tsetter: (dp) => {\n\t\t\treturn () => {\n\t\t\t\tdp.value = undefined;\n\t\t\t}\n\t\t},\n\t\tvalue: (dp) => 500\n\t}, data);\n\t// Consume && Format\n\treturn Castelog.metodos.un_call_wait_map([\n\t\t[ \"value\", dp.value() ],\n\t\t[ \"setter\", dp.setter() ],\n\t\t[ \"getter\", dp.getter() ]\n\t], dp);\n\treturn dp;\n};\n\n//Included:lib/550.castelog.v1.metodos.un_state_design_pattern.js\nCastelog.metodos.un_state_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_strategy_design_pattern.js\nCastelog.metodos.un_strategy_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_template_method_design_pattern.js\nCastelog.metodos.un_template_method_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/550.castelog.v1.metodos.un_visitor_design_pattern.js\nCastelog.metodos.un_visitor_design_pattern = function(data) {\n\treturn {};\n};\n\n//Included:lib/553.castelog.v1.metodos.un_componente_vue2.js\nCastelog.metodos.un_componente_vue2 = function(id, plantilla, logica, estilos, parametros_de_estilos = {}) {\n    if(typeof window === \"object\") {\n        const vue_global = (typeof window.Vue !== \"undefined\") ? window.Vue :\n            (typeof window.vue !== \"undefined\") ? window.vue : undefined;\n        if(typeof vue_global === \"undefined\") {\n            throw new Error(\"Castelog no pudo encontrar Vue en el entorno vía 'window.vue' o 'window.Vue'\");\n        }\n        const componente_base_original = { template: plantilla };\n        const definicion_logica_de_componente = logica ? logica(componente_base_original) : {};\n        const componente_base = Object.assign({}, componente_base_original, definicion_logica_de_componente);\n        const componente_clase_base = vue_global.component(id, componente_base);\n        const uniqueId = \"castelog-style-tag-\" + id;\n        const foundElement = document.getElementById(uniqueId);\n        if(estilos && !foundElement) {\n            const styleTag = document.createElement(\"style\");\n            styleTag.id = uniqueId;\n            styleTag.textContent = Castelog.metodos.una_plantilla(estilos, {\n                estilo_uid: uniqueId,\n                componente: componente_base,\n                componente_id: id,\n                componente_clase: componente_clase_base,\n                ...parametros_de_estilos,\n            })();\n            document.head.appendChild(styleTag);\n        }\n        return componente_clase_base;\n    } else if(typeof global === \"object\") {\n        return;\n    }\n};\n\n//Included:lib/554.castelog.v1.metodos.una_aplicacion_vue2.js\nCastelog.metodos.una_aplicacion_vue2 = function (id, plantilla, logica, estilos, parametros_de_estilos = {}, rutas = [], traducciones = [], montada = null) {\n    if(typeof window === \"object\") {\n        const vue_global = (typeof window.Vue !== \"undefined\") ? window.Vue : (typeof window.vue !== \"undefined\") ? window.vue : undefined;\n        if(typeof vue_global === \"undefined\") {\n            throw new Error(\"Castelog no pudo encontrar Vue en el entorno vía 'window.vue' o 'window.Vue'\");\n        }\n        if(typeof vue_global.prototype.$primera_app_vue_desde_castelog === \"undefined\") {\n            if(typeof VueI18next !== \"undefined\") {\n                vue_global.use(VueI18n);\n            }\n        }\n        const componente_base_original = { template: plantilla };\n        const definicion_logica_de_componente = logica ? logica(componente_base_original) : {};\n        const componente_base = Object.assign({}, componente_base_original, definicion_logica_de_componente);\n        const uniqueId = \"castelog-style-tag-\" + id;\n        const foundElement = document.getElementById(uniqueId);\n        if(estilos && (!foundElement)) {\n            const styleTag = document.createElement(\"style\");\n            styleTag.id = uniqueId;\n            styleTag.textContent = Castelog.metodos.una_plantilla(estilos, {\n                estilo_uid: uniqueId,\n                componente: componente_base,\n                componente_id: id,\n                ...parametros_de_estilos,\n            })();\n            document.head.appendChild(styleTag);\n        }\n        // const userPreferredLocales = window.navigator.languages;\n        // const localeIds = Object.keys(traducciones);\n        // let currentLocale = \"en\";\n        // for(let indexLocales = 0; indexLocales < userPreferredLocales.length; indexLocales++) {\n        //     const userPreferredLocale = userPreferredLocales[indexLocales];\n        //     const userPreferredIso = userPreferredLocale.split(\"-\")[0];\n        //     const localePosition = localeIds.indexOf(userPreferredIso);\n        //     if (localePosition !== -1) {\n        //         currentLocale = localeIds[localePosition];\n        //     }\n        // }\n        // i18next.init({\n        //     lng: currentLocale,\n        //     nsSeparator: \"#<1>#\",\n        //     keySeparator: \"#<2>#\",\n        //     pluralSeparator: \"#<3>#\",\n        //     contextSeparator: \"#<4>#\",\n        //     resources: traducciones ? Object.keys(traducciones).reduce(function(out, key) {\n        //         if(!(key in out)) {\n        //             out[key] = {\n        //                 translation: traducciones[key]\n        //             };\n        //         }\n        //         return out;\n        //     }, {}) : {}\n        // });\n        const vue_global_parameters = {...componente_base};\n        if(Array.isArray(rutas) && rutas.length) {\n            if(typeof vue_global.prototype.$primera_app_vue_desde_castelog === \"undefined\") {\n                vue_global_parameters.router = new VueRouter({\n                    routes: rutas\n                });\n            } else {\n                throw new Error(\"Una segunda app vue no permite definir rutas específicas.\");\n            }\n        }\n        // if(!(\"$i18n\" in vue_global.prototype)) {\n        //     vue_global_parameters.i18n = new VueI18next(i18next);\n        // }\n        const instancia_base = new vue_global(vue_global_parameters);\n        if(typeof(montada) === \"string\") {\n            instancia_base.$mount(montada);\n        } else {\n            console.log(\"[!] Aplicación Vue2 no montada.\");\n            console.log(\" [+] montada:\", montada);\n            console.log(\" [+] id:\", id);\n            console.log(\" [+] plantilla:\", plantilla);\n            console.log(\" [+] logica:\", logica);\n            console.log(\" [+] estilos:\", estilos);\n            console.log(\" [+] rutas:\", rutas);\n            console.log(\" [+] traducciones:\", traducciones);\n        }\n        vue_global.prototype.$primera_app_vue_desde_castelog = instancia_base;\n        return instancia_base;\n    } else if(typeof global === \"object\") {\n        return;\n    }\n};\n\n//Included:lib/560.castelog.v1.metodos.un_numero_textual.js\nCastelog.metodos.un_numero_textual = function(numeroTextual) {\n    // @TOOVERRIDE:\n    return numeroTextual;\n};\n\n//Included:lib/561.castelog.v1.metodos.un_sistema_rest.js\nCastelog.metodos.un_sistema_rest = function(configuraciones, configuracionesServer, donde, tipo, enError) {\n    if(typeof configuraciones !== \"object\") {\n        throw new Error(\"Required parameter «configuraciones» to be an object in order to «un_sistema_rest»\");\n    }\n    if(typeof configuracionesServer !== \"object\") {\n        throw new Error(\"Required parameter «configuracionesServer» to be an object in order to «un_sistema_rest»\");\n    }\n    if(typeof configuracionesServer.adapter !== \"string\") {\n        configuracionesServer.adapter = \"dexie\";\n    }\n    let ServerClass = undefined;\n    if(configuracionesServer.adapter === \"mysql\") {\n        if(configuraciones.platform !== \"node\") {\n            throw new Error(\"Required parameter «configuracionesServer.adapter» to be compatible with «configuracionesApi.platform» in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials !== \"object\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials» to be an object in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials.user !== \"string\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials.user» to be an string in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials.password !== \"string\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials.password» to be an string in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials.host !== \"string\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials.host» to be an string in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials.port !== \"number\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials.port» to be an number in order to «un_sistema_rest»\");\n        }\n        if(typeof configuracionesServer.credentials.database !== \"string\") {\n            throw new Error(\"Required parameter «configuracionesServer.credentials.database» to be an string in order to «un_sistema_rest»\");\n        }\n    } else if(configuracionesServer.adapter === \"dexie\") {\n        if (configuraciones.platform !== \"browser\") {\n            configuraciones.platform = \"browser\";\n        }\n    } else {\n        throw new Error(\"Required parameter «configuraciones.adapter» to be a known type ('dexie','mysql') in order to «un_sistema_rest»\");\n    }\n    const RestAPI = Castelog.variables.Automatic_http_rest_api_interface(configuraciones);\n    if (configuracionesServer.adapter === \"dexie\") {\n        ServerClass = RestAPI.VirtualDataServer;\n    } else if (configuracionesServer.adapter === \"mysql\") {\n        ServerClass = RestAPI.DataServer;\n    } else {\n        throw new Error(\"Required parameter «configuraciones.adapter» to be a known type ('dexie','mysql') in order to «un_sistema_rest»\");\n    }\n    return ServerClass.initialize(configuracionesServer).then(serverInstance => {\n        Object.assign(serverInstance, {\n            create(options) {\n                return {\n                    instanceType: \"standard\",\n                    select(modelo, filtrando, ordenando, agrupando, paginando, bd, adaptador, objetivo) {\n                        if(objetivo === \"a un ítem\") {\n                            return serverInstance.rest.selectOne(modelo, {\n                                where: filtrando ? filtrando : []\n                            });\n                        } else if (objetivo === \"a varios ítems\") {\n                            return serverInstance.rest.selectMany(modelo, {\n                                where: filtrando ? filtrando : [],\n                                order: ordenando ? ordenando : [],\n                                groups: agrupando ? agrupando : [],\n                                pagination: paginando ? paginando : [1, 20]\n                            });\n                        } else if (objetivo === \"al primer ítem\") {\n                            return serverInstance.rest.selectFirst(modelo, {\n                                where: filtrando ? filtrando : [],\n                                order: ordenando ? ordenando : [],\n                                groups: agrupando ? agrupando : [],\n                                pagination: paginando ? paginando : [1, 20]\n                            });\n                        } else if (objetivo === \"al último ítem\") {\n                            return serverInstance.rest.selectLast(modelo, {\n                                where: filtrando ? filtrando : [],\n                                order: ordenando ? ordenando : [],\n                                groups: agrupando ? agrupando : [],\n                                pagination: paginando ? paginando : [1, 20]\n                            });\n                        } else {\n                            throw new Error(\"Required argument «motivo» to be an identifiable string in order to «select»\");\n                        }\n                    },\n                    insert(modelo, valores) {\n                        return serverInstance.rest.insertMany(modelo, {\n                            items: Array.isArray(valores) ? valores : [valores]\n                        });\n                    },\n                    update(modelo, filtrando, valores) {\n                        return serverInstance.rest.updateMany(modelo, {\n                            where: filtrando,\n                            values: valores\n                        });\n                    },\n                    delete(modelo, filtrando) {\n                        return serverInstance.rest.deleteMany(modelo, {\n                            where: filtrando\n                        });\n                    }\n                };\n            }\n        });\n        if(typeof donde === \"function\") {\n            return (async () => {\n                try {\n                    await donde(serverInstance);\n                    return serverInstance;\n                } catch(error) {\n                    if (typeof enError === \"function\") {\n                        return enError(error, RestAPI, serverInstance);\n                    }\n                }\n            });\n        }\n        return serverInstance;\n    }).catch(error => {\n        if(typeof enError === \"function\") {\n            return enError(error, RestAPI);\n        }\n    });\n};\n\n//Included:lib/562.castelog.v1.metodos.un_diagrama_conceptual.js\nCastelog.metodos.termino_el_programa = function(...args) {\n    debugar_sintaxis_de_diagramas(...args);\n    process.exit(0);\n};\n\nCastelog.variables.DiagramaConceptualPorDefecto = function () {\n    debugar_sintaxis_de_diagramas(\"Entro en: Castelog.variables.DiagramaConceptualPorDefecto\");\n    this.codigo = {\n        cabeceras: \"\",\n        pieceras: \"\",\n        nodos: \"\",\n        relaciones: \"\"\n    };\n    this.sentencias = [];\n    this.toMermaidCode = () => {\n        return this.codigo.cabeceras + \"\\n\" + this.codigo.nodos + \"\\n\" + this.codigo.relaciones + \"\\n\" + this.codigo.pieceras;\n    };\n    return this;\n};\n\nCastelog.variables.ContextoDeDiagramaConceptual = function (id_original, extra) {\n    debugar_sintaxis_de_diagramas(\"Entro en: Castelog.variables.ContextoDeDiagramaConceptual\");\n    let id = id_original;\n    if(id_original instanceof Castelog.variables.ContextoDeDiagramaConceptual) {\n        id = id_original.id;\n    }\n    if(!Array.isArray(id)) {\n        throw new Error(\"Required argument «id» to be an array in order to «Castelog.variables.ContextoDeDiagramaConceptual»\");\n    }\n    this.id = id;\n    if(typeof extra === \"string\") {\n        this.id = this.id.concat(extra);\n    } else if(typeof extra === \"undefined\") {\n        // @OK\"\n    } else {\n        throw new Error(\"Required argument «extra» to be a string or undefined in order to «Castelog.variables.ContextoDeDiagramaConceptual»\");\n    }\n    return this;\n};\nCastelog.variables.ContextoDeDiagramaConceptual.prototype = {};\nCastelog.variables.ContextoDeDiagramaConceptual.prototype.tabulacion = function() {\n    let tab = \"\";\n    for(let index = 0; index < this.id.length; index++) {\n        const id_item = this.id[index];\n        tab += \"  \";\n    }\n    return tab;\n};\n\nCastelog.variables.DiagramaConceptualSeleccionado = Castelog.variables.DiagramaConceptualPorDefecto;\n\nCastelog.variables.configuraciones_de_constructor_de_diagramas = { debug: false };\n\nconst debugar_sintaxis_de_diagramas = function(...args) {\n    if(Castelog.variables.configuraciones_de_constructor_de_diagramas.debug) {\n        console.log(...args);\n    }\n};\n\nconst comprobar_objeto_de_diagrama = function(method, diagrama) {\n    debugar_sintaxis_de_diagramas(\"Entro en: comprobar_objeto_de_diagrama\");\n    debugar_sintaxis_de_diagramas(\"OK en:\" + method);\n    if(!(diagrama instanceof Castelog.variables.DiagramaConceptualSeleccionado)) {\n        throw new Error(\"Required argument «diagrama» to be an instance of «Castelog.variables.DiagramaConceptualSeleccionado» in order to «\" + method + \"»\");\n    }\n};\n\nconst comprobar_contexto_de_diagrama = function (method, contexto) {\n    debugar_sintaxis_de_diagramas(\"Entro en: comprobar_contexto_de_diagrama\");\n    debugar_sintaxis_de_diagramas(\"OK en:\" + method);\n    if(!(contexto instanceof Castelog.variables.ContextoDeDiagramaConceptual)) {\n        throw new Error(\"Required argument «contexto» to be an instance of «Castelog.variables.ContextoDeDiagramaConceptual» in order to «\" + method + \"»\");\n    }\n};\n\nconst comprobar_valor_de_diagrama = function (method, valor) {\n    debugar_sintaxis_de_diagramas(\"Entro en: comprobar_valor_de_diagrama\");\n    debugar_sintaxis_de_diagramas(\"OK en:\" + method);\n    if (typeof valor !== \"object\") {\n        throw new Error(\"Required argument «valor» to be an object in order to «\" + method + \"»\");\n    }\n};\n\nCastelog.metodos.un_diagrama_conceptual = async function(datos_de_diagrama, en_errores) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.un_diagrama_conceptual\");\n        if (typeof datos_de_diagrama !== \"function\") {\n            throw new Error(\"Required argument «datos_de_diagrama» to be a function in order to «Castelog.metodos.un_diagrama_conceptual»\");\n        }\n        const diagrama_objeto = new Castelog.variables.DiagramaConceptualSeleccionado();\n        const contexto_de_diagrama = new Castelog.variables.ContextoDeDiagramaConceptual([]);\n        await datos_de_diagrama(diagrama_objeto, contexto_de_diagrama);\n        return diagrama_objeto;\n    } catch(error) {\n        if(typeof en_errores === \"function\") {\n            return en_errores(error);\n        }\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_direccion_de_diagrama = async function(diagrama, valor) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_direccion_de_diagrama\");\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_direccion_de_diagrama\", diagrama);\n        diagrama.codigo.cabeceras += \"graph \";\n        switch (valor) {\n            case \"izquierda a derecha\":\n                diagrama.codigo.cabeceras += \"LR;\\n\";\n                break;\n            case \"derecha a izquierda\":\n                diagrama.codigo.cabeceras += \"RL;\\n\";\n                break;\n            case \"arriba a abajo\":\n                diagrama.codigo.cabeceras += \"TB;\\n\";\n                break;\n            case \"abajo a arriba\":\n                diagrama.codigo.cabeceras += \"BT;\\n\";\n                break;\n            default:\n                throw new Error(\"Required argument «valor» to be recognized on «Castelog.metodos.defino_direccion_de_diagrama»\");\n        }\n        diagrama.sentencias.push({ tipo: \"dirección de diagrama\", valor });\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_direccion_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_nodo_de_diagrama = async function(diagrama, valor, contexto) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_nodo_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_nodo_de_diagrama\", diagrama, valor, contexto);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_nodo_de_diagrama\", diagrama);\n        comprobar_contexto_de_diagrama(\"Castelog.metodos.defino_nodo_de_diagrama\", contexto);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_nodo_de_diagrama\", valor);\n        const { nombre } = valor;\n        let { texto } = valor;\n        if (typeof nombre !== \"string\") {\n            throw new Error(\"Required argument «nombre» to be a string in order to «Castelog.metodos.defino_nodo_de_diagrama»\");\n        }\n        if(!(\"texto\" in valor)) {\n            texto = nombre;\n        }\n        if (typeof texto !== \"string\") {\n            throw new Error(\"Required argument «texto» to be a string in order to «Castelog.metodos.defino_nodo_de_diagrama»\");\n        }\n        const abre_grupo = \"[\";\n        const cierra_grupo = \"]\";\n        diagrama.codigo.nodos += `${contexto.tabulacion()}${nombre}${abre_grupo}${JSON.stringify(texto)}${cierra_grupo};\\n`;\n        diagrama.sentencias.push({ tipo: \"nodo de diagrama\", valor, contexto });\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_nodo_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_relacion_de_diagrama = async function(diagrama, valor) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_relacion_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_relacion_de_diagrama\", diagrama, valor);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_relacion_de_diagrama\", diagrama);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_relacion_de_diagrama\", valor);\n        const { origen, texto, destino } = valor;\n        if (typeof origen !== \"string\") {\n            throw new Error(\"Required argument «origen» to be a string in order to «Castelog.metodos.defino_relacion_de_diagrama»\");\n        }\n        if (typeof texto !== \"string\") {\n            throw new Error(\"Required argument «texto» to be a string in order to «Castelog.metodos.defino_relacion_de_diagrama»\");\n        }\n        if (typeof destino !== \"string\") {\n            throw new Error(\"Required argument «destino» to be a string in order to «Castelog.metodos.defino_relacion_de_diagrama»\");\n        }\n        const abre_relacion = \"-- \";\n        const cierra_relacion = \" -->\";\n        diagrama.codigo.relaciones += `${origen} ${abre_relacion}${texto}${cierra_relacion} ${destino}\\n`;\n        diagrama.sentencias.push({ tipo: \"relación de diagrama\", valor });\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_relacion_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_conjunto_de_diagrama = async function(diagrama, valor, contexto) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_conjunto_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_conjunto_de_diagrama\", diagrama, valor, contexto);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_conjunto_de_diagrama\", diagrama);\n        comprobar_contexto_de_diagrama(\"Castelog.metodos.defino_conjunto_de_diagrama\", contexto);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_conjunto_de_diagrama\", valor);\n        const { nombre, callback } = valor;\n        if (typeof nombre !== \"string\") {\n            throw new Error(\"Required argument «nombre» to be a string in order to «Castelog.metodos.defino_conjunto_de_diagrama»\");\n        }\n        if(typeof callback !== \"function\") {\n            throw new Error(\"Required argument «callback» to be a function in order to «Castelog.metodos.defino_conjunto_de_diagrama»\");\n        }\n        const nuevo_contexto = new Castelog.variables.ContextoDeDiagramaConceptual(contexto, nombre);\n        diagrama.sentencias.push({ tipo: \"conjunto de diagrama\", valor, contexto });\n        diagrama.codigo.nodos += `${contexto.tabulacion()}subgraph ${nombre}:\\n`;\n        await callback(diagrama, nuevo_contexto);\n        diagrama.codigo.nodos += `${contexto.tabulacion()}end\\n`;\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_conjunto_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_clase_de_diagrama = async function(diagrama, valor) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_clase_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_clase_de_diagrama\", diagrama, valor);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_clase_de_diagrama\", diagrama);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_clase_de_diagrama\", valor);\n        const { nombre, relleno = \"#FFF\", grosor = \"1px\", borde = \"#333\" } = valor;\n        if(typeof nombre !== \"string\") {\n            throw new Error(\"Required argument «nombre» to be a string in order to «Castelog.metodos.defino_clase_de_diagrama»\");\n        }\n        if (typeof relleno !== \"string\") {\n            throw new Error(\"Required argument «relleno» to be a string in order to «Castelog.metodos.defino_clase_de_diagrama»\");\n        }\n        if (typeof grosor !== \"string\") {\n            throw new Error(\"Required argument «grosor» to be a string in order to «Castelog.metodos.defino_clase_de_diagrama»\");\n        }\n        if (typeof borde !== \"string\") {\n            throw new Error(\"Required argument «borde» to be a string in order to «Castelog.metodos.defino_clase_de_diagrama»\");\n        }\n        diagrama.sentencias.push({ tipo: \"clase de diagrama\", valor });\n        diagrama.codigo.pieceras += `classDef ${nombre} fill:${relleno},stroke:${borde},stroke-width:${grosor}\\n`;\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_clase_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_clasificacion_de_diagrama = async function(diagrama, valor) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_clasificacion_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_clasificacion_de_diagrama\", diagrama, valor);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_clasificacion_de_diagrama\", diagrama);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_clasificacion_de_diagrama\", valor);\n        const { nombre, nodos } = valor;\n        if (typeof nombre !== \"string\") {\n            throw new Error(\"Required argument «nombre» to be a string in order to «Castelog.metodos.defino_clasificacion_de_diagrama\");\n        }\n        if (!Array.isArray(nodos)) {\n            throw new Error(\"Required argument «nodos» to be an array in order to «Castelog.metodos.defino_clasificacion_de_diagrama\");\n        }\n        for(let index = 0; index < nodos.length; index++) {\n            const nodo = nodos[index];\n            diagrama.codigo.pieceras += `class ${nombre} ${nodo}\\n`;\n            diagrama.sentencias.push({ tipo: \"clasificación de diagrama\", valor });\n        }\n    } catch(error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_clasificacion_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\nCastelog.metodos.defino_estrategias_de_diagrama = async function(diagrama, valor) {\n    try {\n        debugar_sintaxis_de_diagramas(\"Entro en: Castelog.metodos.defino_estrategias_de_diagrama\");\n        debugar_sintaxis_de_diagramas(\"defino_estrategias_de_diagrama\", diagrama, valor);\n        comprobar_objeto_de_diagrama(\"Castelog.metodos.defino_estrategias_de_diagrama\", diagrama);\n        comprobar_valor_de_diagrama(\"Castelog.metodos.defino_estrategias_de_diagrama\", valor);\n    } catch (error) {\n        debugar_sintaxis_de_diagramas(\"Error on «Castelog.metodos.defino_estrategias_de_diagrama»:\", error);\n        throw error;\n    }\n};\n\n\n//Included:lib/562.castelog.v1.metodos.un_diagrama_de_dependencias.js\nCastelog.variables.Gestor_de_dependencia = class {\n    static create(...args) {\n        return new this(...args);\n    }\n    constructor(dependencies, scope) {\n        this.data = [];\n        this.dependencies = dependencies;\n        this.scope = scope;\n        this.find = {\n            one: this.$find_one,\n        };\n        this.append = this.$append;\n        this.config = {\n            tipo: this.$from_scope_to_tipo(scope)\n        };\n    }\n    $find_one(filter) {\n        const result = this.data.filter(filter);\n        if (result.length === 0) throw new Error(\"Required parameter «filter» to result in any match on «\" + this.scope + \"» in order to «Castelog.variables.Gestor_de_dependencia.find_one»\");\n        if (result.length !== 1) throw new Error(\"Required parameter «filter» to result in a match of only one item on «\" + this.scope + \"» in order to «Castelog.variables.Gestor_de_dependencia.find_one»\");\n        return result[0];\n    }\n    $append() {\n        const sentence = {\n            tipo: this.config.tipo,\n            item,\n        };\n        this.data.push(sentence);\n        this.dependencies.sentences.push(sentence);\n    }\n    $from_scope_to_tipo(scope) {\n        return scope === \"packages\" ? \"defino paquete\" :\n            scope === \"classes\" ? \"defino clase\" :\n            scope === \"objects\" ? \"defino objeto\" :\n            scope === \"functions\" ? \"defino función\" :\n            scope === \"factories\" ? \"defino fábrica\" :\n            scope === \"variables\" ? \"defino variable\" :\n            scope === \"constants\" ? \"defino constante\" :\n            scope === \"ui_components\" ? \"defino componente UI\" :\n            scope === \"ui_applications\" ? \"defino aplicación UI\" :\n            false;\n    }\n};\n\nCastelog.variables.Sistema_de_dependencias_de_software = class {\n    static create(...args) {\n        return new this(...args);\n    }\n    constructor() {\n        this.sentences = Castelog.variables.Gestor_de_dependencia.create(this, \"sentences\");\n        this.packages = Castelog.variables.Gestor_de_dependencia.create(this, \"packages\");\n        this.classes = Castelog.variables.Gestor_de_dependencia.create(this, \"classes\");\n        this.objects = Castelog.variables.Gestor_de_dependencia.create(this, \"objects\");\n        this.functions = Castelog.variables.Gestor_de_dependencia.create(this, \"functions\");\n        this.factories = Castelog.variables.Gestor_de_dependencia.create(this, \"factories\");\n        this.variables = Castelog.variables.Gestor_de_dependencia.create(this, \"variables\");\n        this.constants = Castelog.variables.Gestor_de_dependencia.create(this, \"constants\");\n        this.ui = {\n            components: Castelog.variables.Gestor_de_dependencia.create(this, \"ui_components\"),\n            applications: Castelog.variables.Gestor_de_dependencia.create(this, \"ui_applications\")\n        };\n        this.to = {\n            validation: () => {\n                try {\n                    \n                } catch(error) {\n                    throw error;\n                }\n            },\n            project: async (basepath = \".\") => {\n                try {\n                    const basedir = require(\"path\").resolve(basepath);\n                    const state = { dependencies: this, basedir, sentences: [], index: -1 };\n                    for (let indexSentence = 0; indexSentence < this.sentences.data.length; indexSentence++) {\n                        state.index = indexSentence;\n                        const sentence = this.sentences.data[indexSentence];\n                        const result = await this.de_sentencia_a_proyecto(sentence, state);\n                        state.sentences.push(result);\n                    }\n                    return result;\n                } catch (error) {\n                    throw error;\n                }\n            }\n        };\n    }\n    async de_sentencia_a_proyecto(sentence, state) {\n        try {\n            let result = false;\n            if (false) {\n            } else if (sentence.tipo === \"defino paquete\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino clase\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino objeto\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino función\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino fábrica\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino variable\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino constante\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino componente UI\") {\n                // @TODO...\n            } else if (sentence.tipo === \"defino aplicación UI\") {\n                // @TODO...\n            } else throw new Error(\"Required property «tipo» to be identificable in order to «Castelog.variables.Gestor_de_dependencia.to.project»\");\n            return result;\n        } catch (error) {\n            throw error;\n        }\n    }\n};\n\nCastelog.metodos.un_diagrama_de_dependencias = function(diagrama) {\n\n};\n\n//Included:lib/562.castelog.v1.metodos.utilidades_del_dom.js\nCastelog.metodos.una_seleccion_de_elementos_del_dom = function(parametros, base) {\n    if(typeof parametros !== \"string\") {\n        throw new Error(\"Required parameter «parametros» to be a string (a css selector) in order to «Castelog.metodos.una_seleccion_de_elementos_del_dom»\");\n    }\n    if(typeof base === \"string\") {\n        base = document.querySelector(base);\n    }\n    if(!(base instanceof HTMLElement)) {\n        throw new Error(\"Required parameter «base» to a string (a css selector) matching at least 1 element or an instance of HTMLElement in order to «Castelog.metodos.una_seleccion_de_elementos_del_dom»\");\n    }\n    return Array.from(base.querySelectorAll(parametros));\n};\nCastelog.metodos.una_seleccion_del_primer_elemento_del_dom = function(parametros, base) {\n    if (typeof parametros !== \"string\") {\n        throw new Error(\"Required parameter «parametros» to be a string (a css selector) in order to «Castelog.metodos.una_seleccion_del_primer_elemento_del_dom»\");\n    }\n    if (typeof base === \"string\") {\n        base = document.querySelector(base);\n    }\n    if (!(base instanceof HTMLElement)) {\n        throw new Error(\"Required parameter «base» to a string (a css selector) matching at least 1 element or an instance of HTMLElement in order to «Castelog.metodos.una_seleccion_del_primer_elemento_del_dom»\");\n    }\n    return base.querySelector(parametros);\n};\nCastelog.metodos.una_insercion_de_estilos_en_cascada = function(id, contenidos) {\n    const PROPERTY = \"data-identificador-de-estilo-en-cascada-de-castelog\";\n    const matches = Array.from(document.head.querySelectorAll(`style`)).filter(item => {\n        const id_elemento = item.getAttribute(PROPERTY);\n        return id === id_elemento;\n    });\n    if(matches.length) {\n        return false;\n    }\n    const styleTag = document.createElement(\"style\");\n    styleTag.setAttribute(PROPERTY, id);\n    styleTag.textContent = contenidos;\n    document.head.appendChild(styleTag);\n};\nCastelog.metodos.un_bloque_de_estilos_en_cascada = function(bloque_de_texto) {\n    return bloque_de_texto;\n};\nCastelog.metodos.una_insercion_de_elemento_del_dom = function(selector, base, elemento_html) {\n    if(typeof base === \"string\") {\n        base = Array.from(document.querySelectorAll(base));\n    }\n    if (base === null) {\n        base = [document.body];\n    }\n    if(base instanceof HTMLElement) {\n        base = [ base ];\n    }\n    if(!Array.isArray(base)) {\n        throw new Error(\"Required parameter «base» to result a css selection as an array in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    if(base.length === 0) {\n        throw new Error(\"Required parameter «base» to be css selection matching minimum 1 element in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    if(base.length > 1) {\n        throw new Error(\"Required parameter «base» to be css selection matching maximum 1 element in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    base = base[0];\n    if(!(base instanceof HTMLElement)) {\n        throw new Error(\"Required parameter «base» to result an instance of HTMLElement in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    if (typeof selector !== \"string\") {\n        throw new Error(\"Required parameter «selector» to be a string in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    const selection = base.querySelectorAll(selector);\n    if(selection.length === 0) {\n        throw new Error(\"Required parameter «selector» to match minimum 1 element in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    if(selection.length > 1) {\n        throw new Error(\"Required parameter «selector» to match maximum 1 element in order to «Castelog.metodos.una_insercion_de_elemento_del_dom»\");\n    }\n    const selected = selection[0];\n    selected.appendChild(elemento_html);\n    return [selected, elemento_html];\n};\nCastelog.metodos.un_elemento_jquery = function(...parametros) {\n    if(typeof jQuery !== \"function\") {\n        throw new Error(\"Required «jQuery» library to be loaded in order to «Castelog.metodos.un_elemento_jquery»\");\n    }\n    return jQuery(...parametros);\n};\n\n\n//Included:lib/563.castelog.v1.metodos.un_formateo_de_fecha.js\nCastelog.variables.formato_de_fecha_por_defecto = \"YYYY/MM/DD HH:mm:ss.xxx\";\nCastelog.metodos.un_formateo_de_fecha = function (fecha = new Date(), formato = Castelog.variables.formato_de_fecha_por_defecto, direccion = \"un formateo de fecha a texto\") {\n    const maxLength = Castelog.variables.formato_de_fecha_por_defecto.length;\n    const minLength = \"ss\".length;\n    if(typeof formato === \"undefined\") {\n        formato = Castelog.variables.formato_de_fecha_por_defecto;\n    }\n    if(formato === null) {\n        formato = Castelog.variables.formato_de_fecha_por_defecto;\n    }\n    if(direccion === \"un formateo de fecha a texto\") {\n        if(typeof formato !== \"string\") {\n            throw new Error(\"Required parameter «formato» to be a string while «direccion» is «un formateo de fecha a texto» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(formato.length > maxLength) {\n            throw new Error(\"Required parameter «formato» to be greater than «\" + maxLength + \"» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(formato.length < minLength) {\n            throw new Error(\"Required parameter «formato» to be greater than «\" + minLength + \"» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(!(fecha instanceof Date)) {\n            throw new Error(\"Required parameter «fecha» to be an instance of Date in order while «direccion» is «un formateo de fecha a texto» to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        return formato\n            .replace(\"YYYY\", Castelog.metodos.un_relleno_de_texto(fecha.getFullYear(), 4, \"0\"))\n            .replace(\"MM\", Castelog.metodos.un_relleno_de_texto(fecha.getMonth() + 1, 2, \"0\"))\n            .replace(\"DD\", Castelog.metodos.un_relleno_de_texto(fecha.getDate(), 2, \"0\"))\n            .replace(\"HH\", Castelog.metodos.un_relleno_de_texto(fecha.getHours(), 2, \"0\"))\n            .replace(\"mm\", Castelog.metodos.un_relleno_de_texto(fecha.getMinutes(), 2, \"0\"))\n            .replace(\"ss\", Castelog.metodos.un_relleno_de_texto(fecha.getSeconds(), 2, \"0\"))\n            .replace(\"xxx\", Castelog.metodos.un_relleno_de_texto(fecha.getMilliseconds(), 3, \"0\"));\n    } else if(direccion === \"un formateo de texto a fecha\") {\n        if (typeof formato !== \"string\") {\n            throw new Error(\"Required parameter «formato» to be a string while «direccion» is «un formateo de texto a fecha» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(formato.length > maxLength) {\n            throw new Error(\"Required parameter «formato» to be greater than «\" + maxLength + \"» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(formato.length < minLength) {\n            throw new Error(\"Required parameter «formato» to be greater than «\" + minLength + \"» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if (typeof fecha !== \"string\") {\n            throw new Error(\"Required parameter «fecha» to be a string while «direccion» is «un formateo de texto a fecha» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        if(fecha.length < minLength) {\n            throw new Error(\"Required parameter «fecha» to be greater than «\" + minLength + \"» in order to «Castelog.metodos.un_formateo_de_fecha»\");\n        }\n        let nueva_fecha = new Date();\n        nueva_fecha.setHours(0);\n        nueva_fecha.setMinutes(0);\n        nueva_fecha.setSeconds(0);\n        nueva_fecha.setMilliseconds(0);\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"YYYY\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 4);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setFullYear(date_part_int);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"MM\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 2);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setMonth(date_part_int - 1);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"DD\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 2);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setDate(date_part_int);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"HH\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 2);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setHours(date_part_int);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"mm\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 2);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setMinutes(date_part_int);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"ss\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 2);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setSeconds(date_part_int);\n        }\n        ExtractingDatePart: {\n            const matchedPosition = formato.indexOf(\"xxx\");\n            if(matchedPosition === -1) break ExtractingDatePart;\n            const date_part = fecha.substring(matchedPosition, matchedPosition + 3);\n            const date_part_int = parseInt(date_part);\n            if(date_part) nueva_fecha.setMilliseconds(date_part_int);\n        }\n        return nueva_fecha;\n\n    }\n};\n\n//Included:lib/564.castelog.v1.metodos.un_relleno_de_texto.js\nCastelog.metodos.un_relleno_de_texto = function(texto, longitud = 2, relleno = \"0\", por_el_principio = true) {\n    if(typeof longitud !== \"number\") {\n        throw new Error(\"Required parameter «longitud» to be a number in order to «Castelog.metodos.un_relleno_de_texto»\");\n    }\n    if(typeof relleno !== \"string\") {\n        throw new Error(\"Required parameter «relleno» to be a string in order to «Castelog.metodos.un_relleno_de_texto»\");\n    }\n    let salida = \"\" + texto;\n    while(salida.length < longitud) {\n        if(por_el_principio) {\n            salida = relleno + salida;\n        } else {\n            salida = salida + relleno;\n        }\n    }\n    return salida;\n};\n\n//Included:lib/565.castelog.v1.metodos.un_dia_de_la_semana.js\nCastelog.metodos.un_dia_de_la_semana = function(base) {\n    if(typeof base === \"string\") {\n        const baseLower = base.toLowerCase();\n        if (baseLower === \"lunes\") { return 1 }\n        else if (baseLower === \"martes\") { return 2 }\n        else if (baseLower === \"miércoles\") { return 3 }\n        else if (baseLower === \"jueves\") { return 4 }\n        else if (baseLower === \"viernes\") { return 5 }\n        else if (baseLower === \"sábado\") { return 6 }\n        else if (baseLower === \"domingo\") { return 0 }\n        else throw new Error(\"Required parameter «base» to be a valid week day when string in order to «Castelog.metodos.un_dia_de_la_semana»\");\n    }\n    if(base instanceof Date) {\n        base = base.getDay();\n    }\n    if(typeof base === \"number\") {\n        if (base === 0) { return \"Domingo\" }\n        else if (base === 1) { return \"Lunes\" }\n        else if (base === 2) { return \"Martes\" }\n        else if (base === 3) { return \"Miércoles\" }\n        else if (base === 4) { return \"Jueves\" }\n        else if (base === 5) { return \"Viernes\" }\n        else if (base === 6) { return \"Sábado\" }\n        else throw new Error(\"Required parameter «base» to be a valid number when number in order to «Castelog.metodos.un_dia_de_la_semana»\");\n    }\n    throw new Error(\"Required parameter «base» to be a valid type (string, number or date) in order to «Castelog.metodos.un_dia_de_la_semana»\");\n};\n\n//Included:lib/566.castelog.v1.metodos.un_nombre_de_mes.js\nCastelog.metodos.un_nombre_de_mes = function(base) {\n    let mes = base;\n    if(base instanceof Date) {\n        mes = base.getMonth();\n    }\n    if(typeof base === \"number\") {\n        mes = base;\n    }\n    if(typeof base === \"string\") {\n        mes = parseInt(base);\n    }\n    if(typeof mes !== \"number\") {\n        throw new Error(\"Required parameter «base» to be an instance of Date, a string or a number in order to «Castelog.metodos.un_nombre_de_mes»\");\n    }\n    if(mes === 0) return \"Enero\";\n    if(mes === 1) return \"Febrero\";\n    if(mes === 2) return \"Marzo\";\n    if(mes === 3) return \"Abril\";\n    if(mes === 4) return \"Mayo\";\n    if(mes === 5) return \"Junio\";\n    if(mes === 6) return \"Julio\";\n    if(mes === 7) return \"Agosto\";\n    if(mes === 8) return \"Setiembre\";\n    if(mes === 9) return \"Octubre\";\n    if(mes === 10) return \"Noviembre\";\n    if(mes === 11) return \"Diciembre\";\n    throw new Error(\"Required parameter «base» to be a number between 1 and 11 in order to «Castelog.metodos.un_nombre_de_mes»\");\n};\n\n//Included:lib/567.castelog.v1.metodos.una_comunicacion_de_entrada_de_usuario.js\nCastelog.metodos.una_comunicacion_de_entrada_de_usuario = function (componente, atributos = {}, eventos = {}) {\n    if(typeof Vue === \"undefined\") {\n        throw new Error(\"Required global «Vue» to be defined in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    if(typeof Vue.prototype === \"undefined\") {\n        throw new Error(\"Required global «Vue.prototype» to be defined in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    if(typeof Vue.prototype.$comunicaciones.una_entrada_de_usuario === \"undefined\") {\n        throw new Error(\"Required global «Vue.prototype.una_comunicacion_de_entrada_de_usuario» to be defined in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    if(typeof componente !== \"string\") {\n        throw new Error(\"Required argument «componente» to be a string in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    if(typeof atributos !== \"object\") {\n        throw new Error(\"Required argument «atributos» to be a object in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    if(typeof eventos !== \"object\") {\n        throw new Error(\"Required argument «eventos» to be a object in order to «Castelog.metodos.una_comunicacion_de_entrada_de_usuario»\");\n    }\n    return Vue.prototype.$comunicaciones.una_entrada_de_usuario(componente, atributos, eventos);\n};\n\n//Included:lib/568.castelog.v1.metodos.una_comunicacion_de_salida_a_usuario.js\nCastelog.metodos.una_comunicacion_de_salida_a_usuario = function (componente, atributos = {}, eventos = {}) {\n    if(typeof Vue === \"undefined\") {\n        throw new Error(\"Required global «Vue» to be defined in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    if(typeof Vue.prototype === \"undefined\") {\n        throw new Error(\"Required global «Vue.prototype» to be defined in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    if(typeof Vue.prototype.$comunicaciones.una_salida_a_usuario === \"undefined\") {\n        throw new Error(\"Required global «Vue.prototype.una_comunicacion_de_salida_a_usuario» to be defined in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    if(typeof componente !== \"string\") {\n        throw new Error(\"Required argument «componente» to be a string in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    if(typeof atributos !== \"object\") {\n        throw new Error(\"Required argument «atributos» to be a object in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    if(typeof eventos !== \"object\") {\n        throw new Error(\"Required argument «eventos» to be a object in order to «Castelog.metodos.una_comunicacion_de_salida_a_usuario»\");\n    }\n    return Vue.prototype.$comunicaciones.una_salida_a_usuario(componente, atributos, eventos);\n};\n\n//Included:lib/569.castelog.v1.metodos.un_proxy.js\nCastelog.metodos.un_proxy = function(obj, proxifiers = {}) {\n    if(typeof Proxy === \"undefined\") {\n        throw new Error(\"Required global «Proxy» to not be undefined in order to «Castelog.metodos.un_proxy»\");\n    }\n    return new Proxy(obj, proxifiers);\n};\n\n//Included:lib/570.castelog.v1.metodos.una_proxificacion.js\nCastelog.metodos.una_proxificacion = function(...args) {\n    return new Castelog.variables.Proxificacion(...args);\n};\n\nCastelog.metodos.un_resultado_de_proxificacion = function (...args) {\n    return new Castelog.variables.Resultado_de_proxificacion(...args);\n};\n\nCastelog.variables.Resultado_de_proxificacion = class {\n    static factoria(dato) {\n        return new this(dato);\n    }\n    constructor(resultado) {\n        this.resultado = resultado;\n    }\n};\n\nCastelog.variables.Proxificacion = class {\n    static get Resultado_de_proxificacion() {\n        return Castelog.variables.Resultado_de_proxificacion;\n    }\n    constructor(dato_original) {\n        let proxy = undefined, dato = dato_original;\n        if (typeof dato_original === \"function\") {\n            proxy = Castelog.variables.Proxificacion.obtener_proxy_de_funcion(dato);\n        } else if (typeof dato_original === \"object\") {\n            proxy = Castelog.variables.Proxificacion.obtener_proxy_de_objeto(dato);\n        } else {\n            throw new Error(\"Required parameter «dato_original» to be object or function in order to «Proxificacion.constructor»\");\n        }\n        return proxy;\n    }\n    static comprobar_tipo_de_evento(evento, dato) {\n        if ((typeof evento !== \"string\") || ([\"get\", \"set\", \"call\"].indexOf(evento) === -1)) {\n            throw new Error(\"Required parameter «evento» to be a string and a known event type in order to «Proxificacion.comprobar_tipo_de_evento»\");\n        }\n        return true;\n    }\n    static comprobar_accion_o_dato_de_accion(accion, dato) {\n        if(typeof accion === \"function\") {\n            return true;\n        } else if((typeof accion === \"object\") && Array.isArray(accion) && (accion.length > 0)) {\n            return true;\n        }\n        throw new Error(\"Required parameter «accion» to be a function or an array of more than 0 items in order to «Proxificacion.comprobar_accion_o_dato_de_accion»\");\n    }\n    static comprobar_accion(accion, dato) {\n        if (typeof accion !== \"function\") {\n            throw new Error(\"Required parameter «accion» to be a function in order to «Proxificacion.comprobar_accion»\");\n        }\n        return true;\n    }\n    static comprobar_configuracion(configuracion, dato) {\n        if (typeof configuracion !== \"object\") {\n            throw new Error(\"Required parameter «configuracion» to be an object in order to «Proxificacion.comprobar_configuracion»\");\n        }\n        return true;\n    }\n    static extender_con_proxy_api(dato) {\n        dato.$proxy_api = {\n            debug: false,\n            eventos: {\n                para: {\n                    get: [],\n                    set: [],\n                    call: [],\n                }\n            },\n            seleccionar: function (tipo_de_evento, filtro) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion(filtro);\n                return dato.$proxy.eventos.para[tipo_de_evento].filter(filtro);\n            },\n            insertar: function (tipo_de_evento, accion, configuracion = {}) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion(accion);\n                Castelog.variables.Proxificacion.comprobar_configuracion(configuracion);\n                const datos_de_evento = [accion, configuracion];\n                dato.$proxy_api.eventos.para[tipo_de_evento].push(datos_de_evento);\n                return datos_de_evento;\n            },\n            eliminar: function (tipo_de_evento, accion) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion_o_dato_de_accion(accion);\n                const checker = (typeof accion === \"function\") ? evento => evento[0] === accion : evento => evento === accion;\n                const evento = dato.$proxy_api.eventos.para[tipo_de_evento].filter(checker);\n                if (typeof evento === \"undefined\") {\n                    throw new Error(`Required parameter «accion» to be known as an event function by «${tipo_de_evento}» in order to «proxificacion.$proxy_api.eliminar»`)\n                }\n                return dato.$proxy_api.eventos.para[tipo_de_evento].splice(\n                    0 + dato.$proxy_api.eventos.para[tipo_de_evento].indexOf(evento),\n                    1\n                );\n            },\n            actualizar: function (tipo_de_evento, accion, nueva_accion, nueva_configuracion = {}) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion_o_dato_de_accion(accion);\n                Castelog.variables.Proxificacion.comprobar_accion(nueva_accion);\n                const checker = (typeof accion === \"function\") ? evento => evento[0] === accion : evento => evento === accion;\n                const evento = dato.$proxy_api.eventos.para[tipo_de_evento].filter(checker);\n                if (typeof evento === \"undefined\") {\n                    throw new Error(`Required parameter «accion» to be known as an event function by «${tipo_de_evento}» in order to «proxificacion.$proxy_api.actualizar»`)\n                }\n                return dato.$proxy_api.eventos.para[tipo_de_evento].splice(\n                    0 + dato.$proxy_api.eventos.para[tipo_de_evento].indexOf(evento),\n                    1,\n                    [nueva_accion, nueva_configuracion]\n                );\n            },\n            apendizar: function (tipo_de_evento, accion, nueva_accion, nueva_configuracion = {}) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion_o_dato_de_accion(accion);\n                Castelog.variables.Proxificacion.comprobar_accion(nueva_accion);\n                const checker = (typeof accion === \"function\") ? evento => evento[0] === accion : evento => evento === accion;\n                const evento = dato.$proxy_api.eventos.para[tipo_de_evento].filter(checker);\n                if (typeof evento === \"undefined\") {\n                    throw new Error(`Required parameter «accion» to be known as an event function by «${tipo_de_evento}» in order to «proxificacion.$proxy_api.apendizar»`)\n                }\n                return dato.$proxy_api.eventos.para[tipo_de_evento].splice(\n                    0 + dato.$proxy_api.eventos.para[tipo_de_evento].indexOf(evento),\n                    0,\n                    [nueva_accion, nueva_configuracion]\n                );\n            },\n            prependizar: function (tipo_de_evento, accion, nueva_accion, nueva_configuracion = {}) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                Castelog.variables.Proxificacion.comprobar_accion_o_dato_de_accion(accion);\n                Castelog.variables.Proxificacion.comprobar_accion(nueva_accion);\n                const checker = (typeof accion === \"function\") ? evento => evento[0] === accion : evento => evento === accion;\n                const evento = dato.$proxy_api.eventos.para[tipo_de_evento].filter(checker);\n                if (typeof evento === \"undefined\") {\n                    throw new Error(`Required parameter «accion» to be known as an event function by «${tipo_de_evento}» in order to «proxificacion.$proxy_api.prependizar»`)\n                }\n                return dato.$proxy_api.eventos.para[tipo_de_evento].splice(\n                    1 + dato.$proxy_api.eventos.para[tipo_de_evento].indexOf(evento),\n                    0,\n                    [nueva_accion, nueva_configuracion]\n                );\n            },\n            ejecutar: function (tipo_de_evento, parametros_de_proxificacion) {\n                Castelog.variables.Proxificacion.comprobar_tipo_de_evento(tipo_de_evento);\n                const [externo, clave, valor] = parametros_de_proxificacion;\n                if ((typeof clave === \"string\") && clave.startsWith(\"$\")) {\n                    if (tipo_de_evento === \"get\") {\n                        return externo[clave];\n                    } else if (tipo_de_evento === \"set\") {\n                        return externo[clave] = valor;\n                    } else if (tipo_de_evento === \"call\") {\n                        return externo(...clave);\n                    }\n                }\n                if(tipo_de_evento === \"get\") {\n                    if((typeof clave === \"string\") && (clave === \"toJSON\")) {\n                        return (...args) => JSON.stringify(externo, args[0] ? args[0] : null, args[1] ? args[1] : 2);\n                    } else if ((typeof clave === \"string\") && (clave === \"toString\")) {\n                        return () => externo;\n                    }\n                }\n                const eventos = dato.$proxy_api.eventos.para[tipo_de_evento];\n                const resultado = [];\n                for (let index = 0; index < eventos.length; index++) {\n                    const evento = eventos[index];\n                    if(!Array.isArray(evento)) {\n                        console.log(evento);\n                        throw new Error(`Required configuration «proxificacion.$proxy_api.eventos.para.${ tipo_de_evento }» or simply «eventos» on index «${ index }» to be an array in order to «proxificacion.$proxy_api.ejecutar»`);\n                    }\n                    const [accion, parametros_de_accion] = evento;\n                    Castelog.variables.Proxificacion.comprobar_accion(accion);\n                    const salida = accion.call(externo, tipo_de_evento === \"call\" ? {\n                        ambito: externo,\n                        configuraciones: parametros_de_proxificacion,\n                        dato: parametros_de_proxificacion[0],\n                        clave: undefined,\n                        valor: undefined,\n                        parametros: parametros_de_accion,\n                        hecho: Castelog.variables.Proxificacion.Resultado_de_proxificacion.factoria,\n                        argumentos: parametros_de_proxificacion[1]\n                    } : {\n                        ambito: externo,\n                        configuraciones: parametros_de_proxificacion,\n                        dato: parametros_de_proxificacion[0],\n                        clave: parametros_de_proxificacion[1],\n                        valor: parametros_de_proxificacion[2],\n                        parametros: parametros_de_accion,\n                            hecho: Castelog.variables.Proxificacion.Resultado_de_proxificacion.factoria\n                    });\n                    if (salida instanceof Castelog.variables.Proxificacion.Resultado_de_proxificacion) {\n                        return salida.resultado;\n                    }\n                    resultado.push(salida);\n                }\n                return resultado;\n            }\n        };\n        return dato;\n    }\n    static obtener_proxy_de_objeto(dato) {\n        this.extender_con_proxy_api(dato);\n        return new Proxy(dato, {\n            get: function (externo, clave) {\n                if (typeof externo.$proxy_api.debug === \"function\") {\n                    externo.$proxy_api.debug(\"[DEBUG][PROXY][GETTER] Property: \" + clave);\n                }\n                return dato.$proxy_api.ejecutar(\"get\", [externo, clave]);\n            },\n            set: function (externo, clave, valor) {\n                if (typeof externo.$proxy_api.debug === \"function\") {\n                    externo.$proxy_api.debug(\"[DEBUG][PROXY][SETTER] Property: \" + clave);\n                }\n                return dato.$proxy_api.ejecutar(\"set\", [externo, clave, valor]);\n            },\n        })\n    }\n    static obtener_proxy_de_funcion(dato) {\n        this.extender_con_proxy_api(dato);\n        return new Proxy(dato, {\n            apply: function (externo, proxificado, argumentos) {\n                if (typeof externo.$proxy_api.debug === \"function\") {\n                    externo.$proxy_api.debug(\"[DEBUG][PROXY][CALLER] Arguments: \" + argumentos.length + (argumentos.length ? \" (\" + argumentos.map(arg => typeof arg) + \")\" : \"\"));\n                }\n                return dato.$proxy_api.ejecutar(\"call\", [externo, argumentos]);\n            },\n        })\n    }\n};\n\nCastelog.variables.tipos_de_proxificacion_disponibles = [\n    \"accede a propiedad\",\n    \"accede a cualquier propiedad\",\n    \"asigna propiedad\",\n    \"asigna cualquier propiedad\",\n    \"se llama\",\n];\n\nCastelog.metodos.siempre_que_proxificacion = function(proxificacion, tipo, ...otros) {\n    if(!(\"$proxy_api\" in proxificacion)) {\n        throw new Error(\"Required argument «proxificacion» to be an instance of «Castelog.variables.Proxificacion» in order to «Castelog.metodos.siempre_que_proxificacion»\");\n    }\n    if(typeof tipo !== \"string\") {\n        throw new Error(\"Required argument «tipo» to be a string in order to «Castelog.metodos.siempre_que_proxificacion»\");\n    }\n    if(Castelog.variables.tipos_de_proxificacion_disponibles.indexOf(tipo) === -1) {\n        throw new Error(\"Required argument «tipo» to be a valid string in order to «Castelog.metodos.siempre_que_proxificacion»\");\n    }\n    if(otros.length === 0) {\n        throw new Error(\"Required argument «otros» to have 1 or more items in order to «Castelog.metodos.siempre_que_proxificacion»\");\n    }\n    if(tipo === \"accede a propiedad\") {\n        const [ propiedad, evento ] = otros;\n        if(typeof propiedad !== \"string\") {\n            throw new Error(\"Required argument «propiedad» to be a string in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n        if (typeof evento !== \"function\") {\n            throw new Error(\"Required argument «evento» to be a function in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n        return proxificacion.$proxy_api.insertar(\"get\", function(parametros) {\n            const { dato, clave } = parametros;\n            if(clave === propiedad) {\n                return evento(parametros);\n            }\n        }, {});\n    } else if (tipo === \"accede a cualquier propiedad\") {\n        const [evento] = otros;\n        if (typeof evento === \"function\") {\n            return proxificacion.$proxy_api.insertar(\"get\", function (parametros) {\n                return evento(parametros);\n            }, {});\n        } else if(typeof evento === \"object\") {\n            if(Array.isArray(evento.deja_de) && (evento.deja_de.length > 0) && (evento.deja_de[0] === \"function\")) {\n                throw new Error(\"Required argument «evento.deja_de» to be a function on «accede a cualquier propiedad» in order to «Castelog.metodos.siempre_que_proxificacion»\");\n            }\n            const { deja_de, en_su_lugar = null } = evento;\n            if(en_su_lugar === null) {\n                return proxificacion.$proxy_api.eliminar(\"get\", deja_de[0]);\n            } else if(typeof en_su_lugar === \"function\") {\n                return proxificacion.$proxy_api.actualizar(\"get\", deja_de[0], en_su_lugar);\n            } else {\n                throw new Error(\"Required argument «evento.en_su_lugar» to be a function or null on «accede a cualquier propiedad» in order to «Castelog.metodos.siempre_que_proxificacion»\");\n            }\n        } else {\n            throw new Error(\"Required argument «evento» to be a function or an object on «accede a cualquier propiedad» in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n    } else if (tipo === \"asigna propiedad\") {\n        const [propiedad, evento] = otros;\n        if (typeof propiedad !== \"string\") {\n            throw new Error(\"Required argument «propiedad» to be a string in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n        if (typeof evento !== \"function\") {\n            throw new Error(\"Required argument «evento» to be a function in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n        return proxificacion.$proxy_api.insertar(\"set\", function (parametros) {\n            const { dato, clave } = parametros;\n            if (clave === propiedad) {\n                return evento(parametros);\n            }\n        }, {});\n    } else if (tipo === \"asigna cualquier propiedad\") {\n        const [evento] = otros;\n        if (typeof evento === \"function\") {\n            return proxificacion.$proxy_api.insertar(\"set\", function (parametros) {\n                return evento(parametros);\n            }, {});\n        } else if (typeof evento === \"object\") {\n            if(Array.isArray(evento.deja_de) && (evento.deja_de.length > 0) && (evento.deja_de[0] === \"function\")) {\n                throw new Error(\"Required argument «evento.deja_de» to be a function on «asigna cualquier propiedad» in order to «Castelog.metodos.siempre_que_proxificacion»\");\n            }\n            const { deja_de, en_su_lugar = null } = evento;\n            if (en_su_lugar === null) {\n                return proxificacion.$proxy_api.eliminar(\"set\", deja_de[0]);\n            } else if (typeof en_su_lugar === \"function\") {\n                return proxificacion.$proxy_api.actualizar(\"set\", deja_de[0], en_su_lugar);\n            } else {\n                throw new Error(\"Required argument «evento.en_su_lugar» to be a function or null on «asigna cualquier propiedad» in order to «Castelog.metodos.siempre_que_proxificacion»\");\n            }\n        } else {\n            throw new Error(\"Required argument «evento» to be a function or an object on «asigna cualquier propiedad» in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n    } else if (tipo === \"se llama\") {\n        const [evento] = otros;\n        if (typeof evento !== \"function\") {\n            throw new Error(\"Required argument «evento» to be a function in order to Castelog.metodos.siempre_que_proxificacion»\");\n        }\n        return proxificacion.$proxy_api.insertar(\"call\", function (parametros) {\n            return evento(parametros);\n        }, {});\n    } else {\n        throw new Error(\"Required argument «tipo» to be a valid string in order to «Castelog.metodos.siempre_que_proxificacion»\")\n    }\n};\n\n//Included:lib/571.castelog.v1.metodos.una_observacion_fenomenica.js\nCastelog.metodos.una_observacion_de_fenomenos = function(factoria, base = {}) {\n    if(typeof factoria !== \"function\") {\n        throw new Error(\"Required argument «factoria» to be a function in order to «Castelog.metodos.una_observacion_de_fenomenos»\")\n    }\n    return function(configuraciones = {}) {\n        if (typeof configuraciones !== \"object\") {\n            throw new Error(\"Required argument «configuraciones» to be an object in order to «Castelog.metodos.una_observacion_de_fenomenos»\")\n        }\n        const observacion = new Castelog.variables.Observacion_de_fenomenos(base, factoria, configuraciones)\n        return observacion;\n    };\n};\n\nCastelog.metodos.una_insercion_de_ley = function(observacion, accion, propiedad, evento) {\n    if (typeof observacion.$fenomenos_api !== \"object\") {\n        throw new Error(\"Required argument «observacion» to be an instance of «Castelog.metodos.una_observacion» in order to «Castelog.metodos.una_insercion_de_ley»\");\n    }\n    if (typeof accion !== \"string\") {\n        throw new Error(\"Required argument «accion» to be a string in order to «Castelog.metodos.una_insercion_de_ley»\");\n    }\n    if ((typeof propiedad !== \"string\") && (propiedad !== null)) {\n        throw new Error(\"Required argument «propiedad» to be a string in order to «Castelog.metodos.una_insercion_de_ley»\");\n    }\n    if (typeof evento !== \"function\") {\n        throw new Error(\"Required argument «evento» to be a function in order to «Castelog.metodos.una_insercion_de_ley»\");\n    }\n    return observacion.$fenomenos_api.leyes.insertar(accion, propiedad, evento);\n};\n\nCastelog.metodos.una_actualizacion_de_ley = function (observacion, accion, propiedad, evento) {\n    if (typeof observacion.$fenomenos_api !== \"object\") {\n        throw new Error(\"Required argument «observacion» to be an instance of «Castelog.metodos.una_observacion» in order to «Castelog.metodos.una_actualizacion_de_ley»\");\n    }\n    if (typeof accion !== \"string\") {\n        throw new Error(\"Required argument «accion» to be a string in order to «Castelog.metodos.una_actualizacion_de_ley»\");\n    }\n    if ((typeof propiedad !== \"string\") && (propiedad !== null)) {\n        throw new Error(\"Required argument «propiedad» to be a string in order to «Castelog.metodos.una_actualizacion_de_ley»\");\n    }\n    if (typeof evento !== \"function\") {\n        throw new Error(\"Required argument «evento» to be a function in order to «Castelog.metodos.una_actualizacion_de_ley»\");\n    }\n    return observacion.$fenomenos_api.leyes.actualizar(accion, propiedad, evento);\n};\n\nCastelog.metodos.una_eliminacion_de_ley = function (observacion, accion, propiedad, evento) {\n    if (typeof observacion.$fenomenos_api !== \"object\") {\n        throw new Error(\"Required argument «observacion» to be an instance of «Castelog.metodos.una_observacion» in order to «Castelog.metodos.una_eliminacion_de_ley»\");\n    }\n    if (typeof accion !== \"string\") {\n        throw new Error(\"Required argument «accion» to be a string in order to «Castelog.metodos.una_eliminacion_de_ley»\");\n    }\n    if ((typeof propiedad !== \"string\") && (propiedad !== null)) {\n        throw new Error(\"Required argument «propiedad» to be a string in order to «Castelog.metodos.una_eliminacion_de_ley»\");\n    }\n    if (typeof evento !== \"function\") {\n        throw new Error(\"Required argument «evento» to be a function in order to «Castelog.metodos.una_eliminacion_de_ley»\");\n    }\n    return observacion.$fenomenos_api.leyes.eliminar(accion, propiedad, evento);\n};\n\nCastelog.metodos.una_inicializacion_de_fenomeno = function (observacion, nombre, valor) {\n    return observacion.$fenomenos_api.inicializar(nombre, valor);\n};\n\nCastelog.metodos.una_actualizacion_de_fenomeno = function (observacion, nombre, valor) {\n    return observacion.$fenomenos_api.actualizar(nombre, valor);\n};\n\nCastelog.metodos.una_eliminacion_de_fenomeno = function (observacion, nombre) {\n    return observacion.$fenomenos_api.eliminar(nombre);\n};\n\nCastelog.variables.Observacion_de_fenomenos = class {\n    static extender_con_fenomenos_api(proxy) {\n        proxy.$fenomenos_api = {\n            leyes: {\n                insertar: function(tipo_de_evento, propiedad, consecuencia) {\n                    return proxy.$proxy_api.insertar(tipo_de_evento, ...propiedad ? [propiedad, consecuencia] : [consecuencia]);\n                },\n                actualizar: function (tipo_de_evento, consecuencia_anterior, consecuencia_nueva) {\n                    return proxy.$proxy_api.actualizar(tipo_de_evento, consecuencia_anterior, consecuencia_nueva);\n                },\n                eliminar: function(tipo_de_evento, consecuencia_anterior) {\n                    return proxy.$proxy_api.eliminar(tipo_de_evento, consecuencia_anterior);\n                },\n            },\n            inicializar: function (nombre, valor) {\n                if(typeof nombre !== \"string\") {\n                    throw new Error(\"Required argument «nombre» to be a string in order to «proxy.$fenomenos_api.inicializar»\");\n                }\n                if(typeof proxy[nombre] !== \"undefined\") {\n                    throw new Error(`Required phenomena «${ nombre }» to not be defined in order to «$proxy.$fenomenos_api.inicializar»`);\n                }\n                proxy[nombre] = valor;\n                return proxy[nombre];\n            },\n            actualizar: function (nombre, valor) {\n                if(typeof nombre !== \"string\") {\n                    throw new Error(\"Required argument «nombre» to be a string in order to «proxy.$fenomenos_api.actualizar»\");\n                }\n                proxy[nombre] = valor;\n                return proxy[nombre];\n            },\n            eliminar: function (nombre) {\n                if(typeof nombre !== \"string\") {\n                    throw new Error(\"Required argument «nombre» to be a string in order to «proxy.$fenomenos_api.eliminar»\");\n                }\n                delete this[nombre];\n                return proxy[nombre];\n            }\n        };\n    }\n    constructor(dato_original = {}, factoria = false, configuraciones = {}) {\n        const proxy = Castelog.metodos.una_proxificacion(dato_original);\n        Castelog.variables.Observacion_de_fenomenos.extender_con_fenomenos_api(proxy);\n        if(typeof factoria === \"function\") {\n            const resultado = factoria(proxy, configuraciones);\n            if (typeof resultado !== \"undefined\") {\n                return resultado;\n            }\n        } else if(factoria === false) {\n            // OK!\n        } else {\n            throw new Error(\"Required argument «factoria» to be a function or false in order to «Castelog.variables.Observacion_de_fenomenos»\")\n        }\n        return proxy;\n    }\n};\n\nCastelog.metodos.una_casuistica_de_observacion = function(observacion, proxy, configuraciones = {}) {\n    return new observacion(proxy, configuraciones);\n};\n\n//Included:lib/572.castelog.v1.metodos.una_interfaz_vacia.js\nCastelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica = function (base, selectores, base_original, reductor_unico) {\n    if ([\"function\", \"object\"].indexOf(typeof base) === -1) {\n        throw new Error(\"Required argument «base» to be an object or a function in order to «Castelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica»\");\n    }\n    if ([\"function\", \"object\"].indexOf(typeof base_original) === -1) {\n        throw new Error(\"Required argument «base_original» to be an object or a function in order to «Castelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica»\");\n    }\n    if (!Array.isArray(selectores)) {\n        throw new Error(\"Required argument «selectores» to be an array in order to «Castelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica»\");\n    }\n    if (typeof reductor_unico !== \"function\") {\n        throw new Error(\"Required argument «reductor_unico» to be a function in order to «Castelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica»\");\n    }\n    return function (evento) {\n        if (base_original === base) {\n            reductor_unico(evento);\n            return base_original;\n        }\n        return base_original.$(evento);\n    };\n};\n\nCastelog.variables.Interfaz_vacia_basica = function (base = {}, selectores = [], base_original = undefined, reductor_unico = undefined, extensiones = {}) {\n    if ([\"object\", \"function\"].indexOf(typeof base) === -1) {\n        throw new Error(\"Required argument «base» to be an object or a function in order to «Castelog.variables.Interfaz_vacia_basica»\");\n    }\n    if (!Array.isArray(selectores)) {\n        throw new Error(\"Required argument «selectores» to be an array in order to «Castelog.variables.Interfaz_vacia_basica»\");\n    }\n    if ([\"object\", \"function\"].indexOf(typeof base_original) === -1) {\n        throw new Error(\"Required argument «base_original» to be an object or a function in order to «Castelog.variables.Interfaz_vacia_basica»\");\n    }\n    const interfaz_vacia = Castelog.variables.Factory_de_accion_por_defecto_de_interfaz_basica(base, selectores, base_original, reductor_unico);\n    interfaz_vacia.cambiar = interfaz_vacia;\n    interfaz_vacia.Promise = Promise;\n    interfaz_vacia.console = {\n        log: console.log.bind(console)\n    };\n    for (let prop in extensiones) {\n        if ([\"object\", \"function\"].indexOf(extensiones[prop]) === -1) {\n            throw new Error(\"Required argument «extensiones» on index «\" + prop + \"» to be an object or a function in order to «Castelog.variables.Interfaz_vacia_basica»\");\n        }\n        interfaz_vacia[prop] = Castelog.metodos.una_interfaz_vacia(extensiones[prop]);\n    }\n    return interfaz_vacia;\n};\nCastelog.variables.Interfaz_vacia_por_defecto = Castelog.variables.Interfaz_vacia_basica;\nCastelog.metodos.una_interfaz_vacia = function (reductor_unico = Castelog.variables.noop, base = {}, selectores = [], base_original = undefined) {\n    if ([\"function\"].indexOf(typeof reductor_unico) === -1) {\n        throw new Error(\"Required argument «reductor_unico» to be a function in order to «Castelog.metodos.una_interfaz_vacia»\");\n    }\n    if ([\"object\", \"function\"].indexOf(typeof base) === -1) {\n        throw new Error(\"Required argument «base» to be an object or a function in order to «Castelog.metodos.una_interfaz_vacia»\");\n    }\n    if (!Array.isArray(selectores)) {\n        throw new Error(\"Required argument «selectores» to be an array in order to «Castelog.metodos.una_interfaz_vacia»\");\n    }\n    if (typeof base_original === \"undefined\") {\n        base_original = base;\n    }\n    base.$ = Castelog.variables.Interfaz_vacia_por_defecto(base, selectores, base_original, reductor_unico);\n    const reducir_a_jsonable = function (dato) {\n        const claves = Object.keys(dato);\n        const reduccion = claves.reduce((output, item) => {\n            output[item] = dato[item];\n            return output;\n        }, {});\n        return reduccion;\n    };\n    const interfaz_vacia = new Proxy(base, {\n        get: function (dato, clave) {\n            if (clave.startsWith(\"$\")) {\n                return dato[clave];\n            }\n            if (clave === \"toJSON\") {\n                return function (...args) {\n                    return reducir_a_jsonable(base);\n                };\n            }\n            if (!(clave in dato)) {\n                const selector_especifico = [].concat(selectores).concat([clave]);\n                const base = new Function(Castelog.noop);\n                base.referencia = selector_especifico;\n                dato[clave] = Castelog.metodos.una_interfaz_vacia(\n                    reductor_unico,\n                    base,\n                    selector_especifico,\n                    base_original\n                );\n            }\n            return dato[clave];\n        },\n        set: function (dato, clave, valor) {\n            if (clave.startsWith(\"$\")) {\n                return dato[clave] = valor;\n            }\n            return dato[clave] = valor;\n        },\n        apply: function (externo, proxificado, argumentos) {\n            const resultado = base_original.$({\n                original: base_original,\n                selector: selectores,\n                funcion_original: externo,\n                funcion_proxificada: interfaz_vacia,\n                argumentos,\n                accion: \"/\" + selectores.join(\"/\"),\n                parametro: argumentos[0],\n            });\n            return interfaz_vacia;\n        }\n    });\n    for(let prop in base) {\n        interfaz_vacia[prop] = base[prop];\n    }\n    return interfaz_vacia;\n};\n\n//Included:lib/573.castelog.v1.metodos.una_funcion_contextualiazada.js\nCastelog.variables.Polyfill_de_vm_para_navegadores = function() {\n    // https://raw.githubusercontext.com/snanovskyi/vm-browser/master/index.js\n};\n\nCastelog.metodos.una_funcion_contextualizada = function(contexto, funcion, errores = undefined) {\n    if(typeof contexto !== \"object\") {\n        throw new Error(\"Required argument «contexto» to be an object in order to «Castelog.metodos.una_funcion_contextualizada»\");\n    }\n    if(typeof funcion !== \"function\") {\n        throw new Error(\"Required argument «funcion» to be an function in order to «Castelog.metodos.una_funcion_contextualizada»\");\n    }\n    if (typeof errores !== \"function\") {\n        errores = function (error) {\n            console.log(\"Errors arised on «Castelog.metodos.una_funcion_contextualizada». Details:\");\n            console.log(error);\n            throw error;\n        };\n    }\n    if(typeof errores !== \"function\") {\n        throw new Error(\"Required argument «errores» to be an function in order to «Castelog.metodos.una_funcion_contextualizada»\");\n    }\n    if (typeof finalmente !== \"function\") {\n        finalmente = Castelog.variables.noop;\n    }\n    let vm = undefined;\n    if ((typeof global !== \"undefined\") && (typeof require !== \"undefined\")) {\n        vm = require(\"vm\");\n    } else if (typeof window !== \"undefined\") {\n        vm = Castelog.variables.Polyfill_de_vm_para_navegadores();\n    }\n    const funcion_virtual = (...args) => {\n        const contexto_virtual = vm.createContext(Object.assign(contexto, {\n            Castelog,\n            console,\n            $parametros_virtuales: args,\n            $gestor_de_en_errores: errores,\n            $gestor_de_finalmente: finalmente\n        }));\n        const codigo_virtual = `(${funcion.toString()})($gestor_de_en_errores, $gestor_de_finalmente, ...$parametros_virtuales)`;\n        return vm.runInContext(codigo_virtual, contexto_virtual);\n    };\n    return funcion_virtual;\n};\n\n//Included:lib/574.castelog.v1.metodos.una_funcion_literaria.js\nCastelog.metodos.una_funcion_literaria = function (ast_factory, partir = {}, reductor = Castelog.variables.noop, en_errores = undefined) {\n    return Castelog.metodos.una_funcion_contextualizada(\n        Castelog.metodos.una_interfaz_vacia(reductor, partir),\n        ast_factory,\n        en_errores\n    );\n};\n\n//Included:lib/575.castelog.v1.metodos.un_clon_de_proxy.js\nCastelog.metodos.un_clon_de_proxy = function(proxy, extension = {}) {\n    const clon = new Proxy(typeof proxy === \"function\" ? function(){} : {}, {\n        get: function(dato, clave) {\n            if(clave in extension) {\n                return extension[clave];\n            }\n            return proxy[clave];\n        },\n        set: function(dato, clave, valor) {\n            if(clave in extension) {\n                return extension[clave] = valor;\n            }\n            return proxy[clave] = valor;\n        },\n        apply: function(dato, proxified, args) {\n            return proxy(...args);\n        }\n    });\n    return clon;\n};\n\n//Included:lib/576.castelog.v1.metodos.una_funcion_mixta.js\nCastelog.metodos.un_resultado_de_funcion_mixta = function (...args) {\n    return new Castelog.variables.Resultado_de_funcion_mixta(...args);\n};\n\nCastelog.variables.Resultado_de_funcion_mixta = class {\n    static factoria(dato) {\n        return new this(dato);\n    }\n    constructor(resultado) {\n        this.resultado = resultado;\n    }\n};\n\nCastelog.metodos.una_funcion_mixta = function (partir = [], configuraciones = []) {\n    if (!Array.isArray(partir)) {\n        throw new Error(\"Required parameter «partir» to be an array in order to «Castelog.metodos.una_funcion_mixta»\")\n    }\n    if (!Array.isArray(configuraciones)) {\n        throw new Error(\"Required parameter «configuraciones» to be an array in order to «Castelog.metodos.una_funcion_mixta»\")\n    }\n    const partir_copy = [].concat(partir);\n    return function (...parametros) {\n        try {\n            const total = [];\n            for (let index = 0; index < partir_copy.length; index++) {\n                const funcion_parcial = partir_copy[index];\n                (function x(funcion_parcial) {\n                    let resultado_parcial = undefined;\n                    if (typeof funcion_parcial === \"function\") {\n                        resultado_parcial = funcion_parcial(...parametros, configuraciones, total, this, index);\n                    } else {\n                        resultado_parcial = funcion_parcial;\n                    }\n                    if (resultado_parcial instanceof Castelog.variables.Resultado_de_funcion_mixta) {\n                        return resultado_parcial.resultado;\n                    }\n                    total.push(resultado_parcial)\n                })(funcion_parcial);\n            }\n            return total;\n        } catch (error) {\n            console.log(error);\n            throw error;\n        }\n    }\n};\n\n//Included:lib/577.castelog.v1.metodos.una_reduccion_recursiva.js\nCastelog.metodos.una_reduccion_recursiva = function (base, reduccion, inicio = {}) {\n    const claves = Object.keys(base);\n    let salida = inicio;\n    for(let index = 0; index < claves.length; index++) {\n        const clave = claves[index];\n        const valor = base[clave];\n        const salida_intermedia = reduccion(salida, valor, clave, reduccion, index, base);\n        if(typeof salida_intermedia !== \"undefined\") {\n            if(salida_intermedia instanceof Castelog.variables.Resultado_de_reduccion_recursiva) {\n                return salida_intermedia.resultado;\n            }\n            salida = salida_intermedia;\n        }\n    }\n    return salida;\n};\n\nCastelog.variables.Resultado_de_reduccion_recursiva = class {\n    static factoria(dato) {\n        return new this(dato);\n    }\n    constructor(resultado) {\n        this.resultado = resultado;\n    }\n};\n\n//Included:lib/578.castelog.v1.metodos.una_expansion.js\nCastelog.variables.configuraciones_de_expansion_por_defecto = {\n    separador: \"/\"\n};\nCastelog.metodos.una_expansion = function(base = {}, expansor = {}, configuraciones_arg = {}) {\n    const configuraciones = Object.assign({}, Castelog.variables.configuraciones_de_expansion_por_defecto, configuraciones_arg);\n    const { separador } = configuraciones;\n    const expansor_ids = Object.keys(expansor);\n    for(let index_id = 0; index_id < expansor_ids.length; index_id++) {\n        const expansor_id = expansor_ids[index_id];\n        const expansor_valor = expansor[expansor_id];\n        const expansor_partes = expansor_id.split(separador).filter(it => it !== \"\");\n        let pivote = base;\n        for(let index_parte_id = 0; index_parte_id < expansor_partes.length; index_parte_id++) {\n            const expansor_parte = expansor_partes[index_parte_id];\n            if(typeof pivote === \"undefined\") {\n                pivote = {};\n            } else if (typeof pivote === \"boolean\") {\n                pivote = { $valor: pivote };\n            } else if (typeof pivote === \"number\") {\n                pivote = { $valor: pivote };\n            }\n            if(index_parte_id === expansor_partes.length - 1) {\n                pivote[expansor_parte] = expansor_valor;\n            } else {\n                pivote = pivote[expansor_parte];\n            }\n        }\n    }\n    return base;\n}\n\n//Included:lib/600.castelog.v1.componentes_vue2.js\n\nCastelog.variables.tema_de_estilos_en_cascada_nativos = {\n};\nCastelog.variables.estilos_en_cascada_nativos_comunes = {\n};\nCastelog.variables.estilos_en_cascada_nativos_comunes.rasgos = {\n    para: {\n        espaciado_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" padding: 0px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" padding: 3px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" padding: 6px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" padding: 9px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" margin: 3px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" margin: 6px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" margin: 9px; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        bordeado: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" border: 1px solid #333; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        bordeado_rallado: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \" border: 1px dashed #333; \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_horizontal_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 0px;\\n            padding-right: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_horizontal_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 3px;\\n            padding-right: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_horizontal_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 6px;\\n            padding-right: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_horizontal_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 9px;\\n            padding-right: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_horizontal_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 3px;\\n            margin-right: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_horizontal_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 6px;\\n            margin-right: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_horizontal_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 9px;\\n            margin-right: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_vertical_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 0px;\\n            padding-bottom: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_vertical_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 3px;\\n            padding-bottom: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_vertical_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 6px;\\n            padding-bottom: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_vertical_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 9px;\\n            padding-bottom: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_vertical_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 3px;\\n            margin-bottom: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_vertical_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 6px;\\n            margin-bottom: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_vertical_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 9px;\\n            margin-bottom: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_izquierda_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_izquierda_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_izquierda_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_izquierda_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-left: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_izquierda_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_izquierda_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_izquierda_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-left: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_derecha_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-right: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_derecha_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-right: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_derecha_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-right: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_derecha_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-right: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_derecha_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-right: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_derecha_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-right: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_derecha_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-right: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_arriba_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_arriba_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_arriba_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_arriba_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-top: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_arriba_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_arriba_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_arriba_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-top: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_abajo_0: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-bottom: 0px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_abajo_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-bottom: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_abajo_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-bottom: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        espaciado_abajo_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding-bottom: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_abajo_1: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-bottom: 3px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_abajo_2: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-bottom: 6px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        marginado_abajo_3: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            margin-bottom: 9px;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        carta: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding: 5px;\\n            border: 1px solid #CCC;\\n            border-radius: 4pt;\\n            background-color: #EEE;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        })),\n        carta_vacia: Castelog.metodos.una_plantilla(function (config, settings) {\n            let $plantilla = \"\";\n            $plantilla += \"\\n            padding: 5px;\\n            border: 1px solid #CCC;\\n            border-radius: 4pt;\\n            background-color: white;\\n        \";\n            return $plantilla;\n        })(({\n            estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n        }))\n    }\n};\nif ((!(typeof jQuery === 'undefined'))) {\n    jQuery.fn.debugging = function (first,\n        second) {\n            try {\n                console.log(\"[jQuery][DEBUG][SCOPE]\");\n                console.log(this);\n                console.log(\"[jQuery][DEBUG][PARAMETER 1]\");\n                console.log(first);\n                console.log(\"[jQuery][DEBUG][PARAMETER 2]\");\n                console.log(second);\n                return this;\n            } catch (error) {\n                console.log(error);\n                throw error;\n            }\n\n    };\n}\nCastelog.metodos.propagar_cambios_desde_watcher = function (nuevoValor,\n    callback = false) {\n        try {\n            if (((!(typeof this.gestor === 'undefined'))) && (typeof this.propiedad === 'string') && (this.propiedad in this.gestor)) {\n                this.gestor[this.propiedad] = nuevoValor;\n            }\n            if (typeof callback === 'function') {\n                callback(this,\n                    nuevoValor);\n            }\n            this.$forceUpdate(true);\n        } catch (error) {\n            console.log(error);\n            throw error;\n        }\n\n};\nif ((!(typeof window === 'undefined'))) {\n    Castelog.metodos.un_componente_vue2(\"Imagen\", \"<img class=\\\"Imagen\\\" :src=\\\"fuente\\\" />\", function (component) {\n        return {\n            props: {\n                fuente: {\n                    type: String,\n                    required: true\n                }\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"GaleriaDeImagenes\", \"<div class=\\\"GaleriaDeImagenes\\\">\"\n        + \"            <DisposicionLineal>\"\n        + \"                <Item>\"\n        + \"                    <ControlParaBoton v-on:click.native=\\\"() => seleccionar_imagen_anterior()\\\">«</ControlParaBoton>\"\n        + \"                </Item>\"\n        + \"                <Item style=\\\"flex-grow: 1; text-align: center;\\\">{{ internal_imagen_seleccionada in imagenes ? imagenes[internal_imagen_seleccionada] : \\\"Ninguna.\\\" }}</Item>\"\n        + \"                <Item>\"\n        + \"                    <ControlParaBoton v-on:click.native=\\\"() => seleccionar_imagen_siguiente()\\\">»</ControlParaBoton>\"\n        + \"                </Item>\"\n        + \"            </DisposicionLineal>\"\n        + \"            <div v-for=\\\"(imagen, imagenIndex) in internal_imagenes\\\" v-bind:key=\\\"'galeria-de-imagenes-' + uuid + '-imagen-' + imagenIndex\\\">\"\n        + \"                <template v-if=\\\"internal_imagen_seleccionada === imagenIndex\\\">\"\n        + \"                    <Imagen :fuente=\\\"imagen\\\" style=\\\"max-width: 100%;\\\" />\"\n        + \"                </template>\"\n        + \"            </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    imagenes: {\n                        type: Array,\n                        default: function () {\n                            try {\n                                return [];\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            internal_imagen_seleccionada: 0 - 1,\n                            internal_imagenes: this.imagenes\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    establecer_imagenes: function (imagenes) {\n                        try {\n                            this.internal_imagenes = imagenes;\n                            this.$forceUpdate(true);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    seleccionar_imagen_anterior: function () {\n                        try {\n                            console.log(\"OK!!\");\n                            this.internal_imagen_seleccionada -= 1;\n                            this.$forceUpdate(true);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    seleccionar_imagen_siguiente: function () {\n                        try {\n                            console.log(\"OK!\");\n                            this.internal_imagen_seleccionada += 1;\n                            this.$forceUpdate(true);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"SoloProyector\", \"<div class=\\\"SoloProyector\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"SoloTelevision\", \"<div class=\\\"SoloTelevision\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"SoloOrdenador\", \"<div class=\\\"SoloOrdenador\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"SoloTablet\", \"<div class=\\\"SoloTablet\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"SoloMovil\", \"<div class=\\\"SoloMovil\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"SoloReloj\", \"<div class=\\\"SoloReloj\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"Paragrafo\", \"<p class=\\\"Paragrafo\\\"><slot></slot></p>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"Pestanyas\", \"<div class=\\\"Pestanyas\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"BotonDePestanya\", \"<div class=\\\"BotonDePestanya\\\" :data-identificador-de-grupo=\\\"grupo\\\" :data-identificador-de-pestanya=\\\"identificador\\\">\"\n        + \"            <div class=\\\"Pestanya\\\" v-on:click=\\\"internal_al_clicar\\\">\"\n        + \"                <slot></slot>\"\n        + \"            </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    identificador: {\n                        type: String,\n                        required: true\n                    },\n                    grupo: {\n                        type: String,\n                        required: true\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            internal_al_clicar: () => {\n                                try {\n                                    const jThis = Castelog.metodos.un_elemento_jquery((this.$el));\n                                    const jPestanyaDestino = jThis.closest(\".BotonDePestanya\");\n                                    const jPestanyasDeGrupo = jThis.closest(\".Pestanyas\").find(\".BotonDePestanya\").filter((index,\n                                        elemento) => {\n                                            try {\n                                                return elemento.getAttribute(\"data-identificador-de-grupo\") === this.grupo;\n                                            } catch (error) {\n                                                console.log(error);\n                                                throw error;\n                                            }\n\n                                    }).removeClass(\"seleccionado\");\n                                    const jPanelDestino = jThis.closest(\".Pestanyas\").find(\".PanelDePestanya\").filter((index,\n                                        elemento) => {\n                                            try {\n                                                return elemento.getAttribute(\"data-identificador-de-grupo\") === this.grupo;\n                                            } catch (error) {\n                                                console.log(error);\n                                                throw error;\n                                            }\n\n                                    }).removeClass(\"seleccionado\").filter((index,\n                                        elemento) => {\n                                            try {\n                                                return elemento.getAttribute(\"data-identificador-de-pestanya\") === this.identificador;\n                                            } catch (error) {\n                                                console.log(error);\n                                                throw error;\n                                            }\n\n                                    }).addClass(\"seleccionado\");\n                                    jPestanyaDestino.addClass(\"seleccionado\");\n                                } catch (error) {\n                                    console.log(error);\n                                    throw error;\n                                }\n\n                            }\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"PanelDePestanya\", \"<div class=\\\"PanelDePestanya\\\"\"\n        + \"        :data-identificador-de-grupo=\\\"grupo\\\"\"\n        + \"        :data-identificador-de-pestanya=\\\"identificador\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    identificador: {\n                        type: String,\n                        required: true\n                    },\n                    grupo: {\n                        type: String,\n                        required: true\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia1\", \"<h1 class=\\\"TituloDeImportancia1\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h1>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia2\", \"<h2 class=\\\"TituloDeImportancia2\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h2>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia3\", \"<h3 class=\\\"TituloDeImportancia3\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h3>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia4\", \"<h4 class=\\\"TituloDeImportancia4\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h4>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia5\", \"<h5 class=\\\"TituloDeImportancia5\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h5>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"TituloDeImportancia6\", \"<h6 class=\\\"TituloDeImportancia6\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </h6>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"Texto\", \"<div class=\\\"Texto\\\"><slot></slot></div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaBoton\", \"<button class=\\\"ControlParaBoton\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </button>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaDia\", \"<ControlParaMomento ref=\\\"control_proxificado\\\" :valor-inicial=\\\"valorInicial\\\" modo=\\\"solo dia\\\" :gestor=\\\"gestor\\\" :propiedad=\\\"propiedad\\\"></ControlParaMomento>\", function (component) {\n        return {\n            props: {\n                valorInicial: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return Castelog.metodos.un_formateo_de_fecha(new Date(), null, \"un formateo de fecha a texto\");\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaHora\", \"<ControlParaMomento ref=\\\"control_proxificado\\\" :valor-inicial=\\\"valorInicial\\\" modo=\\\"solo hora\\\" :gestor=\\\"gestor\\\" :propiedad=\\\"propiedad\\\"></ControlParaMomento>\", function (component) {\n        return {\n            props: {\n                valorInicial: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return Castelog.metodos.un_formateo_de_fecha(new Date(), null, \"un formateo de fecha a texto\");\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaMomento\", \"<div class=\\\"ControlParaMomento carta Control\\\">\"\n        + \"            <input class=\\\"PuntoDeControl\\\" type=\\\"hidden\\\" v-model=\\\"internal_value\\\" />\"\n        + \"            <template v-if=\\\"(modo === 'solo dia') || (modo === 'normal')\\\">\"\n        + \"                <DisposicionCuadricular v-if=\\\"internal_value_date\\\" class=\\\"cuadricula_para_panel_de_control_de_anyo_a_dia\\\">\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Año:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_anyo_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_anyo_anterior\\\"> « </ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getFullYear(), 4, \\\"0\\\") }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_anyo_siguiente\\\"> » </ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Mes:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_mes_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_mes_anterior\\\"> « </ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha no_contraer_texto\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getMonth() + 1, 2, \\\"0\\\") }} | {{ $Castelog.metodos.un_nombre_de_mes(internal_value_date.getMonth()) }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_mes_siguiente\\\"> » </ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2 no_contraer_texto\\\">Día:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_dia_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_dia_anterior\\\"> « </ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getDate(), 2, \\\"0\\\") }} | {{ $Castelog.metodos.un_dia_de_la_semana(internal_value_date.getDay()) }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_dia_siguiente\\\"> » </ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                </DisposicionCuadricular>\"\n        + \"                <div class=\\\"carta_vacia marginado_vertical_1\\\">\"\n        + \"                    <EtiquetaDeControl class=\\\"importancia_2\\\">Calendario:</EtiquetaDeControl>\"\n        + \"                    <Calendario ref=\\\"calendario\\\" :al-cambiar-fecha=\\\"seleccionar_fecha\\\"></Calendario>\"\n        + \"                </div>\"\n        + \"            </template>\"\n        + \"            <template v-if=\\\"(modo === 'solo hora') || (modo === 'normal')\\\">\"\n        + \"                <DisposicionCuadricular v-if=\\\"internal_value_date\\\" class=\\\"cuadricula_para_panel_de_control_de_hora_a_milisegundo\\\">\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Hora:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_hora_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_hora_siguiente\\\"><div class=\\\"girado_de_izquierda_a_arriba\\\"> « </div></ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getHours(), 2, \\\"0\\\") }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_hora_anterior\\\"><div class=\\\"girado_de_derecha_a_abajo\\\"> » </div></ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Minuto:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_minuto_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_minuto_siguiente\\\"><div class=\\\"girado_de_izquierda_a_arriba\\\"> « </div></ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getMinutes(), 2, \\\"0\\\") }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_minuto_anterior\\\"><div class=\\\"girado_de_derecha_a_abajo\\\"> » </div></ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Segundo:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_segundo_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_segundo_siguiente\\\"><div class=\\\"girado_de_izquierda_a_arriba\\\"> « </div></ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getSeconds(), 2, \\\"0\\\") }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_segundo_anterior\\\"><div class=\\\"girado_de_derecha_a_abajo\\\"> » </div></ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                    <DisposicionLineal class=\\\"disposicion_vertical\\\">\"\n        + \"                        <EtiquetaDeControl class=\\\"importancia_2\\\">Milisegundo:</EtiquetaDeControl>\"\n        + \"                        <DisposicionLineal class=\\\"contenedor_de_parte_de_fecha contenedor_de_milisegundo_de_fecha\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_milisegundo_siguiente\\\"><div class=\\\"girado_de_izquierda_a_arriba\\\"> « </div></ControlParaBoton>\"\n        + \"                            <Capa class=\\\"caja_de_parte_de_fecha\\\">{{ $Castelog.metodos.un_relleno_de_texto(internal_value_date.getMilliseconds(), 3, \\\"0\\\") }}</Capa>\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"ir_a_milisegundo_anterior\\\"><div class=\\\"girado_de_derecha_a_abajo\\\"> » </div></ControlParaBoton>\"\n        + \"                        </DisposicionLineal>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                </DisposicionCuadricular>\"\n        + \"            </template>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    modo: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"normal\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    valorInicial: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_formateo_de_fecha(new Date(), null, \"un formateo de fecha a texto\");\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        try {\n                            if (!(typeof this.valorInicial === 'string')) throw new Error(\"Error en fichero [-] en posición [27788-27833=584:21-584:66] cuando: \" + \"compruebo que this.valorInicial es tipo texto\");\n                            if (!(this.valorInicial.length > 2)) throw new Error(\"Error en fichero [-] en posición [27834-27908=584:67-585:74] cuando: \" + \"compruebo que this.valorInicial.length es mayor que 2\");\n                        } catch (error) {\n                            console.log(\"Required property «valor-inicial» in component «ControlParaMomento» to be a string and with a length greater than 2 in order to «ControlParaMomento.data»\");\n                            throw error;\n                        }\n                        const fecha = Castelog.metodos.un_formateo_de_fecha(this.valorInicial, null, \"un formateo de texto a fecha\");\n                        return {\n                            internal_value: this.valorInicial,\n                            internal_value_date: fecha\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                watch: {\n                    internal_value_date: function (nuevoValor) {\n                        try {\n                            this.internal_value = Castelog.metodos.un_formateo_de_fecha(nuevoValor, null, \"un formateo de fecha a texto\");\n                            if ((!(typeof this.$refs.calendario === 'undefined'))) {\n                                this.$refs.calendario.seleccionar_dia(nuevoValor);\n                            }\n                            if ((!(typeof this.$refs.reloj === 'undefined'))) {\n                                this.$refs.reloj.seleccionar_hora(nuevoValor);\n                            }\n                            this.$forceUpdate(true);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                methods: {\n                    get_value: function () {\n                        try {\n                            return this.internal_value;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    seleccionar_fecha: function (valor) {\n                        try {\n                            this.internal_value_date = valor;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_dia_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setDate(fechaTemporal.getDate() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_mes_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMonth(fechaTemporal.getMonth() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_anyo_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setFullYear(fechaTemporal.getFullYear() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_dia_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setDate(fechaTemporal.getDate() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_mes_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMonth(fechaTemporal.getMonth() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_anyo_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setFullYear(fechaTemporal.getFullYear() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_dia_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setDate(fechaTemporal.getDate() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_dia_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setDate(fechaTemporal.getDate() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_hora_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setHours(fechaTemporal.getHours() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_hora_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setHours(fechaTemporal.getHours() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_minuto_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMinutes(fechaTemporal.getMinutes() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_minuto_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMinutes(fechaTemporal.getMinutes() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_segundo_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setSeconds(fechaTemporal.getSeconds() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_segundo_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setSeconds(fechaTemporal.getSeconds() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_milisegundo_anterior: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMilliseconds(fechaTemporal.getMilliseconds() - 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    ir_a_milisegundo_siguiente: function () {\n                        try {\n                            const fechaTemporal = new Date(this.internal_value_date);\n                            fechaTemporal.setMilliseconds(fechaTemporal.getMilliseconds() + 1);\n                            this.internal_value_date = fechaTemporal;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"Calendario\", \"<div class=\\\"Calendario\\\">\"\n        + \"            <div class=\\\"contenedor_de_calendario\\\">\"\n        + \"                <table v-if=\\\"internal_dias\\\">\"\n        + \"                    <tr v-for=\\\"(fila, filaIndex) in internal_dias\\\" v-bind:key=\\\"'calendario-' + uuid + '-fila-' + filaIndex\\\">\"\n        + \"                        <td v-for=\\\"(celda, celdaIndex) in fila\\\" v-bind:key=\\\"'calendario-' + uuid + '-fila-' + filaIndex + '-celda-' + celdaIndex\\\" :class=\\\"{seleccionado:internal_value_date.getDate() === celda.dia}\\\">\"\n        + \"                            <div class=\\\"contenedor_de_dia_de_calendario\\\" v-on:click=\\\"seleccionar_dia(celda, 1, { fila: filaIndex, celda: celdaIndex })\\\">\"\n        + \"                                <span class=\\\"dia_de_calendario\\\" v-if=\\\"celda.dia\\\">{{ celda.dia }}</span>\"\n        + \"                            </div>\"\n        + \"                        </td>\"\n        + \"                    </tr>\"\n        + \"                </table>\"\n        + \"            </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    valorInicial: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_formateo_de_fecha(new Date(), null, \"un formateo de fecha a texto\");\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiarFecha: {\n                        type: Function,\n                        default: function () {\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        const fecha_inicial = Castelog.metodos.un_formateo_de_fecha(this.valorInicial, null, \"un formateo de texto a fecha\");\n                        return {\n                            internal_dias: this.computar_dias_de_mes(fecha_inicial),\n                            internal_value: this.valorInicial,\n                            internal_value_date: fecha_inicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    seleccionar_dia: function (dia,\n                        con_propagacion = false) {\n                            try {\n                                if (dia instanceof Date) {\n                                    const nueva_fecha = new Date(dia);\n                                    this.internal_value_date = nueva_fecha;\n                                    if (con_propagacion) {\n                                        this.alCambiarFecha(nueva_fecha,\n                                            this);\n                                    }\n                                    this.$forceUpdate(true);\n                                    return 1;\n                                }\n                                if (typeof dia === 'object') {\n                                    if ((!(((o) => (typeof o === 'number') && (!isNaN(o)) && (o !== Infinity))(dia.dia)))) {\n                                        throw new Error(\"Required parameter «dia.dia» to be number in order to «Calendario.seleccionar_dia»\");\n                                    }\n                                    const nueva_fecha = new Date(this.internal_value_date);\n                                    nueva_fecha.setDate(dia.dia);\n                                    this.internal_value_date = nueva_fecha;\n                                    if (con_propagacion) {\n                                        this.alCambiarFecha(nueva_fecha,\n                                            this);\n                                    }\n                                    this.$forceUpdate(true);\n                                    return 2;\n                                }\n                                throw new Error(\"Required parameter «dia» to be an instance of Date or an object in order to «Calendario.seleccionar_dia»\");\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                    },\n                    computar_dias_de_mes: function (fecha) {\n                        try {\n                            const fecha2 = new Date(fecha);\n                            const dias_de_mes = [[]];\n                            fecha2.setDate(1);\n                            while ((!(fecha2.getDay() === 1))) {\n                                fecha2.setDate(fecha2.getDate() - 1);\n                            }\n                            while ((!(fecha2.getMonth() === fecha.getMonth()))) {\n                                dias_de_mes[0].push({\n                                });\n                                fecha2.setDate(fecha2.getDate() + 1);\n                            }\n                            while (fecha2.getMonth() === fecha.getMonth()) {\n                                dias_de_mes[dias_de_mes.length - 1].push({\n                                    dia: fecha2.getDate()\n                                });\n                                const es_domingo = fecha2.getDay() === 0;\n                                if (es_domingo) {\n                                    dias_de_mes.push([]);\n                                }\n                                fecha2.setDate(fecha2.getDate() + 1);\n                            }\n                            while ((!(fecha2.getDay() === 1))) {\n                                dias_de_mes[dias_de_mes.length - 1].push({\n                                });\n                                fecha2.setDate(fecha2.getDate() + 1);\n                            }\n                            return dias_de_mes;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                watch: {\n                    internal_value_date: function (nuevoValor) {\n                        try {\n                            this.internal_value = Castelog.metodos.un_formateo_de_fecha(nuevoValor, null, \"un formateo de fecha a texto\");\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    internal_value: function (nuevoValor) {\n                        try {\n                            const fecha = Castelog.metodos.un_formateo_de_fecha(nuevoValor, null, \"un formateo de texto a fecha\");\n                            this.internal_dias = this.computar_dias_de_mes(fecha);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaPlazoTemporal\", \"<div class=\\\"ControlParaPlazoTemporal carta_vacia Control\\\">\"\n        + \"            <input class=\\\"PuntoDeControl\\\" type=\\\"hidden\\\" v-model=\\\"internal_value\\\" />\"\n        + \"            <ControlParaEntrada\"\n        + \"                tipo=\\\"momento\\\"\"\n        + \"                :gestor=\\\"this\\\"\"\n        + \"                propiedad=\\\"internal_value_start\\\"\"\n        + \"                enunciado=\\\"Desde:\\\"\"\n        + \"                modo=\\\"normal\\\"\"\n        + \"                :valor-inicial=\\\"internal_value_start\\\"\"\n        + \"                :expandible=\\\"true\\\"\"\n        + \"            />\"\n        + \"            <ControlParaEntrada\"\n        + \"                tipo=\\\"momento\\\"\"\n        + \"                :gestor=\\\"this\\\"\"\n        + \"                propiedad=\\\"internal_value_end\\\"\"\n        + \"                enunciado=\\\"Hasta\\\"\"\n        + \"                modo=\\\"normal\\\"\"\n        + \"                :valor-inicial=\\\"internal_value_start\\\"\"\n        + \"                :expandible=\\\"true\\\"\"\n        + \"            />\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    modo: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"normal\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    valorInicial: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_formateo_de_fecha(new Date(), null, \"un formateo de fecha a texto\");\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        const [start, end] = this.valorInicial.split(\"&\");\n                        return {\n                            internal_value: this.valorInicial,\n                            internal_value_start: start,\n                            internal_value_end: end\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                watch: {\n                    internal_value_start: function (nuevoValor) {\n                        try {\n                            const [start, end] = this.internal_value.split(\"&\");\n                            this.internal_value = nuevoValor + ' & ' + end;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    internal_value_end: function (nuevoValor) {\n                        try {\n                            const [start, end] = this.internal_value.split(\"&\");\n                            this.internal_value = start + ' & ' + nuevoValor;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaPuntoMultidimensional\", \"<div class=\\\"ControlParaPuntoMultidimensional Control\\\">\"\n        + \"            <input class=\\\"PuntoDeControl\\\" type=\\\"hidden\\\" v-model=\\\"internal_value\\\" />\"\n        + \"            <div class=\\\"carta_vacia\\\">\"\n        + \"                <template v-for=\\\"(dimension, dimensionIndex) in dimensiones\\\">\"\n        + \"                    <DisposicionLineal style=\\\"flow-direction: column;\\\" v-bind:key=\\\"'control-para-punto-multidimensional-' + uuid + '-dimension-' + dimensionIndex\\\">\"\n        + \"                        <Item style=\\\"flex-grow: 1;\\\">\"\n        + \"                            <ControlParaEntrada\"\n        + \"                                :tipo=\\\"tipoDeEntradas\\\"\"\n        + \"                                :gestor=\\\"internal_value\\\"\"\n        + \"                                propiedad=\\\"dimensionIndex\\\"\"\n        + \"                                :enunciado=\\\"'Dimensión ' + (dimensionIndex+1) + ':'\\\"\"\n        + \"                                :valor-inicial=\\\"internal_value[dimensionIndex]\\\"\"\n        + \"                                :al-cambiar=\\\"fabrica_para_propagar_cambios_en_dimension(dimensionIndex)\\\"\"\n        + \"                            />\"\n        + \"                        </Item>\"\n        + \"                        <Item style=\\\"flex-grow: auto;\\\" v-if=\\\"dimensionable\\\">\"\n        + \"                            <ControlParaBoton v-on:click.native=\\\"() => internal_value.splice(dimensionIndex, 1)\\\">Quitar</ControlParaBoton>\"\n        + \"                        </Item>\"\n        + \"                    </DisposicionLineal>\"\n        + \"                </template>\"\n        + \"                <template v-if=\\\"dimensionable\\\">\"\n        + \"                    <ControlParaBoton v-on:click.native=\\\"() => internal_value.push(0)\\\">Añadir dimensión</ControlParaBoton>\"\n        + \"                </template>\"\n        + \"            </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    dimensiones: {\n                        type: Number,\n                        default: function () {\n                            try {\n                                return 3;\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    dimensionable: {\n                        type: Boolean,\n                        default: function () {\n                            try {\n                                return false;\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    valorInicial: {\n                        type: Array,\n                        default: function () {\n                            try {\n                                return [0,\n                                    0,\n                                    0];\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    },\n                    tipoDeEntradas: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"numero\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            internal_value: this.valorInicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    fabrica_para_propagar_cambios_en_dimension: function (dimensionIndex) {\n                        try {\n                            return (componente,\n                                valor) => {\n                                    try {\n                                        let nuevo_valor = ([]).concat(this.internal_value);\n                                        nuevo_valor[dimensionIndex] = valor;\n                                        this.internal_value = nuevo_valor;\n                                        this.$forceUpdate(true);\n                                    } catch (error) {\n                                        console.log(error);\n                                        throw error;\n                                    }\n\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                mounted: function () {\n                },\n                watch: {\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaLista\", \"<div class=\\\"ControlParaLista Control\\\">\"\n        + \"            <input class=\\\"PuntoDeControl\\\" type=\\\"hidden\\\" v-model=\\\"internal_value\\\" />\"\n        + \"            Lista...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            internal_value: this.valorInicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaObjeto\", \"<div class=\\\"ControlParaObjeto Control\\\">\"\n        + \"            <input class=\\\"PuntoDeControl\\\" type=\\\"hidden\\\" v-model=\\\"internal_value\\\" />\"\n        + \"            Objeto...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            internal_value: this.valorInicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaEntrada\", \"<div class=\\\"ControlParaEntrada Control\\\">\"\n        + \"            <EtiquetaDeControl v-if=\\\"enunciado\\\">\"\n        + \"                <DisposicionLineal style=\\\"flex-direction: row;\\\">\"\n        + \"                    <Item style=\\\"flex-grow: 1; align-self: flex-end;\\\">\"\n        + \"                        <span>{{ enunciado }} </span>\"\n        + \"                        <span v-if=\\\"['fichero'].indexOf(tipo) === -1\\\">\"\n        + \"                            <template v-if=\\\"['texto', 'texto largo', 'contrasenya'].indexOf(tipo) !== -1\\\">\"\n        + \"                                ({{ internal_value.length }} caracteres)\"\n        + \"                            </template>\"\n        + \"                            <template v-else-if=\\\"internal_value\\\">\"\n        + \"                                ({{ internal_value }})\"\n        + \"                            </template>\"\n        + \"                            <template v-else></template>\"\n        + \"                        </span>\"\n        + \"                    </Item>\"\n        + \"                    <Item style=\\\"flex-grow: 0;\\\" v-if=\\\"expandible\\\">\"\n        + \"                        <ControlParaBoton class=\\\"boton_de_expandir_control\\\" v-on:click.native=\\\"expandir_o_contraer\\\">{{ esta_expandido ? \\\"Contraer\\\" : \\\"Expandir\\\" }}</ControlParaBoton>\"\n        + \"                    </Item>\"\n        + \"                </DisposicionLineal>\"\n        + \"            </EtiquetaDeControl>\"\n        + \"            <template v-if=\\\"tipo === 'fichero'\\\">\"\n        + \"                <ControlParaFichero ref=\\\"control\\\" :class=\\\"{ oculto: !esta_expandido }\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"            </template>\"\n        + \"            <template v-else>\"\n        + \"                <template v-if=\\\"esta_expandido\\\">\"\n        + \"                    <ControlParaTexto ref=\\\"control\\\" v-if=\\\"tipo === 'texto'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaTextoLargo ref=\\\"control\\\" v-else-if=\\\"tipo === 'texto largo'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaNumero ref=\\\"control\\\" v-else-if=\\\"tipo === 'numero'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaDia ref=\\\"control\\\" v-else-if=\\\"tipo === 'dia'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaHora ref=\\\"control\\\" v-else-if=\\\"tipo === 'hora'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaMomento ref=\\\"control\\\" v-else-if=\\\"tipo === 'momento'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaPlazoTemporal ref=\\\"control\\\" v-else-if=\\\"tipo === 'plazo temporal'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaPuntoMultidimensional ref=\\\"control\\\" v-else-if=\\\"tipo === 'punto bidimensional'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" :tipo-de-entradas=\\\"tipoDeEntradas\\\" :dimensiones=\\\"2\\\" />\"\n        + \"                    <ControlParaPuntoMultidimensional ref=\\\"control\\\" v-else-if=\\\"tipo === 'punto multidimensional'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" :tipo-de-entradas=\\\"tipoDeEntradas\\\" />\"\n        + \"                    <ControlParaContrasenya ref=\\\"control\\\" v-else-if=\\\"tipo === 'contrasenya'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaColor ref=\\\"control\\\" v-else-if=\\\"tipo === 'color'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaGrupoDeOpciones ref=\\\"control\\\" v-else-if=\\\"tipo === 'grupo de opciones'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaOpcion ref=\\\"control\\\" v-else-if=\\\"tipo === 'opcion'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaSelectorAvanzado ref=\\\"control\\\" v-else-if=\\\"tipo === 'selectorAvanzado'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaTags ref=\\\"control\\\" v-else-if=\\\"tipo === 'tags'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaLista ref=\\\"control\\\" v-else-if=\\\"tipo === 'lista'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaObjeto ref=\\\"control\\\" v-else-if=\\\"tipo === 'objeto'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaEnvio ref=\\\"control\\\" v-else-if=\\\"tipo === 'envio'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <ControlParaReset ref=\\\"control\\\" v-else-if=\\\"tipo === 'reset'\\\" :valor-inicial=\\\"internal_value\\\" :gestor=\\\"this\\\" propiedad=\\\"internal_value\\\" />\"\n        + \"                    <Capa v-else-if=\\\"tipo === 'color'\\\" :valor-inicial=\\\"internal_value\\\">\"\n        + \"                        <Texto>No se identificó el tipo de control especificado, en este caso: {{ tipo }}.</Texto>\"\n        + \"                    </Capa>\"\n        + \"                </template>\"\n        + \"            </template>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    enunciado: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    tipo: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"texto\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    valorInicial: {\n                        type: [String,\n                            Array,\n                            Object,\n                            Boolean,\n                            Function,\n                            Number],\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"internal_value\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    expandible: {\n                        type: Boolean,\n                        default: function () {\n                            try {\n                                return true;\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    atributos: {\n                        type: Object,\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    },\n                    tipoDeEntradas: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"numero\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            esta_expandido: ((!(this.expandible))) || false,\n                            internal_value: this.valorInicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                watch: {\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                methods: {\n                    expandir_o_contraer: function () {\n                        try {\n                            this.esta_expandido = (!(this.esta_expandido));\n                            this.$forceUpdate(true);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaTextoLargo\", \"<textarea class=\\\"ControlParaTextoLargo Control PuntoDeControl\\\" v-model=\\\"internal_value\\\"></textarea>\", function (component) {\n        return {\n            props: {\n                valorInicial: {\n                    type: [String,\n                        Number],\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                            nuevoValor,\n                            this.alCambiar);\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaTexto\", \"<input class=\\\"ControlParaTexto Control PuntoDeControl\\\" type=\\\"text\\\" v-model=\\\"internal_value\\\" :key=\\\"'control_para_texto_' + uuid\\\" />\", function (component) {\n        return {\n            props: {\n                uuid: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                valorInicial: {\n                    type: [String,\n                        Number],\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                            nuevoValor,\n                            this.alCambiar);\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaNumero\", \"<input class=\\\"ControlParaNumero Control PuntoDeControl\\\" type=\\\"number\\\" v-model=\\\"internal_value\\\" />\", function (component) {\n        return {\n            props: {\n                valorInicial: {\n                    type: [String,\n                        Number],\n                    default: function () {\n                        try {\n                            return 0;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                            nuevoValor,\n                            this.alCambiar);\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaBooleano\", \"<input class=\\\"ControlParaBooleano Control PuntoDeControl\\\" type=\\\"checkbox\\\" v-model=\\\"internal_value\\\" />\", function (component) {\n        return {\n            props: {\n                valorInicial: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                },\n                valorEnLista: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                modo: \"booleano\"\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        if (this.modo === \"booleano\") {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        }\n                        else if (this.modo === \"item de lista\") {\n                            if (((!(typeof this.gestor === 'undefined'))) && (typeof this.propiedad === 'string')) {\n                                const seleccionados_actuales = this.gestor[this.propiedad];\n                                const posicion_en_lista = seleccionados_actuales.indexOf(this.valorEnLista);\n                                if (posicion_en_lista === 0 - 1) {\n                                    seleccionados_actuales.push(this.valorEnLista);\n                                }\n                                else {\n                                    seleccionados_actuales.splice(position_en_lista,\n                                        1);\n                                }\n                            }\n                            if (typeof callback === 'function') {\n                                callback(this,\n                                    nuevoValor);\n                            }\n                            this.$forceUpdate(true);\n                        }\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaSelectorSimple\", \"<select class=\\\"ControlParaSelectorSimple Control PuntoDeControl\\\" v-model=\\\"internal_value\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </select>\", function (component) {\n            return {\n                props: {\n                    valorInicial: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            internal_value: this.valorInicial\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                watch: {\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                methods: {\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaFichero\", \"<div class=\\\"ControlParaFichero Control\\\">\"\n        + \"            <input ref=\\\"entrada_de_fichero\\\" class=\\\"PuntoDeControl\\\" type=\\\"file\\\" v-on:change=\\\"propaga_cambio\\\" />\"\n        + \"            <img ref=\\\"salida_de_imagen\\\" class=\\\"imagen_de_fichero\\\" alt=\\\"No hay imagen cargada.\\\"></img>\"\n        + \"        </div>\", function (component) {\n            return {\n                props: {\n                    uuid: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    gestor: {\n                        type: [Object,\n                            Array,\n                            Function],\n                        default: function () {\n                            try {\n                                return {\n                                };\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    propiedad: {\n                        type: String,\n                        default: function () {\n                            try {\n                                return \"\";\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                        }\n                    },\n                    alCambiar: {\n                        type: Function,\n                        default: function () {\n                        }\n                    }\n                },\n                data: function () {\n                    try {\n                        return {\n                            internal_value: undefined\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                watch: {\n                    internal_value: function (nuevoValor) {\n                        try {\n                            Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                                nuevoValor,\n                                this.alCambiar);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                methods: {\n                    propaga_cambio: function (evento) {\n                        try {\n                            const elemento = evento.target;\n                            const ficheros = elemento.files;\n                            if (FileReader && ficheros && ficheros.length) {\n                                const [fichero] = ficheros;\n                                const lector = new FileReader();\n                                lector.onload = () => {\n                                    try {\n                                        console.log(lector);\n                                        this.$refs.salida_de_imagen.src = lector.result;\n                                        this.internal_value = {\n                                            ruta: fichero,\n                                            contenido: lector.result\n                                        };\n                                    } catch (error) {\n                                        console.log(error);\n                                        throw error;\n                                    }\n\n                                };\n                                lector.readAsDataURL(fichero);\n                            }\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaEnvio\", \"<ControlParaBoton :al-clicar=\\\"() => enviar_formulario()\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </ControlParaBoton>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    enviar_formulario: function () {\n                        try {\n                            return jQuery(this.$el).closest(\"form\").submit();\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaReset\", \"<ControlParaBoton :al-clicar=\\\"() => resetear_formulario()\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </ControlParaBoton>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    enviar_formulario: function () {\n                        try {\n                            return jQuery(this.$el).closest(\"form\").reset();\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaColor\", \"<input class=\\\"ControlParaColor Control PuntoDeControl\\\" type=\\\"color\\\" v-model=\\\"internal_value\\\" :key=\\\"'control_para_color_' + uuid\\\" />\", function (component) {\n        return {\n            props: {\n                uuid: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                valorInicial: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                            nuevoValor,\n                            this.alCambiar);\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaContrasenya\", \"<input class=\\\"ControlParaContrasenya Control PuntoDeControl\\\" type=\\\"password\\\" v-model=\\\"internal_value\\\" :key=\\\"'control_para_contrasenya_' + uuid\\\" />\", function (component) {\n        return {\n            props: {\n                uuid: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return Castelog.metodos.un_texto_aleatorio(10, undefined);\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                valorInicial: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                gestor: {\n                    type: [Object,\n                        Array,\n                        Function],\n                    default: function () {\n                        try {\n                            return {\n                            };\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                propiedad: {\n                    type: String,\n                    default: function () {\n                        try {\n                            return \"\";\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                alCambiar: {\n                    type: Function,\n                    default: function () {\n                    }\n                }\n            },\n            data: function () {\n                try {\n                    return {\n                        internal_value: this.valorInicial\n                    };\n                } catch (error) {\n                    console.log(error);\n                    throw error;\n                }\n\n            },\n            watch: {\n                internal_value: function (nuevoValor) {\n                    try {\n                        Castelog.metodos.propagar_cambios_desde_watcher.call(this,\n                            nuevoValor,\n                            this.alCambiar);\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            },\n            methods: {\n            }\n        };\n    }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaGrupoDeOpciones\", \"<div class=\\\"ControlParaGrupoDeOpciones\\\">\"\n        + \"            ControlParaGrupoDeOpciones...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaOpcion\", \"<div class=\\\"ControlParaOpcion\\\">\"\n        + \"            ControlParaOpcion...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaTags\", \"<div class=\\\"ControlParaTags\\\">\"\n        + \"            ControlParaTags...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"ControlParaSelectorAvanzado\", \"<div class=\\\"ControlParaSelectorAvanzado\\\">\"\n        + \"            ControlParaSelectorAvanzado...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Castelog.metodos.un_componente_vue2(\"EtiquetaDeControl\", \"<label class=\\\"EtiquetaDeControl\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </label>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"DisposicionLineal\", \"<div class=\\\"DisposicionLineal\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"DisposicionCuadricular\", \"<div class=\\\"DisposicionCuadricular\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"Item\", \"<div class=\\\"Item\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    Castelog.metodos.un_componente_vue2(\"Capa\", \"<div class=\\\"Capa\\\">\"\n        + \"            <slot></slot>\"\n        + \"        </div>\", null, null);\n    const PaginaDeInicio = Castelog.metodos.un_componente_vue2(\"PaginaDeInicio\", \"<div class=\\\"PaginaDeInicio Component\\\">\"\n        + \"        <TituloDeImportancia1>Componentes de la API Nativa de Castelog</TituloDeImportancia1>\"\n        + \"        <TituloDeImportancia2>Componentes de la API Nativa de Castelog</TituloDeImportancia2>\"\n        + \"        <TituloDeImportancia3>Componentes de la API Nativa de Castelog</TituloDeImportancia3>\"\n        + \"        <TituloDeImportancia4>Componentes de la API Nativa de Castelog</TituloDeImportancia4>\"\n        + \"        <TituloDeImportancia5>Componentes de la API Nativa de Castelog</TituloDeImportancia5>\"\n        + \"        <TituloDeImportancia6>Componentes de la API Nativa de Castelog</TituloDeImportancia6>\"\n        + \"        <Item>Column:</Item>\"\n        + \"        <DisposicionLineal style=\\\"flex-direction: column;\\\" class=\\\"bordeado\\\">\"\n        + \"            <Item>1</Item>\"\n        + \"            <Item>2</Item>\"\n        + \"            <Item>3</Item>\"\n        + \"        </DisposicionLineal>\"\n        + \"        <Item>Row:</Item>\"\n        + \"        <DisposicionLineal style=\\\"flex-direction: row;\\\" class=\\\"bordeado\\\">\"\n        + \"            <Item style=\\\"flex-grow: 0;\\\">1</Item>\"\n        + \"            <Item style=\\\"flex-grow: 1;\\\">2</Item>\"\n        + \"            <Item style=\\\"flex-grow: 0;\\\">3</Item>\"\n        + \"        </DisposicionLineal>\"\n        + \"        <Item>Row:</Item>\"\n        + \"        <DisposicionLineal style=\\\"flex-direction: row;\\\" class=\\\"bordeado\\\">\"\n        + \"            <Item style=\\\"flex-grow: 1;\\\">1</Item>\"\n        + \"            <Item style=\\\"flex-grow: 2;\\\">2</Item>\"\n        + \"            <Item style=\\\"flex-grow: 3;\\\">3</Item>\"\n        + \"            <Item style=\\\"flex-grow: 4;\\\">4</Item>\"\n        + \"            <Item style=\\\"flex-grow: 5;\\\">5</Item>\"\n        + \"            <Item style=\\\"flex-grow: 6;\\\">6</Item>\"\n        + \"        </DisposicionLineal>\"\n        + \"        <DisposicionCuadricular style=\\\"grid-template-columns: auto auto 1fr auto auto;\\\">\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> «« </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> « </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item style=\\\"text-align: center;\\\">Texto...</Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> » </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> »» </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> «« </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> « </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item style=\\\"text-align: center;\\\">Texto...</Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> » </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"            <Item>\"\n        + \"                <ControlParaBoton> »» </ControlParaBoton>\"\n        + \"            </Item>\"\n        + \"        </DisposicionCuadricular>\"\n        + \"        <Pestanyas>\"\n        + \"            <BotonDePestanya grupo=\\\"uno\\\" identificador=\\\"x\\\" class=\\\"seleccionado\\\">x</BotonDePestanya>\"\n        + \"            <BotonDePestanya grupo=\\\"uno\\\" identificador=\\\"y\\\">y</BotonDePestanya>\"\n        + \"            <BotonDePestanya grupo=\\\"uno\\\" identificador=\\\"z\\\">z</BotonDePestanya>\"\n        + \"            <PanelDePestanya grupo=\\\"uno\\\" identificador=\\\"x\\\" class=\\\"seleccionado\\\">\"\n        + \"                <ChivatoDeVista />\"\n        + \"                <LineaHorizontal />\"\n        + \"                <Capa>\"\n        + \"                    <ControlParaEntrada\"\n        + \"                        tipo=\\\"texto\\\"\"\n        + \"                        enunciado=\\\"Nombre completo:\\\"\"\n        + \"                        relleno=\\\"Pepito de los Palotes Vázquez\\\"\"\n        + \"                        :gestor=\\\"this\\\"\"\n        + \"                        propiedad=\\\"nombre_de_x\\\"\"\n        + \"                        valor-inicial=\\\"\\\"\"\n        + \"                    />\"\n        + \"                    <ControlParaEntrada\"\n        + \"                        tipo=\\\"texto\\\"\"\n        + \"                        enunciado=\\\"Ciudad:\\\"\"\n        + \"                        relleno=\\\"Alarcón de Pozuelo\\\"\"\n        + \"                        :gestor=\\\"this\\\"\"\n        + \"                        propiedad=\\\"ciudad_de_x\\\"\"\n        + \"                        valor-inicial=\\\"\\\"\"\n        + \"                    />\"\n        + \"                    <ControlParaEntrada\"\n        + \"                        tipo=\\\"texto largo\\\"\"\n        + \"                        enunciado=\\\"Descripción:\\\"\"\n        + \"                        :gestor=\\\"this\\\"\"\n        + \"                        propiedad=\\\"descripcion\\\"\"\n        + \"                        valor-inicial=\\\"\\\"\"\n        + \"                    />\"\n        + \"                </Capa>\"\n        + \"            </PanelDePestanya>\"\n        + \"            <PanelDePestanya grupo=\\\"uno\\\" identificador=\\\"y\\\">\"\n        + \"                <ChivatoDeVista />\"\n        + \"                <div>Este es el panel y</div>\"\n        + \"            </PanelDePestanya>\"\n        + \"            <PanelDePestanya grupo=\\\"uno\\\" identificador=\\\"z\\\">\"\n        + \"                <ChivatoDeVista />\"\n        + \"                <div>Este es el panel z</div>\"\n        + \"            </PanelDePestanya>\"\n        + \"        </Pestanyas>\"\n        + \"        <GaleriaDeImagenes :imagenes=\\\"['./img/0.png','./img/1.png','./img/2.png','./img/3.png','./img/4.png','./img/5.png','./img/6.png','./img/7.png','./img/8.png','./img/9.png','./img/10.png']\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"texto\\\" enunciado=\\\"Texto:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"texto largo\\\" enunciado=\\\"Texto largo:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"numero\\\" enunciado=\\\"Numero:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"dia\\\" enunciado=\\\"Selecciona el día:\\\" :valor-inicial=\\\"$Castelog.metodos.un_formateo_de_fecha(new Date(), 'YYYY/MM/DD HH:mm:ss.xxx', 'un formateo de fecha a texto')\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"hora\\\" enunciado=\\\"Selecciona la hora:\\\" :valor-inicial=\\\"$Castelog.metodos.un_formateo_de_fecha(new Date(), 'YYYY/MM/DD HH:mm:ss.xxx', 'un formateo de fecha a texto')\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"momento\\\" enunciado=\\\"Selecciona el día y la hora:\\\" :valor-inicial=\\\"$Castelog.metodos.un_formateo_de_fecha(new Date(), 'YYYY/MM/DD HH:mm:ss.xxx', 'un formateo de fecha a texto')\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"plazo temporal\\\" enunciado=\\\"Plazo temporal:\\\" :valor-inicial=\\\"$Castelog.metodos.un_formateo_de_fecha(new Date()) + ' & ' + $Castelog.metodos.un_formateo_de_fecha(new Date())\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"punto bidimensional\\\" enunciado=\\\"Punto bidimensional:\\\" :valor-inicial=\\\"[0,0]\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"punto multidimensional\\\" enunciado=\\\"Punto multidimensional:\\\" :valor-inicial=\\\"[0,0,0]\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"contrasenya\\\" enunciado=\\\"Contrasenya:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"color\\\" enunciado=\\\"Color:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"fichero\\\" enunciado=\\\"Fichero:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"grupo de opciones\\\" enunciado=\\\"Grupo de opciones:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"opcion\\\" enunciado=\\\"Opcion:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"tags\\\" enunciado=\\\"Tags:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"lista\\\" enunciado=\\\"Lista:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"objeto\\\" enunciado=\\\"Objeto:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"selector avanzado\\\" enunciado=\\\"Selector avanzado:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"envio\\\" enunciado=\\\"Envio:\\\" />\"\n        + \"        <ControlParaEntrada tipo=\\\"reset\\\" enunciado=\\\"Reset:\\\" />\"\n        + \"    </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            nombre_de_x: \"\",\n                            ciudad_de_x: \"\"\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const ChivatoDeVista = Castelog.metodos.un_componente_vue2(\"ChivatoDeVista\", \"<div>\"\n        + \"            <SoloReloj>\"\n        + \"                <div>Vista de reloj:</div>\"\n        + \"            </SoloReloj>\"\n        + \"            <SoloMovil>\"\n        + \"                <div>Vista de movil:</div>\"\n        + \"            </SoloMovil>\"\n        + \"            <SoloTablet>\"\n        + \"                <div>Vista de tablet:</div>\"\n        + \"            </SoloTablet>\"\n        + \"            <SoloOrdenador>\"\n        + \"                <div>Vista de ordenador:</div>\"\n        + \"            </SoloOrdenador>\"\n        + \"            <SoloTelevision>\"\n        + \"                <div>Vista de television:</div>\"\n        + \"            </SoloTelevision>\"\n        + \"            <SoloProyector>\"\n        + \"                <div>Vista de proyector:</div>\"\n        + \"            </SoloProyector>\"\n        + \"        </div>\", null, null);\n    const LineaHorizontal = Castelog.metodos.un_componente_vue2(\"LineaHorizontal\", \"<div class=\\\"LineaHorizontal\\\"></div>\", null, null);\n    const Carta = Castelog.metodos.un_componente_vue2(\"Carta\", \"<div class=\\\"Carta\\\">\"\n        + \"            Carta...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Sonido = Castelog.metodos.un_componente_vue2(\"Sonido\", \"<div class=\\\"Sonido\\\">\"\n        + \"            Sonido...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const ReproductorDeSonido = Castelog.metodos.un_componente_vue2(\"ReproductorDeSonido\", \"<div class=\\\"ReproductorDeSonido\\\">\"\n        + \"            ReproductorDeSonido...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Video = Castelog.metodos.un_componente_vue2(\"Video\", \"<div class=\\\"Video\\\">\"\n        + \"            Video...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const ReproductorDeVideo = Castelog.metodos.un_componente_vue2(\"ReproductorDeVideo\", \"<div class=\\\"ReproductorDeVideo\\\">\"\n        + \"            ReproductorDeVideo...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const VideoDeYoutube = Castelog.metodos.un_componente_vue2(\"VideoDeYoutube\", \"<div class=\\\"VideoDeYoutube\\\">\"\n        + \"            VideoDeYoutube...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Tabla = Castelog.metodos.un_componente_vue2(\"Tabla\", \"<div class=\\\"Tabla\\\">\"\n        + \"            Tabla...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Fila = Castelog.metodos.un_componente_vue2(\"Fila\", \"<div class=\\\"Fila\\\">\"\n        + \"            Fila...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Celda = Castelog.metodos.un_componente_vue2(\"Celda\", \"<div class=\\\"Celda\\\">\"\n        + \"            Celda...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const GestorDeDatosDeTabla = Castelog.metodos.un_componente_vue2(\"GestorDeDatosDeTabla\", \"<div class=\\\"GestorDeDatosDeTabla\\\">\"\n        + \"            GestorDeDatosDeTabla...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const GestorDeDatosDeFila = Castelog.metodos.un_componente_vue2(\"GestorDeDatosDeFila\", \"<div class=\\\"GestorDeDatosDeFila\\\">\"\n        + \"            GestorDeDatosDeFila...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const BuscadorDeDatos = Castelog.metodos.un_componente_vue2(\"BuscadorDeDatos\", \"<div class=\\\"BuscadorDeDatos\\\">\"\n        + \"            BuscadorDeDatos...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const ListadorDeDatos = Castelog.metodos.un_componente_vue2(\"ListadorDeDatos\", \"<div class=\\\"ListadorDeDatos\\\">\"\n        + \"            ListadorDeDatos...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const PaginadorDeDatos = Castelog.metodos.un_componente_vue2(\"PaginadorDeDatos\", \"<div class=\\\"PaginadorDeDatos\\\">\"\n        + \"            PaginadorDeDatos...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const IndiceDePagina = Castelog.metodos.un_componente_vue2(\"IndiceDePagina\", \"<div class=\\\"IndiceDePagina\\\">\"\n        + \"            IndiceDePagina...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const PuertoDeDialogos = Castelog.metodos.un_componente_vue2(\"PuertoDeDialogos\", \"<div class=\\\"PuertoDeDialogos\\\">\"\n        + \"            <div class=\\\"contenedor_de_puerto_de_dialogo\\\" v-for=\\\"(dialogo, dialogoIndex) in dialogos\\\" v-bind:key=\\\"'puerto-de-dialogo-' + dialogoIndex\\\">\"\n        + \"                <div class=\\\"capa_de_puerto_de_dialogo\\\">\"\n        + \"                    <component :is=\\\"dialogo.componente\\\" v-bind=\\\"dialogo.atributos\\\" v-on=\\\"dialogo.eventos\\\"></component>\"\n        + \"                </div>\"\n        + \"            </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            dialogos: []\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                mounted: function () {\n                    try {\n                        this.$dialogos = this;\n                        Vue.prototype.$dialogos = this;\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    abrir_dialogo: function () {\n                    },\n                    cerrar_dialogo: function () {\n                    }\n                }\n            };\n        }, null);\n    const PuertoDeNotificaciones = Castelog.metodos.un_componente_vue2(\"PuertoDeNotificaciones\", \"<div class=\\\"PuertoDeNotificaciones\\\">\"\n        + \"        <div class=\\\"contenedor_de_puerto_de_notificacion\\\" v-for=\\\"(notificacion, notificacionIndex) in notificaciones\\\" v-bind:key=\\\"'puerto-de-notificacion-' + notificacionIndex\\\">\"\n        + \"            <div class=\\\"capa_de_puerto_de_notificacion\\\" v-if=\\\"(typeof notificacion === 'object') && (typeof notificacion.component === 'string')\\\">\"\n        + \"            <component :is=\\\"notificacion.componente\\\" v-bind=\\\"notificacion.atributos\\\" v-on=\\\"notificacion.eventos\\\"></component>\"\n        + \"            </div>\"\n        + \"            <div class=\\\"capa_de_puerto_de_notificacion\\\" v-else>\"\n        + \"                <div class=\\\"cabecera_de_notificacion\\\">Notificación:</div>\"\n        + \"                <div class=\\\"cuerpo_de_notificacion\\\">{{ dialogo }}</div>\"\n        + \"                <div class=\\\"pie_de_notificacion\\\">\"\n        + \"                    <ControlParaBoton :al-clicar=\\\"() => notificacion.resolver_notificacion('ok')\\\">Aceptar</ControlParaBoton>\"\n        + \"                </div>\"\n        + \"            </div>\"\n        + \"        </div>\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            notificaciones: []\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    notificar: function (datos) {\n                        try {\n                            this.notificaciones.push({\n                                tipo: datos.tipo || \"info\",\n                                titulo: datos.tipo || \"Nota informativa\",\n                                mensaje: datos.mensaje,\n                                detalles: datos.detalles\n                            })\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    notificar_error: function (error) {\n                        try {\n                            this.notificaciones.push({\n                                tipo: \"error\",\n                                titulo: error.name,\n                                mensaje: error.message,\n                                detalles: error.stack\n                            })\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    }\n                },\n                mounted: function () {\n                    try {\n                        this.$notificaciones = this;\n                        Vue.prototype.$notificaciones = this;\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const Hipervinculo = Castelog.metodos.un_componente_vue2(\"Hipervinculo\", \"<a class=\\\"Hipervinculo\\\"><slot></slot></a>\", null, null);\n    const Icono = Castelog.metodos.un_componente_vue2(\"Icono\", \"<div class=\\\"Icono\\\">\"\n        + \"            Icono...\"\n        + \"        </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    const PuertoDeComunicaciones = Castelog.metodos.un_componente_vue2(\"PuertoDeComunicaciones\", \"<div class=\\\"PuertoDeComunicaciones\\\">\"\n        + \"        <div class=\\\"contenedor_de_puerto_de_comunicaciones\\\" v-if=\\\"identificador_de_componente && atributos_de_componente && eventos_de_componente\\\" v-bind:key=\\\"'puerto_de_comunicacion_' + identificador_de_comunicacion\\\">\"\n        + \"        <component :is=\\\"identificador_de_componente\\\" v-bind=\\\"atributos_de_componente\\\" v-on=\\\"eventos_de_componente\\\" v-bind:key=\\\"'componente_de_puerto_de_comunicacion_' + identificador_de_comunicacion\\\"/>\"\n        + \"        </div>\"\n        + \"    </div>\", function (component) {\n            return {\n                data: function () {\n                    try {\n                        return {\n                            identificador_de_comunicacion: Castelog.metodos.un_texto_aleatorio(10, undefined),\n                            identificador_de_componente: undefined,\n                            atributos_de_componente: undefined,\n                            eventos_de_componente: undefined,\n                            promesa_de_comunicacion: undefined,\n                            promesa_exitosa: undefined,\n                            promesa_fallida: undefined\n                        };\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                },\n                methods: {\n                    resolver_comunicacion: function (datos) {\n                        try {\n                            if ((!(typeof this.promesa_exitosa === 'function'))) {\n                                console.log(\"No hay ninguna comunicación activa en este momento para «Vue.prototype.$comunicaciones.fracasar_comunicacion».\");\n                                return this.promesa_de_comunicacion;\n                            }\n                            this.promesa_exitosa(datos);\n                            this.promesa_exitosa = undefined;\n                            this.promesa_fallida = undefined;\n                            this.identificador_de_componente = undefined;\n                            this.atributos_de_componente = undefined;\n                            this.eventos_de_componente = undefined;\n                            return this.promesa_de_comunicacion;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    fracasar_comunicacion: function (error) {\n                        try {\n                            if ((!(typeof this.promesa_exitosa === 'function'))) {\n                                console.log(\"No hay ninguna comunicación activa en este momento para «Vue.prototype.$comunicaciones.fracasar_comunicacion».\");\n                                return this.promesa_de_comunicacion;\n                            }\n                            if ((!(typeof this.promesa_fallida === 'function'))) {\n                                return this.promesa_de_comunicacion;\n                            }\n                            this.promesa_fallida(error);\n                            this.promesa_exitosa = undefined;\n                            this.promesa_fallida = undefined;\n                            this.identificador_de_componente = undefined;\n                            this.atributos_de_componente = undefined;\n                            this.eventos_de_componente = undefined;\n                            this.identificador_de_comunicacion = undefined;\n                            return this.promesa_de_comunicacion;\n                        } catch (error) {\n                            console.log(error);\n                            throw error;\n                        }\n\n                    },\n                    una_entrada_de_usuario: function (componente,\n                        atributos = {\n                        },\n                        eventos = {\n                        }) {\n                            try {\n                                if (typeof this.promesa_exitosa === 'function') {\n                                    console.log(\"Ya hay una comunicación activa en este momento para «Vue.prototype.$comunicaciones.una_entrada_de_usuario» y se ha ignorado la comunicación mediante el componente «\" + componente + \"»\");\n                                    return this.promesa_de_comunicacion;\n                                }\n                                this.identificador_de_comunicacion = Castelog.metodos.un_texto_aleatorio(10, undefined);\n                                this.promesa_de_comunicacion = new Promise((ok,\n                                    fail) => {\n                                    try {\n                                        this.promesa_exitosa = ok;\n                                        this.promesa_fallida = fail;\n                                    } catch (error) {\n                                        console.log(error);\n                                        throw error;\n                                    }\n                                });\n                                this.atributos_de_componente = atributos;\n                                this.eventos_de_componente = eventos;\n                                this.identificador_de_componente = componente;\n                                return this.promesa_de_comunicacion;\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                    },\n                    una_salida_a_usuario: function (componente,\n                        atributos = {\n                        },\n                        eventos = {\n                        }) {\n                            try {\n                                if (typeof this.promesa_exitosa === 'function') {\n                                    console.log(\"Hay una comunicación activa en este momento para «Vue.prototype.$comunicaciones.una_salida_a_usuario» y se ha ignorado la comunicación mediante el componente «\" + componente + \"»\");\n                                    return this.promesa_de_comunicacion;\n                                }\n                                this.identificador_de_comunicacion = Castelog.metodos.un_texto_aleatorio(10, undefined);\n                                this.atributos_de_componente = atributos;\n                                this.eventos_de_componente = eventos;\n                                this.identificador_de_componente = componente;\n                                return this.promesa_de_comunicacion;\n                            } catch (error) {\n                                console.log(error);\n                                throw error;\n                            }\n\n                    }\n                },\n                mounted: function () {\n                    try {\n                        Vue.prototype.$comunicaciones = this;\n                    } catch (error) {\n                        console.log(error);\n                        throw error;\n                    }\n\n                }\n            };\n        }, null);\n    Vue.prototype.$Castelog = Castelog;\n    Vue.prototype.$window = window;\n    const tema = {\n    };\n    const estilos_finales = Object.assign({\n    }, {\n        estilos: Castelog.variables.estilos_en_cascada_nativos_comunes\n    }, {\n        tema: Castelog.variables.tema_de_estilos_en_cascada_nativos\n    });\n    Castelog.metodos.una_insercion_de_estilos_en_cascada(\"estilos generales\", (Castelog.metodos.una_plantilla(function (config, settings) {\n        let $plantilla = \"\";\n        $plantilla += \"\\n        body {\\n            margin: 0;\\n            padding: 2px;\\n            font-family: Roboto;\\n            font-size: 12px;\\n        }\\n        input, button, textarea, select {\\n            font-family: Roboto;\\n            font-size: 12px;\\n            \";\n        $plantilla += config.estilos.rasgos.para.espaciado_2;\n        $plantilla += \"\\n            min-width: 28px;\\n            border: 1px solid #333;\\n            background-color: #CCC;\\n            border-radius: 4pt;\\n            width: auto;\\n        }\\n        button {\\n            cursor: pointer;\\n        }\\n        * {\\n            box-sizing: border-box;\\n        }\\n        .DisposicionLineal {\\n            width: 100%;\\n            display: flex;\\n            flex-direction: row;\\n            align-items: center;\\n        }\\n        .DisposicionCuadricular > .Item {\\n            \";\n        $plantilla += config.estilos.rasgos.para.bordeado_rallado;\n        $plantilla += \"\\n        }\\n        .DisposicionLineal > .Item {\\n            align-self: center;\\n            justify-content: center;\\n        }\\n        .DisposicionCuadricular {\\n            display: grid;\\n        }\\n        .BotonDePestanya {\\n            display: inline-block;\\n            cursor: pointer;\\n        }\\n        .BotonDePestanya > .Pestanya {\\n            \";\n        $plantilla += config.estilos.rasgos.para.espaciado_2;\n        $plantilla += \"\\n            border: 1px solid #333;\\n            border-bottom: 0px solid #333;\\n            border-top-left-radius: 2pt;\\n            border-top-right-radius: 2pt;\\n            background-color: #CCC;\\n        }\\n        .BotonDePestanya.seleccionado > .Pestanya {\\n            background-color: #FFF;\\n        }\\n        .PanelDePestanya {\\n            \";\n        $plantilla += config.estilos.rasgos.para.espaciado_2;\n        $plantilla += \"\\n            display: none;\\n            border: 1px solid #333;\\n            border-bottom-left-radius: 2pt;\\n            border-bottom-right-radius: 2pt;\\n        }\\n        .PanelDePestanya.seleccionado {\\n            display: block;\\n        }\\n        .LineaHorizontal {\\n            border-top: 1px solid #333;\\n        }\\n        select.PuntoDeControl,\\n        textarea.PuntoDeControl,\\n        input.PuntoDeControl {\\n            width: 100%;\\n        }\\n        textarea.PuntoDeControl {\\n            resize: vertical;\\n            min-height: 80px;\\n        }\\n        .bordeado {\\n            \";\n        $plantilla += config.estilos.rasgos.para.bordeado;\n        $plantilla += \"\\n        }\\n        .bordeado_rallado {\\n            \";\n        $plantilla += config.estilos.rasgos.para.bordeado_rallado;\n        $plantilla += \"\\n        }\\n        .caja_de_parte_de_fecha {\\n            \";\n        $plantilla += config.estilos.rasgos.para.espaciado_2;\n        $plantilla += \"\\n            flex-grow: 1;\\n            text-align: center;\\n            font-size: 10px;\\n            white-space: nowrap;\\n        }\\n        .contenedor_de_parte_de_fecha {\\n            align-items: center;\\n            justify-content: start;\\n            margin: 2px;\\n            padding: 2px;\\n            border-radius: 2pt;\\n        }\\n        .contenedor_de_anyo_de_fecha { flex-grow: 0.5; }\\n        .contenedor_de_mes_de_fecha { flex-grow: 0.5; }\\n        .contenedor_de_dia_de_fecha { flex-grow: 0.5; }\\n        .contenedor_de_dia_semanal_de_fecha { flex-grow: 0.5; }\\n        .SoloReloj { display: none; }\\n        .SoloMovil { display: none; }\\n        .SoloTablet { display: none; }\\n        .SoloOrdenador { display: none; }\\n        .SoloTelevision { display: none; }\\n        .SoloProyector { display: none; }\\n        @media only screen and (min-width: 0px) and (max-width: 200px) {\\n            .SoloReloj { display: block; }\\n            .SoloMovil { display: none; }\\n            .SoloTablet { display: none; }\\n            .SoloOrdenador { display: none; }\\n            .SoloTelevision { display: none; }\\n            .SoloProyector { display: none; }\\n        }\\n        @media only screen and (min-width: 200px) and (max-width: 400px) {\\n            .SoloReloj { display: none; }\\n            .SoloMovil { display: block; }\\n            .SoloTablet { display: none; }\\n            .SoloOrdenador { display: none; }\\n            .SoloTelevision { display: none; }\\n            .SoloProyector { display: none; }\\n        }\\n        @media only screen and (min-width: 400px) and (max-width: 600px) {\\n            .SoloReloj { display: none; }\\n            .SoloMovil { display: none; }\\n            .SoloTablet { display: block; }\\n            .SoloOrdenador { display: none; }\\n            .SoloTelevision { display: none; }\\n            .SoloProyector { display: none; }\\n        }\\n        @media only screen and (min-width: 600px) and (max-width: 800px) {\\n            .SoloReloj { display: none; }\\n            .SoloMovil { display: none; }\\n            .SoloTablet { display: none; }\\n            .SoloOrdenador { display: block; }\\n            .SoloTelevision { display: none; }\\n            .SoloProyector { display: none; }\\n        }\\n        @media only screen and (min-width: 800px) and (max-width: 1000px) {\\n            .SoloReloj { display: none; }\\n            .SoloMovil { display: none; }\\n            .SoloTablet { display: none; }\\n            .SoloOrdenador { display: none; }\\n            .SoloTelevision { display: block; }\\n            .SoloProyector { display: none; }\\n        }\\n        @media only screen and (min-width: 1000px) {\\n            .SoloReloj { display: none; }\\n            .SoloMovil { display: none; }\\n            .SoloTablet { display: none; }\\n            .SoloOrdenador { display: none; }\\n            .SoloTelevision { display: none; }\\n            .SoloProyector { display: block; }\\n        }\\n        .no_contraer_texto {\\n            white-space: nowrap;\\n        }\\n        .disposicion_vertical {\\n            flex-direction: column;\\n            align-items: stretch;\\n        }\\n        .EtiquetaDeControl {\\n            display: block;\\n            \";\n        $plantilla += config.estilos.rasgos.para.espaciado_2;\n        $plantilla += \"\\n            padding-bottom: 0px;\\n            padding-left: 2px;\\n            border-bottom: 1px solid #CCC;\\n            font-size: 11px;\\n            font-weight: bold;\\n            margin-bottom: 4px;\\n            text-transform: none;\\n        }\\n        .cuadricula_para_panel_de_control_de_hora_a_milisegundo,\\n        .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n            grid-gap: 4px;\\n        }\\n        .cuadricula_para_panel_de_control_de_hora_a_milisegundo > div,\\n        .cuadricula_para_panel_de_control_de_anyo_a_dia > div {\\n            \";\n        $plantilla += config.estilos.rasgos.para.carta_vacia;\n        $plantilla += \"\\n        }\\n        .cuadricula_para_panel_de_control_de_hora_a_milisegundo {\\n                grid-template-columns: 1fr 1fr 1fr 1fr;\\n                grid-template-rows: 1fr;\\n        }\\n        @media only screen and (min-width: 0px) and (max-width: 200px) {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        @media only screen and (min-width: 200px) and (max-width: 400px)  {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        @media only screen and (min-width: 400px) and (max-width: 600px)  {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        @media only screen and (min-width: 600px) and (max-width: 800px)  {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr 1fr 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        @media only screen and (min-width: 800px) and (max-width: 1000px)  {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr 1fr 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        @media only screen and (min-width: 1000px)  {\\n            .cuadricula_para_panel_de_control_de_anyo_a_dia {\\n                grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n            .cuadricula_para_panel_de_control_de_hora_a_milisegundo {\\n                grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;\\n                grid-template-rows: 1fr;\\n            }\\n        }\\n        .contenedor_de_parte_de_fecha > button {\\n            width: 40px;\\n        }\\n        .Calendario { display: block; text-align: center; }\\n        .Calendario > .contenedor_de_calendario { display: inline-block; }\\n        .Calendario > .contenedor_de_calendario > table {}\\n        .Calendario > .contenedor_de_calendario > table > tr {}\\n        .Calendario > .contenedor_de_calendario > table > tr > td {\\n            background-color: #CCC;\\n            color: black;\\n            border: 1px solid #000;\\n            border-radius: 4pt;\\n            text-align: center;\\n            cursor: pointer;\\n        }\\n        .Calendario > .contenedor_de_calendario > table > tr > td.seleccionado {\\n            background-color: #333;\\n            color: white;\\n            border: 1px solid #000;\\n        }\\n        .Calendario > .contenedor_de_calendario > table > tr > td > .contenedor_de_dia_de_calendario {\\n            padding: 5px;\\n            font-size: 10px;\\n        }\\n        .Calendario > .contenedor_de_calendario > table > tr > td > .contenedor_de_dia_de_calendario > .dia_de_calendario { }\\n        .contenedor_de_hora_de_fecha {\\n            flex-direction: column;\\n        }\\n        .contenedor_de_minuto_de_fecha {\\n            flex-direction: column;\\n        }\\n        .contenedor_de_segundo_de_fecha {\\n            flex-direction: column;\\n        }\\n        .contenedor_de_milisegundo_de_fecha {\\n            flex-direction: column;\\n        }\\n        .girado_de_derecha_a_abajo {\\n            display: inline-block;\\n            transform: rotate(90deg);\\n        }\\n        .girado_de_izquierda_a_arriba {\\n            display: inline-block;\\n            transform: rotate(90deg);\\n        }\\n        @media only screen and (min-width: 800px) and (max-width: 1000px)  {\\n            .contenedor_de_hora_de_fecha,\\n            .contenedor_de_minuto_de_fecha,\\n            .contenedor_de_segundo_de_fecha,\\n            .contenedor_de_milisegundo_de_fecha {\\n                flex-direction: row-reverse;\\n            }\\n            .girado_de_derecha_a_abajo {\\n                transform: rotate(180deg);\\n            }\\n            .girado_de_izquierda_a_arriba {\\n                transform: rotate(180deg);\\n            }\\n        }\\n        @media only screen and (min-width: 1000px)  {\\n            .contenedor_de_hora_de_fecha,\\n            .contenedor_de_minuto_de_fecha,\\n            .contenedor_de_segundo_de_fecha,\\n            .contenedor_de_milisegundo_de_fecha {\\n                flex-direction: row;\\n            }\\n            .girado_de_derecha_a_abajo {\\n                transform: rotate(0deg);\\n            }\\n            .girado_de_izquierda_a_arriba {\\n                transform: rotate(0deg);\\n            }\\n        }\\n        .importancia_2 {\\n            color: #444;\\n            text-transform: uppercase;\\n            font-size: 8px;\\n        }\\n        .boton_de_expandir_control {\\n            padding: 5px;\\n            font-size: 9px;\\n            margin-bottom: 2px;\\n        }\\n        .contenedor_de_comunicaciones {\\n            position: fixed;\\n            top: 0;\\n            left: 0;\\n            right: 0;\\n            bottom: 0;\\n            background-color: rgba(255,255,255,0.5);\\n        }\\n        .panel_de_comunicaciones {\\n            \\n        }\\n        .ControlParaColor {\\n            padding: 0;\\n        }\\n        \";\n        for (const prop in config.estilos.rasgos.para) {\n\n            $plantilla += (function (config, settings) {\n                let $plantilla = \"\";\n                $plantilla += \"\\n                .\";\n                $plantilla += prop;\n                $plantilla += \" {\\n                    \";\n                $plantilla += config.estilos.rasgos.para[prop];\n                $plantilla += \"\\n                }\\n                \";\n                return $plantilla;\n            })((typeof config === \"object\") ? config : {}, (typeof settings === \"object\") ? settings : {})\n        }\n\n        $plantilla += \"\\n        .imagen_de_fichero {\\n            width: 100%;\\n            margin-top: 5px;\\n            margin-bottom: 5px;\\n            box-shadow: 0 0 4px black;\\n        }\\n        .oculto {\\n            display: none;\\n        }\\n    \";\n        return $plantilla;\n    })((estilos_finales))));\n    Castelog.metodos.una_insercion_de_estilos_en_cascada(\"estilos de windows 7 (así no te calientas la cabeza)\", (Castelog.metodos.una_plantilla(function (config, settings) {\n        let $plantilla = \"\";\n        $plantilla += \"\\n/*! 7.css v0.11.0 - https://khang-nd.github.io/7.css */\\nbody.win7 {\\n\\tcolor: #222;\\n\\tfont-family: Arial;\\n\\tfont-size: 12px\\n}\\n\\n.surface.win7 {\\n\\tbackground: #f0f0f0\\n}\\n\\n.win7 h1 {\\n\\tfont-size: 5rem\\n}\\n\\n.win7 h2 {\\n\\tfont-size: 2.5rem\\n}\\n\\n.win7 h3 {\\n\\tfont-size: 2rem\\n}\\n\\n.win7 h4 {\\n\\tfont-size: 1.5rem\\n}\\n\\n.win7 u {\\n\\tborder-bottom: .5px solid #222;\\n\\ttext-decoration: none\\n}\\n\\n.win7 code,\\n.win7 code * {\\n\\tfont-family: monospace\\n}\\n\\n.win7 pre {\\n\\tbackground: #fff;\\n\\tborder: 1px solid #8e8f8f;\\n\\tdisplay: block;\\n\\tmargin: 0;\\n\\tpadding: 12px 8px\\n}\\n\\n.win7 summary:focus {\\n\\toutline: 1px dotted #000\\n}\\n\\n.win7 ::-webkit-scrollbar {\\n\\twidth: 16px\\n}\\n\\n.win7 ::-webkit-scrollbar:horizontal {\\n\\theight: 17px\\n}\\n\\n.win7 ::-webkit-scrollbar-corner {\\n\\tbackground: #eee\\n}\\n\\n.win7 ::-webkit-scrollbar-track:vertical {\\n\\tbackground: linear-gradient(90deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-track:horizontal {\\n\\tbackground: linear-gradient(180deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb {\\n\\tbackground-color: #eee;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 1px hsla(0, 0%, 100%, .8), inset 0 1px 1px #fff\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:vertical {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAKCAIAAADpZ+PpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADrSURBVChTTc5LboJQGAXguyoCu4ERCzAGlRk7UOwGWIDh0s4M4kxb06RSq/jAB6AxJkJ4lTDrue3AnvyzP+fLId+/yfM8juP7PQmCCOf7B3e+ZD+O40RRVFW12VQUpd3r9U3T2m4OpKoqWZYNwzBZLEqfh0N7NnvfrPcEWlEUWZb9mWF4Ph6D0ylcLbfM5HkeJrhGA2hb15/QXnv+w7RYXsDatjOdvnmrHSnLEizMNE2v11sUXQBCnn98kbquBUGQJAlmq9WB2e3qg4HJdqKkaRql1HGc0WgMcDJ5dd0F24kediZJ8t/ELT69H+8py0CYSIO5AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(90deg, #eee 45%, #ddd 0, #bbb)\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:horizontal {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADcSURBVChTNZBLqoUwEEQrURQUxZGCvy24ACfiityJi7tv8GauQoPxk5tquA2RQ9vVVYk6z9NZaxFFEe77htYazjk8z4MwDIVZ+rourOuKaZrwvi+WZcE8z1BKCbPPCjk4DAO2bRP1OI7wLiL6Mbd7J408z1GWpQwWRYGqqiQG+03TgMu0MacfUN4qANmn8UOv9MjW3sKaSm7iIdOSlziOQ3LScd93aPonSYK6riVLlmVo21aYfVqzND9pmqLrOlGT+76XbcxLZkb19/l3fEP+oF0cx8KMEASBsDEGX2/CgZCHkg+8AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(180deg, #eee 45%, #ddd 0, #bbb)\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:hover:vertical {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAKCAIAAADpZ+PpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADrSURBVChTTc5LboJQGAXguyoCu4ERCzAGlRk7UOwGWIDh0s4M4kxb06RSq/jAB6AxJkJ4lTDrue3AnvyzP+fLId+/yfM8juP7PQmCCOf7B3e+ZD+O40RRVFW12VQUpd3r9U3T2m4OpKoqWZYNwzBZLEqfh0N7NnvfrPcEWlEUWZb9mWF4Ph6D0ylcLbfM5HkeJrhGA2hb15/QXnv+w7RYXsDatjOdvnmrHSnLEizMNE2v11sUXQBCnn98kbquBUGQJAlmq9WB2e3qg4HJdqKkaRql1HGc0WgMcDJ5dd0F24kediZJ8t/ELT69H+8py0CYSIO5AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(90deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:hover:horizontal {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADcSURBVChTNZBLqoUwEEQrURQUxZGCvy24ACfiityJi7tv8GauQoPxk5tquA2RQ9vVVYk6z9NZaxFFEe77htYazjk8z4MwDIVZ+rourOuKaZrwvi+WZcE8z1BKCbPPCjk4DAO2bRP1OI7wLiL6Mbd7J408z1GWpQwWRYGqqiQG+03TgMu0MacfUN4qANmn8UOv9MjW3sKaSm7iIdOSlziOQ3LScd93aPonSYK6riVLlmVo21aYfVqzND9pmqLrOlGT+76XbcxLZkb19/l3fEP+oF0cx8KMEASBsDEGX2/CgZCHkg+8AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(180deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:active:vertical {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAKCAIAAADpZ+PpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADrSURBVChTTc5LboJQGAXguyoCu4ERCzAGlRk7UOwGWIDh0s4M4kxb06RSq/jAB6AxJkJ4lTDrue3AnvyzP+fLId+/yfM8juP7PQmCCOf7B3e+ZD+O40RRVFW12VQUpd3r9U3T2m4OpKoqWZYNwzBZLEqfh0N7NnvfrPcEWlEUWZb9mWF4Ph6D0ylcLbfM5HkeJrhGA2hb15/QXnv+w7RYXsDatjOdvnmrHSnLEizMNE2v11sUXQBCnn98kbquBUGQJAlmq9WB2e3qg4HJdqKkaRql1HGc0WgMcDJ5dd0F24kediZJ8t/ELT69H+8py0CYSIO5AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(90deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 ::-webkit-scrollbar-thumb:active:horizontal {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADcSURBVChTNZBLqoUwEEQrURQUxZGCvy24ACfiityJi7tv8GauQoPxk5tquA2RQ9vVVYk6z9NZaxFFEe77htYazjk8z4MwDIVZ+rourOuKaZrwvi+WZcE8z1BKCbPPCjk4DAO2bRP1OI7wLiL6Mbd7J408z1GWpQwWRYGqqiQG+03TgMu0MacfUN4qANmn8UOv9MjW3sKaSm7iIdOSlziOQ3LScd93aPonSYK6riVLlmVo21aYfVqzND9pmqLrOlGT+76XbcxLZkb19/l3fEP+oF0cx8KMEASBsDEGX2/CgZCHkg+8AAAAAElFTkSuQmCC\\\") no-repeat 50%, linear-gradient(180deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 ::-webkit-scrollbar-button:horizontal:end:increment,\\n.win7 ::-webkit-scrollbar-button:horizontal:start:decrement,\\n.win7 ::-webkit-scrollbar-button:vertical:end:increment,\\n.win7 ::-webkit-scrollbar-button:vertical:start:decrement {\\n\\tdisplay: block\\n}\\n\\n.win7 ::-webkit-scrollbar-button {\\n\\tborder: 1px solid #0000\\n}\\n\\n.win7 ::-webkit-scrollbar-button:vertical {\\n\\theight: 17px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:vertical:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik04IDZIN3YxSDZ2MUg1djFINHYxaDdWOWgtMVY4SDlWN0g4VjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-button:vertical:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-button:horizontal {\\n\\twidth: 16px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:horizontal:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik05IDRIOHYxSDd2MUg2djFINXYxaDF2MWgxdjFoMXYxaDFWNFoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=\\\"), linear-gradient(180deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-button:horizontal:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik03IDRINnY3aDF2LTFoMVY5aDFWOGgxVjdIOVY2SDhWNUg3VjRaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #e5e5e5, #f0f0f0 20%)\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover {\\n\\tbackground-color: #eee;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 1px hsla(0, 0%, 100%, .8), inset 0 1px 1px #fff\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:vertical {\\n\\theight: 17px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:vertical:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik04IDZIN3YxSDZ2MUg1djFINHYxaDdWOWgtMVY4SDlWN0g4VjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:vertical:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:horizontal {\\n\\twidth: 16px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:horizontal:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik05IDRIOHYxSDd2MUg2djFINXYxaDF2MWgxdjFoMXYxaDFWNFoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=\\\"), linear-gradient(180deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-button:hover:horizontal:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik03IDRINnY3aDF2LTFoMVY5aDFWOGgxVjdIOVY2SDhWNUg3VjRaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active {\\n\\tbackground-color: #eee;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 1px hsla(0, 0%, 100%, .8), inset 0 1px 1px #fff\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:vertical {\\n\\theight: 17px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:vertical:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik04IDZIN3YxSDZ2MUg1djFINHYxaDdWOWgtMVY4SDlWN0g4VjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:vertical:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(90deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:horizontal {\\n\\twidth: 16px\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:horizontal:start {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik05IDRIOHYxSDd2MUg2djFINXYxaDF2MWgxdjFoMXYxaDFWNFoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=\\\"), linear-gradient(180deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 ::-webkit-scrollbar-button:active:horizontal:end {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIxMDAlIiB4Mj0iMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik03IDRINnY3aDF2LTFoMVY5aDFWOGgxVjdIOVY2SDhWNUg3VjRaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab\\n}\\n\\n.win7 [role=tooltip] {\\n\\tbackground: linear-gradient(180deg, #fff, #ddd);\\n\\tborder: 1px solid rgba(0, 0, 0, .4);\\n\\tborder-radius: 3px;\\n\\tbox-shadow: 5px 5px 3px -3px rgba(0, 0, 0, .4);\\n\\tpadding: 1em 1em 1em 2.5em;\\n\\tposition: relative\\n}\\n\\n.win7 [role=tooltip]:before {\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTS41IDEuNXYxOGgxOGwtMTgtMThaIiBmaWxsPSIjZmZmIiBzdHJva2U9IiNmZmYiLz48cGF0aCBkPSJNMSAxOS41SC41di0xOGwxOCAxOEgxOCIgc3Ryb2tlPSIjOTM5MzkzIi8+PC9zdmc+\\\");\\n\\tcontent: \\\"\\\";\\n\\theight: 18px;\\n\\tleft: 1em;\\n\\tposition: absolute;\\n\\ttop: -18px;\\n\\twidth: 18px\\n}\\n\\n.win7 [role=tooltip][id] {\\n\\tposition: absolute\\n}\\n\\n.win7 [role=button],\\n.win7 button {\\n\\tbackground: linear-gradient(180deg, #eee 45%, #ddd 0, #bbb);\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 1px hsla(0, 0%, 100%, .8), inset 0 1px 1px #fff;\\n\\tbox-sizing: border-box;\\n\\tcolor: #222;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tmin-height: 23px;\\n\\tmin-width: 75px;\\n\\tpadding: 0 12px;\\n\\ttext-align: center\\n}\\n\\n.win7 [role=button]:disabled,\\n.win7 button:disabled {\\n\\tbackground: #f4f4f4;\\n\\tborder-color: #aeb2b5;\\n\\tcolor: #838383\\n}\\n\\n.win7 [role=button]:not(:disabled):hover,\\n.win7 button:not(:disabled):hover {\\n\\tbackground: linear-gradient(180deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 [role=button]:not(:disabled).active,\\n.win7 [role=button]:not(:disabled):active,\\n.win7 button:not(:disabled).active,\\n.win7 button:not(:disabled):active {\\n\\tbackground: linear-gradient(180deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab;\\n\\tbox-shadow: none\\n}\\n\\n.win7 [role=button].focused,\\n.win7 [role=button]:focus,\\n.win7 button.focused,\\n.win7 button:focus {\\n\\tbox-shadow: inset 0 0 0 2px #86c6e8;\\n\\toutline: 1px dotted #000;\\n\\toutline-offset: -4px\\n}\\n\\n.win7 [role=button].default,\\n.win7 button.default {\\n\\tbackground: linear-gradient(180deg, #eee 45%, #c3dcea 0);\\n\\tborder-color: #5586a3;\\n\\tbox-shadow: inset 0 0 0 1px #34deff\\n}\\n\\n.win7 input[type=checkbox] {\\n\\tappearance: none;\\n\\t-webkit-appearance: none;\\n\\t-moz-appearance: none;\\n\\tbackground: none;\\n\\tborder: none;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tmargin: 0;\\n\\topacity: 0\\n}\\n\\n.win7 input[type=checkbox]+label {\\n\\talign-items: center;\\n\\tdisplay: inline-flex;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tmargin-left: 0;\\n\\tposition: relative\\n}\\n\\n.win7 input[type=checkbox]+label:before {\\n\\tbackground: #f6f6f6;\\n\\tborder: 1px solid #8e8f8f;\\n\\tbox-shadow: inset 0 0 0 1px #f4f4f4, inset 1px 1px 0 1px #aeaeae, inset -1px -1px 0 1px #ddd, inset 3px 3px 6px #ccc;\\n\\tbox-sizing: border-box;\\n\\tcontent: \\\"\\\";\\n\\tdisplay: inline-block;\\n\\theight: 14px;\\n\\tmargin-right: 6px;\\n\\ttransition: .4s;\\n\\twidth: 14px\\n}\\n\\n.win7 input[type=checkbox]+label:hover:before {\\n\\tbackground: #e9f7fe;\\n\\tborder-color: #3c7fb1;\\n\\tbox-shadow: inset 0 0 0 1px #def9fa, inset 1px 1px 0 1px #79c6f9, inset -1px -1px 0 1px #c6e9fc, inset 3px 3px 6px #b1dffd\\n}\\n\\n.win7 input[type=checkbox]:focus+label {\\n\\toutline: 1px dotted #000\\n}\\n\\n.win7 input[type=checkbox]:checked+label:after {\\n\\tcolor: #4a5f97;\\n\\tcontent: \\\"\\\\2714\\\";\\n\\tdisplay: block;\\n\\tfont-weight: 700;\\n\\tleft: 2px;\\n\\tposition: absolute;\\n\\ttop: 0\\n}\\n\\n.win7 input[type=checkbox]:disabled+label {\\n\\topacity: .6\\n}\\n\\n.win7 details {\\n\\tmargin-top: 0\\n}\\n\\n.win7 details>summary {\\n\\tcursor: pointer;\\n\\tdisplay: inline;\\n\\tmargin-bottom: 0;\\n\\tposition: relative\\n}\\n\\n.win7 details>summary:before {\\n\\tborder: 5px solid transparent;\\n\\tborder-left-color: #000;\\n\\tborder-radius: 3px;\\n\\tcontent: \\\"\\\";\\n\\tposition: absolute;\\n\\tright: 100%;\\n\\ttop: calc(50% - 5px)\\n}\\n\\n.win7 details[open]>summary:before {\\n\\ttop: calc(50% - 2.5px);\\n\\ttransform: rotate(45deg)\\n}\\n\\n.win7 .combobox {\\n\\tdisplay: inline-block;\\n\\tposition: relative\\n}\\n\\n.win7 .combobox input[type=text] {\\n\\tpadding-right: 20px;\\n\\twidth: 100%\\n}\\n\\n.win7 .combobox button {\\n\\tborder-bottom-left-radius: 0;\\n\\tborder-top-left-radius: 0;\\n\\tmin-width: 16px;\\n\\tpadding: 0;\\n\\tposition: absolute;\\n\\tright: 0\\n}\\n\\n.win7 .combobox button:before {\\n\\tborder: 4px solid transparent;\\n\\tborder-radius: 2px;\\n\\tborder-top-color: #000;\\n\\tcontent: \\\"\\\";\\n\\tleft: calc(50% - 4px);\\n\\tposition: absolute;\\n\\ttop: calc(50% - 1px)\\n}\\n\\n.win7 .combobox button:focus {\\n\\tbox-shadow: none;\\n\\toutline: none\\n}\\n\\n.win7 select:not([multiple]) {\\n\\t-webkit-appearance: none;\\n\\t-moz-appearance: none;\\n\\tappearance: none;\\n\\tbackground: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #eee 45%, #ddd 0, #bbb);\\n\\tbackground-position: 100%;\\n\\tbackground-repeat: no-repeat;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 1px hsla(0, 0%, 100%, .8), inset 0 1px 1px #fff;\\n\\tbox-sizing: border-box;\\n\\tcolor: #222;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tpadding: 2px 30px 2px 3px;\\n\\tposition: relative\\n}\\n\\n.win7 select:not([multiple]):hover {\\n\\tbackground-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #e5f4fd 45%, #b3e0f9 0);\\n\\tborder-color: #3c7fb1\\n}\\n\\n.win7 select:not([multiple]):focus {\\n\\tbackground-image: url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzMzMztzdG9wLW9wYWNpdHk6MSIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2FhYTtzdG9wLW9wYWNpdHk6MSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0xMSA2SDR2MWgxdjFoMXYxaDF2MWgxVjloMVY4aDFWN2gxVjZaIiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+\\\"), linear-gradient(180deg, #cee9f8 45%, #86c6e8 0);\\n\\tborder-color: #6d91ab;\\n\\tbox-shadow: unset;\\n\\toutline: none\\n}\\n\\n.win7 fieldset {\\n\\tborder: 1px solid #cdd7db;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 0 0 1px #fff;\\n\\tmargin: 0;\\n\\tpadding: 10px;\\n\\t-webkit-padding-before: 8px;\\n\\tpadding-block-start: 8px\\n}\\n\\n.win7 fieldset legend {\\n\\tfont: 9pt Segoe UI, sans-serif\\n}\\n\\n.win7 .field-row {\\n\\talign-items: center;\\n\\tdisplay: flex\\n}\\n\\n.win7 .field-row>*+* {\\n\\tmargin-left: 6px\\n}\\n\\n.win7 .field-row-stacked {\\n\\tdisplay: flex;\\n\\tflex-direction: column\\n}\\n\\n.win7 .field-row-stacked *+*,\\n.win7 [class^=field-row]+[class^=field-row] {\\n\\tmargin-top: 6px\\n}\\n\\n.win7 [role=listbox],\\n.win7 select[multiple] {\\n\\tbackground: #fff;\\n\\tborder: 1px solid #c0c1cd;\\n\\tdisplay: block;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\toverflow-y: scroll\\n}\\n\\n.win7 [role=listbox].has-shadow,\\n.win7 select[multiple].has-shadow {\\n\\tbox-shadow: 4px 4px 3px -2px #999\\n}\\n\\n.win7 [role=listbox].has-hover li:hover,\\n.win7 select[multiple].has-hover li:hover {\\n\\tbackground-color: #2a90ff;\\n\\tcolor: #fff\\n}\\n\\n.win7 [role=listbox]:focus,\\n.win7 select[multiple]:focus {\\n\\toutline: none\\n}\\n\\n.win7 [role=listbox] [role=option],\\n.win7 [role=listbox] option,\\n.win7 select[multiple] [role=option],\\n.win7 select[multiple] option {\\n\\tpadding: 2px\\n}\\n\\n.win7 [role=listbox] [role=option]:focus,\\n.win7 [role=listbox] [role=option][aria-selected],\\n.win7 [role=listbox] option:focus,\\n.win7 [role=listbox] option[aria-selected],\\n.win7 select[multiple] [role=option]:focus,\\n.win7 select[multiple] [role=option][aria-selected],\\n.win7 select[multiple] option:focus,\\n.win7 select[multiple] option[aria-selected] {\\n\\tbackground-color: #2a90ff;\\n\\tcolor: #fff\\n}\\n\\n.win7 ul[role] {\\n\\tcursor: default;\\n\\tlist-style: none;\\n\\tmargin: 0;\\n\\tpadding: 0\\n}\\n\\n.win7 ul[role=menubar] {\\n\\tbackground: linear-gradient(#fff 20%, #f1f4fa 25%, #f1f4fa 43%, #d4dbee 48%, #e6eaf6);\\n\\tdisplay: flex\\n}\\n\\n.win7 ul[role=menubar]>[role=menuitem] {\\n\\tpadding: 6px 10px;\\n\\tposition: relative\\n}\\n\\n.win7 ul[role=menubar]>[role=menuitem]:focus,\\n.win7 ul[role=menubar]>[role=menuitem]:focus-within,\\n.win7 ul[role=menubar]>[role=menuitem]:hover {\\n\\tbackground: #39f;\\n\\tcolor: #fff;\\n\\toutline: none\\n}\\n\\n.win7 ul[role=menu] {\\n\\tbackground: #f0f0f0;\\n\\tborder: 1px solid rgba(0, 0, 0, .4);\\n\\tbox-shadow: 4px 4px 3px -2px rgba(0, 0, 0, .5);\\n\\tcolor: initial;\\n\\tmin-width: 150px;\\n\\tpadding: 2px;\\n\\tposition: relative\\n}\\n\\n.win7 ul[role=menu]:before {\\n\\tbox-shadow: inset 1px 0 rgba(0, 0, 0, .15), inset -1px 0 #fff;\\n\\tcontent: \\\"\\\";\\n\\theight: calc(100% - 4px);\\n\\tleft: 30px;\\n\\tpointer-events: none;\\n\\tposition: absolute;\\n\\twidth: 2px\\n}\\n\\n.win7 [role=menuitem] ul[role=menu] {\\n\\tdisplay: none;\\n\\tleft: 0;\\n\\tposition: absolute;\\n\\ttop: 100%;\\n\\tz-index: 99\\n}\\n\\n.win7 ul[role=menu] [role=menuitem]>[role=menu] {\\n\\tleft: 100%;\\n\\ttop: -4px\\n}\\n\\n.win7 ul[role=menu]>[role=menuitem]>a,\\n.win7 ul[role=menu]>[role=menuitem]>button,\\n.win7 ul[role=menu]>[role=menuitem]>label,\\n.win7 ul[role=menu]>[role=menuitem][aria-haspopup=true] {\\n\\tall: unset;\\n\\tborder: 1px solid transparent;\\n\\tborder-radius: 3px;\\n\\tbox-sizing: border-box;\\n\\tdisplay: flex;\\n\\tjustify-content: space-between;\\n\\tpadding: 4px 10px 4px 32px;\\n\\tposition: relative;\\n\\twhite-space: nowrap;\\n\\twidth: 100%\\n}\\n\\n.win7 ul[role=menu]>[role=menuitem]>a:focus,\\n.win7 ul[role=menu]>[role=menuitem]>a:hover,\\n.win7 ul[role=menu]>[role=menuitem]>button:focus,\\n.win7 ul[role=menu]>[role=menuitem]>button:hover,\\n.win7 ul[role=menu]>[role=menuitem]>label:focus,\\n.win7 ul[role=menu]>[role=menuitem]>label:hover,\\n.win7 ul[role=menu]>[role=menuitem][aria-haspopup=true]:focus,\\n.win7 ul[role=menu]>[role=menuitem][aria-haspopup=true]:hover {\\n\\tbackground: linear-gradient(180deg, hsla(0, 0%, 100%, .6), rgba(230, 236, 245, .8) 90%, hsla(0, 0%, 100%, .8));\\n\\tborder-color: #b8d6fb\\n}\\n\\n.win7 ul[role=menu]>[role=menuitem][aria-haspopup=true]:after {\\n\\tborder: 4px solid transparent;\\n\\tborder-left-color: currentcolor;\\n\\tcontent: \\\"\\\";\\n\\tposition: absolute;\\n\\tright: 2px;\\n\\ttop: 50%;\\n\\ttransform: translateY(-50%)\\n}\\n\\n.win7 ul [role=menuitem] {\\n\\tposition: relative\\n}\\n\\n.win7 ul [role=menuitem]>input[type] {\\n\\tdisplay: none\\n}\\n\\n.win7 ul [role=menuitem]>input[type]+label {\\n\\tdisplay: block;\\n\\tposition: relative\\n}\\n\\n.win7 ul [role=menuitem]>input[type]+label:before {\\n\\tall: unset;\\n\\tbackground: linear-gradient(180deg, hsla(0, 0%, 100%, .6), rgba(230, 236, 245, .8) 90%, hsla(0, 0%, 100%, .8));\\n\\tborder-radius: inherit;\\n\\tbox-shadow: 0 0 0 1px #b3d3f9;\\n\\tbox-sizing: border-box;\\n\\theight: 22px;\\n\\tleft: 0;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\twidth: 22px\\n}\\n\\n.win7 ul [role=menuitem]>input[type]:checked+label:before {\\n\\tcontent: \\\"\\\"\\n}\\n\\n.win7 ul [role=menuitem]>input[type][type=radio]:checked+label:after {\\n\\tbackground: radial-gradient(circle at 75% 25%, #d5d4ea, #333583);\\n\\tborder: 1px solid #1a1490;\\n\\tbox-shadow: none;\\n\\tleft: 8px;\\n\\ttop: 50%;\\n\\ttransform: translateY(-50%)\\n}\\n\\n.win7 ul [role=menuitem]>input[type][type=checkbox]:checked+label:after {\\n\\tcolor: #0c12a1;\\n\\tfont-size: 10pt;\\n\\tleft: 6px;\\n\\ttop: 50%;\\n\\ttransform: translateY(-52%)\\n}\\n\\n.win7 ul [role=menuitem]:focus-within>[role=menu],\\n.win7 ul [role=menuitem]:focus>[role=menu] {\\n\\tdisplay: block\\n}\\n\\n.win7 ul [role=menuitem][aria-disabled] {\\n\\topacity: .5;\\n\\tpointer-events: none\\n}\\n\\n.win7 ul [role=menuitem].has-divider:after {\\n\\tbox-shadow: inset 0 1px rgba(0, 0, 0, .15), inset 0 -1px #fff;\\n\\tcontent: \\\"\\\";\\n\\tdisplay: block;\\n\\theight: 2px;\\n\\tmargin: 3px 0 2px 30px;\\n\\tpointer-events: none\\n}\\n\\n.win7 ul [role=menuitem] img {\\n\\tleft: 2px;\\n\\tpointer-events: none;\\n\\tposition: absolute;\\n\\ttop: 50%;\\n\\ttransform: translateY(-50%);\\n\\tz-index: 1\\n}\\n\\n.win7 ul [role=menuitem] span {\\n\\tmargin-left: 32px\\n}\\n\\n.win7 ul.can-hover [role=menuitem]:hover>[role=menu] {\\n\\tdisplay: block\\n}\\n\\n.win7 [role=progressbar] {\\n\\tbackground: linear-gradient(90deg, rgba(0, 0, 0, .1), transparent 20%, transparent 80%, rgba(0, 0, 0, .1)), linear-gradient(180deg, hsla(0, 0%, 100%, .6) 25%, rgba(0, 0, 0, .05) 35%, rgba(0, 0, 0, .05) 90%, hsla(0, 0%, 100%, .2) 95%), #ddd;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 0 2px #fff, 0 0 2px #aaa;\\n\\theight: 15px;\\n\\tmargin: 2px 0;\\n\\toverflow: hidden\\n}\\n\\n.win7 [role=progressbar]>div {\\n\\tbackground-color: #0bd82c;\\n\\tbackground-image: linear-gradient(90deg, rgba(0, 0, 0, .2), transparent 20%, transparent 80%, rgba(0, 0, 0, .2)), linear-gradient(180deg, hsla(0, 0%, 100%, .6) 30%, rgba(0, 0, 0, .05) 0, rgba(0, 0, 0, .05) 90%, hsla(0, 0%, 100%, .2) 95%);\\n\\tbox-shadow: inset 0 0 1px #fff;\\n\\theight: 100%;\\n\\toverflow: hidden\\n}\\n\\n.win7 [role=progressbar].paused>div {\\n\\tbackground-color: #e6df1b\\n}\\n\\n.win7 [role=progressbar].error>div {\\n\\tbackground-color: #ef0000\\n}\\n\\n.win7 [role=progressbar].animate>div:before,\\n.win7 [role=progressbar].marquee:before {\\n\\tanimation: progressbar 3s linear infinite;\\n\\tbackground: linear-gradient(90deg, transparent, hsla(0, 0%, 100%, .5), transparent 40%);\\n\\tcontent: \\\"\\\";\\n\\tdisplay: block;\\n\\theight: 100%\\n}\\n\\n.win7 [role=progressbar].marquee:before {\\n\\tbackground: linear-gradient(90deg, transparent, #0bd82c, transparent 35%);\\n\\topacity: .5\\n}\\n\\n@keyframes progressbar {\\n\\t0% {\\n\\t\\ttransform: translateX(-40%)\\n\\t}\\n\\n\\t60% {\\n\\t\\ttransform: translateX(100%)\\n\\t}\\n\\n\\tto {\\n\\t\\ttransform: translateX(100%)\\n\\t}\\n}\\n\\n.win7 input[type=radio] {\\n\\tappearance: none;\\n\\t-webkit-appearance: none;\\n\\t-moz-appearance: none;\\n\\tbackground: 0;\\n\\tborder: none;\\n\\tmargin: 0;\\n\\topacity: 0;\\n\\tposition: fixed\\n}\\n\\n.win7 input[type=radio]+label {\\n\\talign-items: center;\\n\\tdisplay: inline-flex;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tmargin-left: 20px;\\n\\tposition: relative\\n}\\n\\n.win7 input[type=radio]+label:before {\\n\\tbackground: #f6f6f6;\\n\\tborder: 1px solid #8e8f8f;\\n\\tborder-radius: 50%;\\n\\tbox-shadow: inset 0 0 0 1.5px #f4f4f4, inset 1px 1px 0 1.5px #aeaeae, inset -1px 0 0 1.5px #ddd, inset 3px 3px 6px #ccc;\\n\\tbox-sizing: border-box;\\n\\tcontent: \\\"\\\";\\n\\tdisplay: inline-block;\\n\\theight: 14px;\\n\\tleft: -20px;\\n\\tmargin-right: 6px;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\ttransition: .4s;\\n\\twidth: 14px\\n}\\n\\n.win7 input[type=radio]+label:hover:before {\\n\\tborder-color: #3c7fb1;\\n\\tbox-shadow: inset 0 0 0 1.5px #def9fa, inset 1px 1px 0 1.5px #79c6f9, inset -1px -1px 0 1.5px #c6e9fc, inset 3px 3px 6px #b1dffd\\n}\\n\\n.win7 input[type=radio]:checked+label:after {\\n\\tbackground: #7cd3eb;\\n\\tborder: 1.5px solid #27506d;\\n\\tborder-radius: 50%;\\n\\tbox-shadow: inset -1px -1px 0 .5px #16638f, inset -1px -1px 0 1px #1985c0;\\n\\tbox-sizing: border-box;\\n\\tcontent: \\\"\\\";\\n\\tdisplay: block;\\n\\theight: 8px;\\n\\tleft: -17px;\\n\\tposition: absolute;\\n\\ttop: 3px;\\n\\twidth: 8px\\n}\\n\\n.win7 input[type=radio]:focus+label {\\n\\toutline: 1px dotted #000\\n}\\n\\n.win7 input[type=radio]:disabled+label {\\n\\topacity: .6\\n}\\n\\n.win7 input[type=range] {\\n\\t-webkit-appearance: none;\\n\\t-moz-appearance: none;\\n\\tappearance: none;\\n\\tbackground: transparent;\\n\\twidth: 100%\\n}\\n\\n.win7 input[type=range]:focus {\\n\\toutline: none\\n}\\n\\n.win7 input[type=range]::-webkit-slider-thumb {\\n\\t-webkit-appearance: none;\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAC7SURBVHgBlZLBCYQwEEVj9CDYgRfbswF7sRAbsArPdhBICDmEzPoDE9CdXeKH0eHP48fINOrSPM+k/mhd16YDtCyLmqZJhM7zxIs6PAF570WQAzJIRLkksd89DUl939eB1Ym3b0wpiQBmIYSXiTFGZYwRgWEY6o8uIPQLZGlu2rYtP54L3g3c912N45gHSEahh4dZERZj2zZyztFxHLnQw/vaLIattbmeULkMdg6XxLFaa3WB7MlCirTIHxVUkxicbwSEAAAAAElFTkSuQmCC\\\");\\n\\theight: 18px;\\n\\ttransform: translateY(-7px);\\n\\twidth: 10px\\n}\\n\\n.win7 input[type=range]::-webkit-slider-thumb:active {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACsSURBVHgB3ZKxCoMwEIYvJWOn0r10LHTuVDp1KIU+RN+gT9FZ6AP0LYqDY+nQWXAScXMQdRYh+ouRqEF0cPGHHJfcl7sbfkaFroYlqEefx5lxQK/blu6rjRZ6R34RLcFxAWSkmRZEbUkeLWigZgVymZhuoid264lGjwMvTkhmtYsqvKEGMQQY43jYNwoy//7t0j31b8DPXyBOcVYe5Kr9mDpKdoY6ndoCrDNyDnRZRNbxQWFyAAAAAElFTkSuQmCC\\\")\\n}\\n\\n.win7 input[type=range]::-moz-range-thumb {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAC7SURBVHgBlZLBCYQwEEVj9CDYgRfbswF7sRAbsArPdhBICDmEzPoDE9CdXeKH0eHP48fINOrSPM+k/mhd16YDtCyLmqZJhM7zxIs6PAF570WQAzJIRLkksd89DUl939eB1Ym3b0wpiQBmIYSXiTFGZYwRgWEY6o8uIPQLZGlu2rYtP54L3g3c912N45gHSEahh4dZERZj2zZyztFxHLnQw/vaLIattbmeULkMdg6XxLFaa3WB7MlCirTIHxVUkxicbwSEAAAAAElFTkSuQmCC\\\");\\n\\tborder: 0;\\n\\tborder-radius: 0;\\n\\theight: 18px;\\n\\twidth: 10px\\n}\\n\\n.win7 input[type=range]::-moz-range-thumb:active {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACsSURBVHgB3ZKxCoMwEIYvJWOn0r10LHTuVDp1KIU+RN+gT9FZ6AP0LYqDY+nQWXAScXMQdRYh+ouRqEF0cPGHHJfcl7sbfkaFroYlqEefx5lxQK/blu6rjRZ6R34RLcFxAWSkmRZEbUkeLWigZgVymZhuoid264lGjwMvTkhmtYsqvKEGMQQY43jYNwoy//7t0j31b8DPXyBOcVYe5Kr9mDpKdoY6ndoCrDNyDnRZRNbxQWFyAAAAAElFTkSuQmCC\\\")\\n}\\n\\n.win7 input[type=range]::-webkit-slider-runnable-track {\\n\\tbackground: #f0f0f0;\\n\\tbox-shadow: inset 1px 1px 1px #999, inset -1px 0 #999, 0 1px #fff;\\n\\tbox-sizing: border-box;\\n\\theight: 3px;\\n\\twidth: 100%\\n}\\n\\n.win7 input[type=range]::-moz-range-track {\\n\\tbackground: #f0f0f0;\\n\\tbox-shadow: inset 1px 1px 1px #999, inset -1px 0 #999, 0 1px #fff;\\n\\tbox-sizing: border-box;\\n\\theight: 3px;\\n\\twidth: 100%\\n}\\n\\n.win7 input[type=range].has-box-indicator::-webkit-slider-thumb {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABrSURBVHgB7dLNCcAgDAXgWASjm9TJ3Egns8N4SGv6c2gbyQA+kED40IPPwJGUEsEgpRRjO8o5i6i11gfZe7HVCojIJ4QA6D3vnXM8F1DmBUkL1TdOOIRGC2X7hcIvPu1ZY/wFV83OhzTF3QGRrxiDB3GCSQAAAABJRU5ErkJggg==\\\")\\n}\\n\\n.win7 input[type=range].has-box-indicator::-webkit-slider-thumb:active {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABmSURBVHgB7dKxCYAwEAXQfyEKYhrBThdwCwsLyRKukFGcRiyyh0tY2kcT0fJIn/zijg+v/IQnerUOTDYzkfToWkbOQcM6+ZX5OMNvVIVeFehqEbopXyIQmQzTgf969qFlIfkTM9wbGH4SS8YdBX4AAAAASUVORK5CYII=\\\")\\n}\\n\\n.win7 input[type=range].has-box-indicator::-moz-range-thumb {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABrSURBVHgB7dLNCcAgDAXgWASjm9TJ3Egns8N4SGv6c2gbyQA+kED40IPPwJGUEsEgpRRjO8o5i6i11gfZe7HVCojIJ4QA6D3vnXM8F1DmBUkL1TdOOIRGC2X7hcIvPu1ZY/wFV83OhzTF3QGRrxiDB3GCSQAAAABJRU5ErkJggg==\\\")\\n}\\n\\n.win7 input[type=range].has-box-indicator::-moz-range-thumb:active {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAASCAYAAABit09LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABmSURBVHgB7dKxCYAwEAXQfyEKYhrBThdwCwsLyRKukFGcRiyyh0tY2kcT0fJIn/zijg+v/IQnerUOTDYzkfToWkbOQcM6+ZX5OMNvVIVeFehqEbopXyIQmQzTgf969qFlIfkTM9wbGH4SS8YdBX4AAAAASUVORK5CYII=\\\")\\n}\\n\\n.win7 .is-vertical {\\n\\tdisplay: inline-block;\\n\\theight: 150px;\\n\\ttransform: translateY(50%);\\n\\twidth: 4px\\n}\\n\\n.win7 .is-vertical>input[type=range] {\\n\\theight: 4px;\\n\\tmargin: undefined;\\n\\ttransform: rotate(270deg) translateX(calc(-50% + 8px));\\n\\ttransform-origin: left;\\n\\twidth: 150px\\n}\\n\\n.win7 .is-vertical>input[type=range]::-webkit-slider-thumb {\\n\\ttransform: translateY(-8px) scaleX(-1)\\n}\\n\\n.win7 .is-vertical>input[type=range]::-moz-range-thumb {\\n\\ttransform: translateY(2px) scaleX(-1)\\n}\\n\\n.win7 .is-vertical>input[type=range].has-box-indicator::-webkit-slider-thumb {\\n\\ttransform: translateY(-9px) scaleX(-1)\\n}\\n\\n.win7 .is-vertical>input[type=range].has-box-indicator::-moz-range-thumb {\\n\\ttransform: translateY(0) scaleX(-1)\\n}\\n\\n.win7 .loader,\\n.win7 .spinner {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAGiElEQVRYw+2UWWxcVxnH/+fcdebeuTNjj+2pM96bOCkle900Dq3dLBVulVBSiUpVQECpoC9ICPpSJChIiBceeEQtTRSQUNOGCqrgxkqaQkpoFodmoa4TO7Yn9nibxbPcmbucew4P5imJhfuGRH4vR/oezvnp/33fAe5zn/93yJ2FX/z0l+CgCKAhICpqnCIcrUO2bMOnMv4xfHmDkOVtfiBaNU1r8X2fuq47pShSOhTWhjdv2zxChA9TJQgLDmLbUDjHz1/93j0F5DsLHAAnyyejgB42kK+U8PHF4e2aZe0+dOjQCy1d7e1dnbEwpZCCAGAMLJOp1MYnJ6ZPnxn6w80bI4O7v/TYJUWVIZPl+1biLoGALj/uUyAAkF/K4/wnVw/07dn3/f69T+00LUvzGMdcxkEQMACA53myZVmRfXu+uKG7u+vHH5w52X/i3eO/PvjMwJ8C371Hzv9FwBMcgixL/Pnk4IFvvPTdV58+sH97Zi5LZqfGIISA4AJCCGSzWYQNA6GCjrFJgaYHkmp//5N9qgTryOu/kV547qt/FJ9HwCMCNSbAAh+/P/bW9qefPfjy2ocf2nYzPUUmpm/DZU6+5rmnajX7L47jfMgYE6qq9hm6ORBStX2STuJhLUQe7Xl0y8T46MuvHz2cfvHb37y0aoGaCOByDp/IUA2zv/+pvb0eZ3RyahrZbHZEONVfmYb626Rlwkg2QFVU2FX7aKlUOVotFV68frXyw5aWlu6oadCdu3p3DJ0afLLKvBUFpDsLu54ZQEAp3n3v5Pqdj/e90rGuu2ssncZ8vrAoHO+1hxJNbzaAIOwxKNUqZLsKkwnUyxrqjejlXKFk11y/t1DIheuTCdVhjnXsd0c+Qj6bXVUCN/UoBGXISXSriEY6rk3fwnxuCYGQBpOGeTikSDAFBWcBuMfBmQ9CPMiyBKZ6KLv24ZJT6Usm4l83IiYaGxvblFh8qw98di8BemdhpncA+Z7HwU1j02Rgx/6VmwWPG1hwau9bySbkvRKWvDJc34HgDCoBVCFAGIMf+BhdnEGG2ScypTxODL2PXDZr0YBvWPUM3DYtxBUioatjjUhEQ4uBg5npW6gzEh/ViEfClIlA8sAFIACw/+xYQIGqSrEkPBD4fw35DqauX0NdSNNBad2qBQgvQ1a4Jq3tiKgNdSJpmmQ2kwFUxTIbIwLlNCg8cAq4FAAl8CngyMCSRuGFKIQIxLXxUSRiESiKDNkMKe4KAne1gCsOoDFNNjXe2tbBd/XswBOP9CCs0631rQla1DmKOoetcjgyYKtAIQTMRoA5E3AMBbbwH1GjJqiho/nBdle2wpVVJxAYDjxGvWg0Wuh5eKvYbCqwzRgaYuq36pPxt4YjkudETNRXOAyuwEGABdnHXEyCb5ooahySkAYaE3HIjGHo3NmMzf1PVxK4K4E1lSpiJdtuMM0rc3MLNSaAjpCMzlRD75mLp3/Q9sQO/YYmYco0cA0M00YIWcNETg9jSdFkJRY/pMYiBzc91gNbMFScyoRQ6LmVBO76Bw7ufx6RoouwHrm8kM9/rblpTWMZLjEVIuVpdfPxC58EUurB87mQLkQqReZkGVpzirhckcZuTH1HUcM/6uxoa3dKRSzMzuQqpaW3U22t75TOXVxdC7oWy8gSjniq2f84PfHOzXx7Z2trk2EigJRoSDS2iZ+MzMztASWD3F8Yiqg6RjJzW+Ja+LnudRt3m2bIhOdgfCYdVKTaPxEVp0vWSiN4D4EosaHIMhaL89jYlvzZqavDa5vJFw40pawIEyo2rtsYfqChsLdUKu3NZrPwHReRNSnEIhY62zuQTt/GxNQkW/LKl8re3Jvdz/ecc1FBabUCeuCBCI6AACVVRqQ1+crfpm/MJ1H3UlPEMho8RuPRCBJxC+vbOuHCBRMM1WoVl65fgO96laqdv0LswhvPfnngWLo4KnT6ORKQAwoIwHKBEOOoUm/WXJt87VZm/LMlT/9KUTd2JXhU931fUhRFDofDWFzM+o5Ts8tBftYuFS7EiHN8ixV9L3b9NhIMkIiMK6sVoAKQOUA4R8TjqHcD1MrVcn0s/obHi0c+nby8U9Kx3zDNNtd1k67jEEmSMkG1+veQbFxfn2w+o4+VeKMToNVXECwBuqSuPgFOKASW9zPmcGzKcaSqHphcRc4qMr/FOVswi2cF5iUVgE4lzWd+TZZkkuJ6IJ0fRUvZRNwDaC2ApOgQXOA+9/mf5d+3RhGneJlNNgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0xMS0wNFQxMjo1OToxNyswMDowMD1ktU4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMTEtMDRUMTI6NTk6MTcrMDA6MDBMOQ3yAAAAKHRFWHRkYXRlOnRpbWVzdGFtcAAyMDIyLTExLTA0VDEyOjU5OjE3KzAwOjAwGywsLQAAACV0RVh0d2VicDptdXgtYmxlbmQAQXRvcFByZXZpb3VzQWxwaGFCbGVuZH56rZIAAAAASUVORK5CYII=\\\") 50%;\\n\\tcolor: transparent;\\n\\tdisplay: inline-block;\\n\\theight: 20px;\\n\\twidth: 20px\\n}\\n\\n.win7 .loader.animate,\\n.win7 .spinner.animate {\\n\\tbackground-image: url(\\\"data:image/gif;base64,R0lGODlhIAAgAPcAAAIRDmyhxGqfw5S707zV5Njm7+nw9unx9tfm773X4pDBy4ayy8HZ5dbl7sfc6L3W47XT37TR373W5Mbe5ePt9MDa4Yazy4muwcre6LrU46LF15C60YS3yJe+1HyyxYSzzJC9zqHL0rrY38rf54evvn6erLvS26TG14i3zXiux5S/0pW/03axwp/F1qTK08PW4HygqJu0vZi6yHWrwnWtxHOxv3Wvv5i9x5u1vXiQmZu1vnChsWOjuWSiuXClrpu8unWWlHuUm3qcp1iSpIq7yVmdm6/EynielHeboU14f0uKlEmXpEmWkkuMgE12dH6WnF2ZnjaPlBmSmgmKlzqEkRZgXzlgaGyJjlCrsSmusi6/whKgqQVtbSJuaCxnWmePh1O8wD7Sz4bt7HrO0Atydyx9cWyQknOjjmPRyqPt6vz9/drs6abX0G68vR6Ehyt8dy93YpDm4uz+/eH6+cTu7CGnpVCwsBh+fUiEeS7a2qn7+9r+/c7384Pg0TG/rz2+uzyzsByOiEbv6bT+/9v//3338inc1U7Wz1fSwWLY0FXVyVrSzBOrpkqqlF7e1TPt5WL9/Fj8+ob49kfr5ELf1h7TxBHKuinRxkjZ0Ijo4EnZzhfFu0G5qnbg1hfx3Rf18DX282z18ZH18KL18Kb174Xv5mPm4C/a0iHQxEXOs0/jwyjvzy/w4iLt4iLr3l7w6Dfo1yjcyjnWvmPerXbmt1jhrEDcqz/cmVfgqZS71Njn7+nx99fn7sDY45S/0MHZ5sfd6LzW47TS4LTQ4L3X48zg6djo7sDZ5IWzysnd6LvV46HF2I+70Iy6zoS0yXyvx4S0y6PJ1rzX4cvg6IuwwX6crLzR23esxpO/0H2xx427zabI1rzS236eqpu4wZi7yHWswnStxHSvwnWtwJi9xpu3vWqosJzIz3C1wmGswGSkt3apsajBxXWUlIDEy2/DyXrO01i9xnzE0om8xlyboYSpq3mXmFG7xGHX2Xrh413HzVaWnUyChU5xeEnFzaTy8yH+JUNyZWF0ZWQgYnkgZkNvZGVyIEdyYXBoaWNzIFByb2Nlc3NvcgAAIf8LTkVUU0NBUEUyLjADAQAAACH5BAUBAAAALAAAAAAgACAABwj/AAEIHEiwoMGDCBMqXMiwocOHECNKnBgxgACKBwcQKGDgAIIECjACWMCggYMHECJImEChgoWJFzBk0LCBQwcPH0CEEDGCRMQSJk6gSKGC4AoWLVy8gAExhowZNBDWsHEDx8McOnbwUNjDxw8gDoMIGUJEIZEiRo40RJJEyRKGTJo4ecIQShQpUxhSqWLlCkMsWbRsYcili5cvDMGEETOGIZkyZs4wRJNGzRo2Ctu4eQPHYRw5c+gorGPnDh6HefTs4dMHoZ8/gAJBFDSIUCFDhwgiSqRoEaNGEB09ghRJ0iRKlSxdwpRJ0yZOEjt5+gQqlKhRpEqZOoUqFUZVq1i1GnL1ClYsWbNECqRVy9YtXOrjy59Pv779+AEBACH5BAUBAAAALAAAAAAgACAAhwERDmyhxGqfw5S71LzV5Njn7+nx9unx99fn7sDY45S/0Iazy8HZ5tbl7sfd6LzW47TS4LTQ4L3X48zg6djo7sDZ5IWzyomuwcnd6LvV46HF2I+70Iy6zoS0yXyvx4S0y5C9zqPJ1rzX4cvg6IuwwX6crLzR26TG14i3zXesxpS/0pO/0H2xx427zabI1rzS236eqpu4wZi7yHWswnStxHSvwnWtwJi9xpu3vWqosJzIz3C1wmGswGSkt3apsajBxXWUlIDEy2/DyXrO01i9xnzE0om8xlyboYSpq3mXmFG7xGHX2Xrh413HzVaWnUyChU5xeH6WnEnFzaTy89Hz9JjHzRhwexdeYDdmZGqMizbP1+f+/vj6+rrV2AVncCJpZ0tzdGmRiSnY2tn8/Pn8+8bd3wtscixwbjBjXXqdlj/d0aP49vj+/tnq6ZfS0XK5ux16fSttbjNiYHnp5Nn+/pL39T3b0yOhn0+nphhvbk95eD3ZxCn7+Ej5+Fjy7zjdzkvBsj24rjyopR5+eh3gzRD181n38lzw5SXWxFfTymHNwjvFsWLSx1rLwRSdllWelRfuwC7z65X59Ybx60fh2CjUxCzQwxHJtSnLvUjQx4fg2UnRxRi5rUezoyboqxnr2i/r4mjt54Xv5qv07p7x55Xt5GPh0zDQxyPFuFDHs1bjqy3iwj7l1y7l1yLg0iThy2Lp2y/Xu0HNt3/VwnvktmTctlHRskjWoFngnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnBgxgACKBwcQKGDgAIIECjACWMCggYMHECJImEChgoWJFzBk0LCBQwcPH0CEEDGCRMQSJk6gSKGC4AoWLVy8gAExhowZNBDWsHEDx8McOnbwUNjDxw8gDYMIGUKkiEIjR5AkaahkCZMmDJ08gRKFoZQpVKowtHIFSxaGWrZw6cLQyxcwYRiKGUOmDEMzZ9CkYahmDZs2bhS+gRNHjsM5dOrYCZDwDp48ehzu4dPHzx+EgAIJGgSRUCFDhxAlIqhoEaNGjh5FhBRJ0iRKlSxdwpRJ0yZOnSZ6+gQqlKhRpEqZOoUqFUZVq1i1G3L1ClYsWbNECqRVy9YtXKTVy59Pv779+yIDAgAh+QQFAQAAACwAAAAAIAAgAIcCEg9socRqoMOUu9O81eTY5+/p8fbq8fbX5++/1+SUvNKGs8vA2ObW5e/I3Oi91uS10eC00eC91+PI3ujW5u3A2eWGs8qAusvK4Oq61eKixdiQvNCKt818r8d8rsiEtMuQvM+lyNm71uLM3+mJrsBkv8q75Oqk2OOIw9V2r8eTv9GUv9F6sMaIuMukx9a70tt+nqtcxM6e5eqg5ut20t1tvtB1rcN1rMGavsictr6B2+HP+Pmv7/JtzdlkpLd4qLSgub94kphZ0tvF8/T6/f7j7fCr0tuJvMdalqF6n6Z6k5ke39rf/P36+/zV5OdRkZ1LfodNcHZ9l5si49zp///4+vq81dkKZ3QXW2FDam9rjIw+09Kd/f3S9/iXyc8FZHIiZGo0YGI/zsg6+Phk8/QlyswLbHItbG8mVld9mppg1L4S5eAs8fEd2ttPzc1zuLsdeXwra24X2qww7epP6+YVzcQjoZdPpKQYbGxPd3hJ14x18OtG6uNI49tn3NZxysVDuKg9pJ0feXYn25MR4NlZ6+RQ59Ym0bhc0MhnycIuuKVVyLlax7gUlIxZmpUi4awV49aB8umZ8elI29AozsEcx7QjxLEoxa1IzLqH29ZJyb0Yr6JNqqI13aww5tIv5dFj5tyI6uKl7+ep7+aO6dl85NUwzLcmu61WwbJn3bU4170s2cdI39Um18Yi1L862r5V2b9EyquD08B947Ri3qhS0qVcyrJ01rUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwYMYAAigcHEChg4ACCBAowAljAoIGDBxAiSJhAoYKFiRcwZNCwgUMHDx9AhBAxgkTEEiZOoEihguAKFi1cvIDxMIaMGTRqILRxA0eOhzp28Oih0McPIEEaChlCpIgRhUeQJFHScAmTJk4YPoESRQrDKVSqWGF4BUsWLQy3cOniheEXMGEALxQzhkwZhmbOoEnDUM0aNm3cKHwDJ04Yh3Lm0Kmj0M4dPHkc6tnDp48fhH8ABRIEcRChQoYOISKYSNEiRo0cRXwEKZKkSZQqWbqEKZOmTZwmdvL0CVQoUaNIlTJ1ChXGVKpWsRpq5eoVrFiyRAqcRauWrVvq48ufT7++/fgBAQAh+QQFAQAAACwAAAAAIAAgAIcCEw9socRqn8N/wtmQwdi71uXY5+/p8fbp8ffX5u+91uSUvNRp0uK+6PDW7PLI3+q91eS10OG0z+DG2+jW5e7A2OaHsstw1OB94uvS9vm+7/Sh3OiQyNqEts18rsh9rsmEs8yQutGhxdi61ePK3umJrcF44ejz/v/n/f2k6/J2ydqIx9mVvtN4rsaHt82kx9e60dt+nash5tvh+/v8/v7t9fey2eR1rsR1q8KZusibtL2F7+z5///3+frW5+1ko7lwobGbtb14kJhc0tCc+fnk7vC51t6Lu8lZkqN6naZ6k5o1z8Vd+vmV9/mc3uJJi5lMfIhNbnZ+lpwtzK428fEj7vAVusIKZXUWV2M4X2ZsiY43xp8n6egj4+MFuL4FZHEjYmosV11MxZEc2c4v2NkKt7oLbXIta28mVFd+mZt5zKQY0qIt0NEewsRayMVxubkeenwra240YGIhzIgYz8pP29YZwb0nqJRPp6IYbGxPd3hayJBD2cxX4tg92c1M0sZYwbNTv7I8ppseenZO2qUr2stZ49lf39Ut0bddz8Frx78xsKdMwbJaxbgTk4xZmpUzzK4V08lK4s6f8OVH18EowrcRuKMrv60qwKZHyLCH2s5KxLoYrJ9OqaE+1bEf2Lto6dtj49CF5Nqf6d+q6+OI49GK5tdG0bgmuaFavrFi3qg71K4ay6kx0MA+1McjzLQpyq1Ezq9Fy5x11rdfy6lfyK2C0b8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwYMYAAigYHEChg4ACCBAoWYATAoIGDBxAiSFAwgUIFCxIvYMigYQOHDh4+gAghYgSJEhFNnECRQsUKgixauHgBI8ZDGTNo1LCB8AaOHDoe7uDRw4fCH0CCCGk4hMiJIkYUHkGSREnDJUyaOGH4BEoUKQynUKliheEVLFm0MNzCpYsXhl/AhBG8UMwYMmUYmjmDJg1DNWvYtHGj8A2cOHIczqFTx47CO3jy6HG4h08fP38QAgokaBBEQoUMHUKUiKCiRYwaOXoUEVIkSZMoVbJ0CVMmTZs4dZro6ROoUKJGkSpl6hSqVBhVrRpi1crVK1ixZI0kOItWLVvr48ufT7++/fgBAQAh+QQFAQAAACwAAAAAIAAgAIcBEQ2Bz+NxvddjqMhqn8NY1+mD4++16/PX8ffp8/fq8vfX5vC91uWUvNRb3d586fLu/f/r/f7W9/q96/G13ei00+K91eTG3OjW5e7A2OWHsstb2tiO9/T8///9/v75+/247fOJ0uF8wNV8tMyEs8yQutCixdi61ePK3eiJrsFo4+X1///w9vnZ6PCp0uGUvtJ3rceIts2kxte70Nt+nqtA1cif/Pzb///t9PfK3+l1rcR1rMGZu8ibtL1O3dSc+/uQ9PaY3ORko7lwoLGctb54kJluzqZl7t568/Vb4+dtztiKu8lZkqN6nKd6k5pTu5RH39lL4eNJzdNJi5lMfIhOb3d+lpw9voY30scZycwJqLAKZHUXV2M5YWhsiY86xIApxrokwsYFoqoFZXEiYmssV1xsiY5buZMfvrAuwsQKpakLbXIta3AnVVh+mZt/yqQfuZQsu7wetLZgxcNwu7YdfHora240X2Exr4sYtLRPzcsbvLpGsatPqaAYbWtPeHhvu5oUt6hBzsU9zcQuxLQ5tKJIuK09pZweeXZCxpdf19Jb2s5V08lMy75izbxsxsAvsaVMvrVbwroTk4xYmZVAyqYWybhK1ciF5NNN0bkpvasRr58UsZo9v7BIx66K3M9Kx7YYrJ9NqaFNybciyrRK2ciE5dmF4NOd5Nue5dqO4NVn18Jz3dYsvqJZv6571r5CzKkvy6wrx7Etx7cvx7Qrwao1waVRx6mE07mB0b5kxqxlxawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpz4MICAAQQoGixg4ACCBAoWMGig0cEDCBEkTKBQwcIFDBk0SNzAoYOHDyBCiBhBooSJEyhSRFSxwgOLFi4IvoARQ8YMGg9r2LiBIwdCHTt49Hjo4weQIAqFDCFSpKGRI0iSKFG4hEkTJw2fQIkiheEUKlWsMLyCJYsWhlu4dPHC8AuYMGIYjiFTxgzDM2jSqGG4hk0bNwzfwIkjZ45COnXs3HGIJ4+ePQr59PHzxyGgQIIGEUJYyNAhRBATKVrEqJEjgo8gRZI0iVLESpYuYcqkaROnTp4+gQolauIoUqVMnUKVStUqVq1caR18BSuWrFm0atm6hUsjwVy6drmfT7++/fv48w8MCAAh+QQFAQAAACwAAAAAIAAgAIcBEg5a2exM1elEyuFDwNtswdov5uKZ+vjj+/33//7v/f7q+vzV8fa82+mSvNR12Nli6e3m/f79///+/v/+///j+vu/8PS95/DH4uzW5e6/2OWGsst+08Vf7OjQ/v7q///5+/zt9Pjj7vS/4OqF0N+EytqQxdihxdi71eLJ3emJrcFQ38a5+vur+vyx9PfU5O2/2OSQwNN4rsaIt8ykx9e60dt+natfw5qS7++Z9PZ26/Bp1N91rsR1rMKYusictL5W0qqb6+5x4+lZ0dtjorlwobGbtb14kJh4y6Jq28F63eFYztVxzNOKu8lYkqN6nKd6k5pYtoxHx8FLy9FJvsdJi5lMfIhOb3d+lpxDtYc3ubIZsbcJmKMKZXUXWGQ4X2ZsiY5Tq5IprKEkrbEFl58FZHEiYmosV11jspAiop0vra8KnaELbHIsa3AmVFd+mZslnYstpKUdo6Vjw8F1vLodfnkrbG01YGI3ooAYnZxPv74esK4+rKlSqqMYbmtQd3dzuJcYnpc9vLc9wLo2uLA7sKk9sqg9o50fenZJrJchtKhe0cZMyLxHv7hsy79rx74xsaZMv7RbwbwUk4xZmJRUwq0lwbBJzcCI3dJKybQpuaQSq50SrJo2vK5PxreJ285Sy7sZr51NqaFRxq8mvK0vyLN/3tSM3tOd4tqe49tm1MU6yLQ+wq9YwKxKxK04xakrw6ojv64tw7Qwwq8atJtNwaxpw7BoxK8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpz4MICAAQQKUCxo4ACCBAoWMGjgYOMDCBEkTKBQwcIFDBk0bJDIoYOHDyBCiBhBooSJEyhSqIi4gkULFy9gEIwhYwaNGjYe3sCRQ8cOhDx6+PjxEEgQIUMUEili5EhDJEmULGGisImTJ1AaRpEyhQrDKlauYGGYRcsWLgy7ePkChmEYMWPIMCxj5kzhhWjSqFnDkE0bN28YBoATR84chXTq2LnjEE8ePXsU8unj549DQIEEDSKEsJChQ4ggJlK0iFEjRwQfQYokaRKliJUsXcKUSdMmTp08fQIVStTEUaRKmTqFKhUmVatYtRvaCMDVK1ixZM2iVYt8QVu33MufT7++/fvzAwIAIfkEBQEAAAAsAAAAACAAIACHAQoJWdvgKOLiCfLoIN/oM97dYNndT9rNafryuv7++P///v//////vfn5fN7rc8feUvDOuvv71v7+//7//f7+/P3+4Pz91vX5vubvf7vRYurE1fn7uvn6ofn6pvXz4vHv6vL22+vu4u3zpuvxoeTsuuHryuDpia7BUN6luvPzpPLyiOvvbdvletDeg8rbcsPXiMbXpcfXutHbfp2sXcWIlOjfmevorervYtHSc7LIdazCmLrIm7S9U9WW2/T1b9/YWs3OY6S5cKGxnLW+eJCYbc62etfRWMjJecjPirvJWZKjep2me5OaXbKLSLCwS7i+Sba/SYuaS32ITm94fpacR7J9N5+jGaCfCJ2XCmV2F1hjOF9nbImOUa6BK5GVI6GYabrABWRxI2FrK1Zca6yRJIiEL5uWCpeHC29wLGtvJ1VYfpmbK4d5LI6QHZGUbL2+e72/JYF/LG1tNF9iQJN6GIiHT7OyIqalKaOcUaijGG5rT3d4HI2HPa6qPrayOrOtO6+rPrCqPaOeH3p2T6OTFJ+UWce9TMG3NrSndcrEa8e+MLKlS7+0WsO6E5OLWJiUS7OfOr+0TMi5h9nQTca2KbikEqybEaudKrenV8e9iNrPWs3BILKfTaufWsOtJrejL8CyZdPDleHan+PaneLbhtvRZtPFL8OwLrunVsGqTr+vNb+oNcSvIsGrI7+uNsO0N76sT8CwacOwasOxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACP8AAQgcSLCgwYMIEypcyLChw4cQI0qc+DCAgAEEChigSPAAggQKFjBY0MDBA44QIkiYsIBChQkWLmDIMFHDBg4dPHwAEULECBIlTJyIiCKFihUsWhB08QJGDBkzHtKoYeMGDoQ5dOzg8bCHjx9AFAYRMoSIwyJGjiBRmETJEiYNmzh5AoVhFClTqDCsYuUKFoZZtGzhwrCLly9gGIYRM4bwQjJlzJxhiCaNmjUN2bRx80YhnDhy5jikU8fOHYV48ujZ4zAAnz5+/iAEFEjQIIiEChk6hCgRQUWLGDVy9CgipEiSJlGqZOkSpkyaNnHqNNHTJ1ChRI0iVcrUKVSpOAIYULWKVStXr2DFEl9Q1iz28OPLn0+/fvyAACH5BAUBAAAALAAAAAAgACAAhwESDnHYx0rTzSTf1jfe2Tnj3UHi3V/VuXbp2rH59tT8/er///n///3//+P//57x9kTb7WTbz7z19OX7+9P6+rz7+7/6++L9/P7+/v7+/+f9/m3d6nnZzcz09rvy863w8Jbs6p3r7Jvj6b7k6uPu8+70+Pn7/Or9/tL3+nLP3GXAs7/t76np7Ije5W/Q2XrR1r/Y5NPk7bHu86vq8Lrl63Ksume+kZbZ16Di4ofa32fHz2/I2HbO25nN15q6wmjEoarf23rUz3HL0WGzxnCsupy2v3iPmIHIuKPY1Vm/u3jIyoe9y1mUpHudp3qTmWumk0qhl0qsp0mrsUmLmkx8iE1vd36WnF+YjziHhhmCiAmDiAlldhdYYzdfZ2yJjmOdjyt4eCSIgi+VkQVlcSNiayxXXXijmSdwby6LgTyblA1wcSxsbydVWH6ZmzFxay1+eh2KgW+8unW7vCmCgixtbTRfYkuAexh2dU+pqCOfniOemk+moxdta093dx59ej2loT2wqzuvqzuwqT6wqj2inx95dleZlBWTjFnCuku+tTGxpnDIwW3HwDCxpUy/tF3EuxWVi1mZlE6roR2xoE/Hu4bY0E/EuSq4phKsmxGrnSi1qEzDuIva003Huiu1qUyrnV7CsC66qS/AsmPRxYnd06Lk3Z3i24Xa0mXRxjDCsie3pFnArk/AsDe+rC/CrijCsCO/rS6/rzy/r0+/r2nDsGrCsQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnPgwgIABBAoYoEjwAIIEChYwaODgAQSOESRMoFDBwgUMGRpo2DCRQwcPH0CEEDGCRAkTJ1CkiKhiBYsWLl4QhBFDxgwaNR7auIEjhw6EO3j08PHwB5AgQhQOIVLEiMMjSJIoUbiESRMnDZ9AiSKF4RQqVawwvIIlixaGW7h08cLwC5gwYhiOIVOG8EIzZ9CkYahmDZs2Dd28gRNHoZw5dOo4tHMHTx6Fevbw6fPQzx9AgRAKGkSoEERDhxAlUrSIIKNGjh5BihRR0iRKlSxdwpRJ0yZOnTx9mggqlKhRpEqZOoUqlapVHAGwF2rl6hWsWLJmhS9Iq9b69/Djy59PH35AACH5BAUBAAAALAAAAAAgACAAhwERDXjWwljPuTvTrDXduUvUyWDa02PTu33d2bTx8db5+u/9/e/+/tP9/bH8/Hvw80jg43HNzsPx8eH4+Mf09bzy87Tz9bP297z7/NX9/uv//+z9/nD382Pa4nXNxMjv8sLv78Dv75Tj4qfi6XzW3X3Y5Ynj7Lfy9vn7/f3+/v3//5br8m3V4Wm+qcrp7qTg5YjX3nDO0X7PzqjV4dno8PH2+PT//nHY4H2vo5bNzpnY1nbL0WnD0Mvg6e309tv7/KPr71+/yGmsmJvPy5XP0m/EyprX4pHm6pvj5WO1vI/CtZbLxFy1rX3ExXfG1FvDzHvEynOttG+ikl+flF+pn0mfoEmjr0yVn014gHyYnmOUizd3chlxcglxfgptfRdZZThgaGyJjm2SkS1kZyRycgR4bgVncSJiaixXXX+dnShcXy58cFCcmBFxdSxtbydUWH6ZmzRhYi10bSeKem27snK6uiB8fSxsbTRfYU53dxdua0+moyOenCOdnU+koxhtbE93dx55dj2ioD2vqjyvqzuwqj6wqj2inh95dliZlBSUjVrBu0u9tzGvp2zGwDSxqUy/tV7EvRiXjlialE6poRitnkrFuobY0UrBti23qhKrnCi0qEjBtorZ0krEuRuuoE+roVm/rzG6qzHBs2TQxoXa0aDi3J/i3ITa0mTRxzDBsie2plm+sE/Brza8rSu/rifBsCO/ri2/rzi+rU/AsGnDsGrDsQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnPgwgIABBAoYoEjwAIIEChYwaODgAQSOESRMoFDBwgUMGTRs4NBBoocPIEKIGEGihIkTKFKoWMECYgsXL2DEkEFwBo0aKWzceIgjh44dPBD28PEDSBCHQoYQKaLQyBEkSRwqWcKkiUInT6BEaShlCpUqDK1cwZKFoZYtXLow9PIFTBiGYsaQKcPQzBk0hxemUbOGDcM2bt7AaRhHzhw6CuvYuYPHYR49e/go7OPnD6CHgQQNIoSwkKFDiCAmUrSIUSNHBB09ghRJ0qSIlCpZuoQpkyZNmzh18vQJ1MRQokaRKmXqFKpUqlaxG+IIoJWrV7BiyZpFi3zBWrbcy59Pv779+/MDAgAh+QQFAQAAACwAAAAAIAAgAIcBEQ1V0LBLzaw9ybdYz7p61cVo0LeD1Nm36e3c9/fy/P3q+vzV+Pqz9fRz7ONY1s1xy8HB7erW8vPH7fK87e+07e+z7fK98fbH9vnW+/y6+vtQ7+Z32Nx/vsbI7Ozm9far5eKj3+SP1918zNp8zt+E1uSP6O+h9Pi+/P3S/v527O9f2dd2tKu+3+Sk2d2H0tJyzMqO0dR60d1y2+Wk8/fm///z//9u8O2Eq6Shx8mhz9J1v8lvusyy2uXt9Pf7/v7h/fw2199xm5mcxcOGwMFgsrnV5+33+fv5/v+L4uZ2qJd7tad7tbiFwsa41t/k7vDz/f2e7O9rzNRxoY6OsKhvq5xImpac2d2Y7vBg19lRuMFlkIZBe2oYb14Ja3IWoaoiur84s7dNqK9wjpEsW1skYmsEaW4FipQil50riYxcmZ6Bm50pVlkuc24fg3YLe4EsfH8mXmJ4nqA0YWIsdWpFmI58wrxyuLsde30sbG41YWNPd3cYb2tPqaEiopcjnZxPpaQYbWtPeHgdenU9op89sKo8r6o8r6s+r6s9op4fenZZmZYTk4tZwbtMvbcwr6htxsExr6hMvLdawbwVlI1amZVOqaEYq59KxLqG2NFIwLYptKgSq50Sqp0ptKlIwbaH19FKw7oYrJ9avrEotacwwLNkz8aF2tKe4duF2tNj0Mcwv7MntaZbvrFPv7A4vK0tvrAivq8svrA4vK5Pv7FqwrIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwIMYCAAQQKUCRo4ACCBAoWMGjg4MFGCBEkTKBQwcIFDBk0bOAgsYOHDyBCiBhBooSJEyhSqFgBkUULFy9gxCAoYwaNGjZuPMSRQ8cOHgcD9PDxA0gQh0KGECmi0MgRJEkcKlnCpIlCJ0+gRJHCcAqVKlYYXsGSRQvDLVy6eGH4BUwYMQzHkCljhuEZNGnUMFzDpo0bhm/gxJHTcA6dOnYU3sGTR4/DPXz6+FH4B1AgQQ8HESpkCOEhRIkUQVzEqJGjR5AIQookaRKlShEtXcKUSdMmTp08fQIVSpSliaNIlTJ1ChWqVKpWsRxqtRGAq1ewYsWSNYtW+YK1ar2fT7++/fv46QcEACH5BAUBAAAALAAAAAAgACAAhwEUD3/Tu1rQqEjCrVG3w2jGyIDUx4XB0IrJ17nl5uz4++n4+er4+tX0+Lbs8Hze3lzWuXnCwb/j6Nbt8sfp7b7o67Tl67Tm773r8sfw9db2+bzz9mDh0IC7vNTr7M7q66TZ25zU3YTL13zH2XzI2oTP35Dc56Hp8Lvz98j4+l/t23mlqbvY3avX2ZXR0XbDxJ7P3IHN2W/P3Ijo76T2+bj6+03g2KnDyZrCynW2w3G3w2HS3Xbt8qD6/Jr8/ErSznWVlaC/v3GrrmKpt2vX4K3198/+/3vn6XqamIKsp3+ut4a+w6rT3eTt8Pn+/sP6+kDc0neek12OfkyQf1CYl9Xk5/r7/OD8/SfX2mKUgneblTF7bghrcLvV2fj6+uj+/jTO1m2RjSxmWCNtZgVmcJfHzNP09J7w8knFy4GcnShVWS5vbwpzbCe4u2Td3T7P0VG9wjVgYixxbTaPh4nFxmLCxR2uryu2tyGoqn/Gyk93dxhvalOsoyemliKnp0+4uBiTkz2Ulh96dj2knj2xqTuvqz2wqz2joB2AfFmYlRWTjFnBu0y9tjGvp2zGwG3GwS+vp0u8tlrCvBSUjVmZlU+qohisoErDu4bX0UjAtim0qRGqnRKrnUnAtobY0UrDuhmsoE2poVq+sSi1qDDAs2PQx4Xa0p7i253h24XZ0mPQxii1p1q+sk+/sDa8rSy+ryK+sCO+ryu+rza9rU+/sWrCsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnPgwgIABBAoYoEjwAIIEChYwaODgAQSOESRMoFDBwgUMGTRs4DCxg4cPIEKIGEGihIkTKFKoiLiCRQsXL2AQjCFjBo0aNiDewJFDB8IdPHr4+OEQSBAhQxIGIFLEyBGHSJIoWaKQSRMnT6AwjCJlChWGVaxcwcIwi5YtXBh28fIFDMMwYsaQYVjGzBk0DNOoWcOGYRs3b+A0jCNnDh2FdezcwZOnoZ49fPoo9PMHUKCHggYRKoSwkKFDiCAmUrSIUSNHBB9BiiRpEqWIlSxdwpRJ0yZOmjp5+gQq1ERRo0iVMnUKVSpVpFaxG+IIoJWrV7BiyZpFi3zBWrXcy59Pv779+/MDAgAh+QQFAQAAACwAAAAAIAAgAIcBEg50v8JersNUtLxkyLqB08OKv8+Nx9DM5uzb8PPp9fjp9vnW8PW55u2F0tt0y8uBuMfA3OfW6e/K5uq94Oa13ei03+q85e7G6/LW8va87fJp1M+FtbjP5um63d+kz9mQx9GEvtJ9vdJ8wdWEy9yQ1eOh4eu77fLI8fVo4sl9naq719fF3eSNxcmNwc6Ux9OGyddyyNiI3Oel6vC58fNV16+ctr2YvsV1s7tytLxnytV13OWY7PCT7e1Qzph6lpqnv8Rwpa5jpLlbzddx5+ub9PVP3cd6mJh8pqNgnKOJvMVsz9dY4eV69vdj7utf0r99l5tNeXNbkY1fnKRe1dp69fZe+fk9zMhlkIZeh4EgcmAJbG6ZytDQ9vek/v4909BolYdNfHMtdmwFaW+71dn4+vrn//8i49x/nZsoXlYucm4JbXDG3d76+/vY+/sf39o1YGMsbm0egXh5vruY0NLZ6er2/f6m7O1Z09tPeHcYbmtUraNDsKkwysuT7++H8fJb1NcfeXY9pZ49sqc7sKkxv7w91NJJ3dwk0dJYx8tYmZQVlIxZwbtMvbYxr6htx8FuxsExsqpMx8Ja1NASv7s7u7xPqqIYrJ9KxLqG19FIwLcptKgSq50Sqp0ptaiG2NFJxLoYsqZDt7FavrEntacwv7Rj0MaF2tOd4due4tuF2dIvwLMotadZvrJPv7A4vK0svq8ivq8jvq8tvq84va1Pv7FqwrIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwIMYCAAQQKUCRo4ACCBAoWMGjg4MFGCBEkTKBQwcIFDBk0bJjIoYOHDyBCiBhBooSJEyhSRFSxgkULFy8IwoghYwaNGhBt3MCRA6GOHTx6+HD4A0gQIQqHEClixOERJEmUKFzCpImTJwyhRJEyhSGVKlauMMSSRcsWhly6ePnCEEwYMWMYkilj5gxDNGnUrGHIpo2bNw3hxJEzRyGdOnbu4GmYR88ePgr7+PkD6GEgQYMIISxk6BCiRA8VLWLUyNEjgpAiSZpEqVJES5cwZdK0iVMnT5o+gQolauIoUqVMnUKVSpWpVaxabRoE4OoVrFiyZtGqNb6gLVvt48ufT7++ffkBAQAh+QQFAQAAACwAAAAAIAAgAIcBEw6At8tkqMNfqcB5u8uaxdHD3ubX6vDp8vfq8/jW7PO64OmJzNhvzb2Gs8vA2uTY6e7L4ui82uS11uW02Oa83urH5u7W7vO+5u9xzM6GsrrJ4Oe71uCiydaQv8+Et898tMx8t8+DxNKb1N2k3eO75+3J7fN0zsp8oKfE2t231dyMv8iNu8+SwM6e0tx9z9OI1d+k5enB7u9X1KCbtrycwsZ9uL5xsrtpxNJ21tm+7u6j5+Rgw5h6lZmeuL5wpK9jpbdbyMt13tqc6eZU1aSAmp5/pKhZl6CLu8lxzMuO3uKC5eNp4sN2zKJ+lpxNdHVXio1Wlp9Ly8tR4t9s5uVHxI1qi4s3amIha2URbnUKub8W4uI66uo0xp1rk4pVfXwyeHAFaW4Svr018e8p8vAszqx8oJczaF8udmwJbnB53dH6/Pth+/kz08AzY18tbW4dfHtwura33dzd7ur2/v5o9/Vb085PeHcYbWxRqKNBraq46eTi+/nh//5g6+cfeXY9pZ1Dtao6sqaI2djN9vPc/f2p+fgc5tpYmZUVlIxZwrpLvbYwr6hsxsBezckuy8Zu7uu5/PzT//5h5eFOqaEZrJ9KxLqG19FJwLYotKkRq50Sq54pt6tIzMWH5+RQ6eQ27eZF5dxk3NBbvrEntaYwv7Nkz8eE2tKd4dyd4duF2tNj08sv0Mch08w22dWB3dlPwLA2vK0tvq8jvq8ivq8rvrAauKhJxbh51c1qwrIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwIMYCAAQQoGixg4ACCBAoWMGig0cEDCBEkTKBQwcIFDBkmatjAoYOHDyBCiBhBooSJExFRpFCxgkULgi5ewIghYwZEGjVs3ECII4eOHTwc9vDxA4jCIEKGEHFYxMgRJAqTKFnCpAlDJ0+gRGEoZQqVKgytXMGShaGWLVy6MPTyBUwYhmLGkCnD0MwZNGkYqlnDpk1DN2/gxFEoZw6dOnYa3sGTR4/CPXz6+Hn4B1AgQQgHESpk6NBDRIkULWLUiKCjR5AiSZoUkVIlS5cwZdK0iVMnT59AhRIlcRSpUqZOoUqlahWrVq5eaRuEFUvWLFq1bN3CpbFgrlzt48ufT7++/fsDAwIAIfkEBQEAAAAsAAAAACAAIACHARANa6LDZqPDmMHSvNbi2Ofv6PH26fL31+jxvNrojsPWg8LNhbPKwdvk2+nwx93ovdbjtdHhtNLhvNvkxuLp1uvxv+Hre8DOia6/yd7ou9bhocjWkLvQhLPMfK/JfLLJicLLqNPdotPduuDpyertd8u9fKCov9bbpMrTjr3Oe7LGlL/Sm8zWdL7KiMvYq+Hh2vHyYcejm7i8rMjRe7O/ebPCa8HMdc/PpOHdltjVcreedpGXm7e8cKWvY6a1XMfHjtranN7cXsGkgJqefKCnWJSii7vJecrLb87PgdnVf9bJesqgfZebUXV4S4GFSY6XSLzATM3NT8zEVriPbImOOGVmKGhtFG15CqSrFsS/Ns+5OMN/b4+PLGBaJG1nBWlvBLKnaOHbTt3WOcKAfp6ZQm5rO3t3Cm5wFc29XOrjMuPYTcCMNGdgLHJsHnp8crm6Y9TQUuXjK+/tEujHb9CmTnl3GG1sT6ajKKObZ93XcvX0GPf3GtbDH3l2PaSfRrWuQrSrpuHfzPXzwP/+VPv6Ntq9WJmUFJONWcK6TL61Ma+nbcbBhtjWrunmyvb12f7+zf//YOrhTqqhGKyfSsS6htjRSMC2KbSpErGkEr2yMNPLfO/s2/z8zv7+xf7/VvbwVeDQWr2xKLWnMMCzZM/GhdrTnePenunlhe3pf/Tyffr4oPr7TevtW+PbT7+wNr2tLL6wI7+yI8m+HtPLJt/bN+TiU+LjasKyYse5ctXNgd/bAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACP8AAQgcSLCgwYMIEypcyLChw4cQI0qcGDGAgAAUDQ4gUMDAAQQJFCzIyKCBgwcQIkiYQKGChQsTMWTQsIFDBw8fQIQQMYJEiYgmTqBIoWIFQRYtXLyAEQOijBk0aiC0cQNHDh0Od/Do4UPhDyBBhDgcQqSIEYVHkCRRsoQhkyZOnjCEEkXKFIZUqli5whBLFi1bGHLp4uULQzBhxIxhSKaMmTMM0aRRs6YhmzZu3iiEE0fOHDoN69i5g0dhHj17+Dzs4+cPIISBBA0iVOihoUOIEilaRJBRI0ePIEWKKGkSpUqWLmHKpGkTp06ePoGSGErUKFKlTJ1ClUrVKlatMrocegUrlqxZtGrZyljwFq5cutjLn0+/vv37+AEEBAAh+QQFAQAAACwAAAAAIAAgAIcBEg5socRqn8OTvNG81eTY5vDp8fbq8fbX5u+91uSSvtSFtMnG2+fW5u7H3Oi10eC00d+92OLG3+fW5++/3Od9vcWJrsHJ3ui81uKhxtaQutCEs8x9rsh8s8SiydWZxtKhytq73ePR6+yEx718nqq709ukyNaJucx4r8WUv9KOw8x2s8mIxc694uPE5eRwsauduL6fwMt2r798ssdvuMR4yMWa1dKXzM10tpl3kJect7x1prJjpbd0wcqR0NKh1NRsuqN7lZp6nqZZlKKKu8l5yMhZuryEysp5w7x/yKB9l5tUdHtMfodIjJlIs7tLvLlJtaxhr49riY04YWYcX2YLZ3UKn5s3vrNFw6tLrYpxjZEtWlwpaW4JaHMFqJVu2Mxg0sc+uoCAnJwtXVsyc3IKbnBFxr4r0MIew6tYuIs7aWU0dHMee3tzubtSz8EvzcQr0cwaypx5zKFOeXcYbmtPpKQjn5sVzstP6OIu4NkgzYYeeXY9o58/satFs68s09I97exE8+938u1OzoVYmJQUkotZwrpNvrYxsKdpyMOe3dmm5uJ99PRj+voQ9vMe4atPqqIYrJ9KxLuF19FIysEpy8MgzsZz39mt7evB9fPc/Pyo/v4y/PsX69192MBavrEotagwwbRj2NCF6eWn9fPJ/Pva/v7P/v68//6R/fwu6uV14NVOwLMyxron2dAp5+BP9fST+PdU+fQq5ttr1s9D1tBC3NhL4uJa5ecAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwYMYAAigcHEChg4ACCBAowAljAoIGDBA8gRJAwgUKFiRYuYMigYQOHDh4+gAghYkREEiVMnECRgqCKFSxauHgBEUYMGTMQ0qhh4wYOhzl07OChsIePH0AcBhEyhIjCIkaOIEnCUMkSJk0YOnkCJQpDKVOoVGFo5QqWLAy1bOHShaGXL2DCMBQzhkwZhmbOoEnTUM0aNm0UunkDJ46chnPo1LGj8A6ePHoe7uHTxw/CP4ACCRr0kFAhQ4cQJSKoaBGjRo4eRYQUSdIkSpUsXcKUSdMmTp08SfwEKpSoUaRKmTqFKpWqVRhZtRty9QrWpliyZokcSKuWrVu41sufT7++/fvrAwIAIfkEBQEAAAAsAAAAACAAIACHAQoJbKHEap/DlLzUvNXk2Ofv6fH26vH21+bvvdbklLvUhrPLwdjl1uXux9zovNbktNHgs9PevNngxt3nwNzifr26ia3Byd7ou9XiosXYkLrQhLPMfLDHirzJosnVkL7MocfWwd/h4u/ygLu1fpysu9HcpMfXiLfNeK3GlL/SksDPd7DEh8LFrNfVutradqmonLS+mLrIdavCda3EcbW/j8fMoM7OnMXGf66eeJCYnLW9cKCxY6K5crnAdLq5rc/Sca+de5Oaep2nWZKji7vJgsHHWKuxeri5c7CnfpacTnB3S3uHSYuaSairUbGmSamUZayLbImOOF9nGFllCWR1CZuNgMvCbsCzSLF4cY2RLFddJGJrBWRxH6yeIrWbMKmbRbR5gZudKldaLm1xCmtxR7y5LLeuIqScXbSJNF9iLGxvHXl9c7i7XcfAHb6yK8G0HriLTnd3GGxrT6SkI52cGsXCUNzVbN3XR9OXH3l2PaKfPbCqObOvJ83IPd7cPeHcG9bAW8uDWZiUFZOMWcG8S8vFK8bBWc/NT9XSI9zYTOvpWu7sEd7bIt6NT6qiGLGlSdXPhu3qZe3qrO7rnujlnujkq+3qZfPxh/v6Svb2FO3qHeeqUMS6IdDHMObil/z62/7/4f7+2/7+lv/+MPz7F/fzHPG6bNjTLd7aOPDwqv//uP//qf//Mvv8E/nrSOXGaeLiPOPlIubpCvXoKOrfWebbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACP8AAQgcSLCgwYMIEypcyLChw4cQI0qcGDGAAIoHBxAoYOAAggQKMAJYwKCBgwcQIkiY0IBChYkWLmDIoGEDhw4ePoAIIWJERBIlTJxAkYKgihUsWrh4ARFGDBkzENKoYeMGDoc5dOzgobCHjx9AHAYRMoSIwiJGjiBpmETJEiYMmzh5AoVhFClTqDCsYuUKFoZZtGzhwrCLly9gGIYRM4YMwzJmzqBpmEbNGjYK27h5A8dhHDlz6CisY+cOnod59Ozhg7CPnz+AAj0UNIhQIUOHCCJKpGgRo0YRHT2CFEnSJEqVLF3ClEnTpomcOnn6BCpUKFGjSJUyhfEUqlSqVq0YYtXK1SuRAmHFkjWLVi308OPLn0+/PvqAACH5BAUBAAAALAAAAAAgACAAhwEQDmyhxGqfw5S71LzV5Njn8Onx9eny9tfm773W5JO80oayy8DZ5dbl78fc6LXS37TT3b3X4sbc6Nbn7cbf5IS8wYmtwcre6LrV46HF15C60YSzzHyzw6HG14m7yJC70KHK08/k6M/l54ewvn6cq7zR3KTH14e3zHitxpS/0navw4fBwqjP0rrU2Huhp5u0vZi6yHWswXWtxHe0wJnD0JvExanByHiRmZu1vXCgsWSiuWKptHGrsZ+/w3KZmHyUmnqdplmTo4q7yYm8yliepnqvq3amm36WnE5vd0t8h0mLmkmgnIG6s2Sklm+jkWyJjjhfZxlZZAlkdQqIeDqfikWXhVubiHGNkS1XXSNiawVlckymqSSWhyyFfF+YjoGbnShVWS5tcQlscRWelCyiliOOgGqokDRfYixsbh18fm+7vWHEwx6po0O0qEyvnE93dxhubU+wrx+urhy+u0/NyCu4rU68kxyDfz69uz3QzjTJxy3HwD3U0T3QzRS3qmLCikqqpxLAvWPo5n3v7abl4p/d2lHVzSjQyUzf3Frj4RHNyTy8oDDMyjTp5qj8/Nr9/MH19Kzt63Pg3B/Z1Cni3Ujo5Ifx7krq5xXg2S3Trjvg4JH6+bz//9D+/dr+/8j9/af8+4X6+mP28zDu6hro3jHguT7k513x74/9+6j//0/+/in8+yD59R7y5ifnyVzhtELq2zvp3jTk2ibn0krjxnHmvgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/AAEIHEiwoMGDCBMqXMiwocOHECNKnBgxgACKBwcQKGDgAIIECjACWMCggQMCDyBEkDCBQoWJFi5gyKBhA4cOHj6ACCFiREQSJUycQJGCYAoVK1i0cAHxBYwYMhDOoFHDxsMbOHLoULiDRw8fDn8ACSJE4RAiRYw0PIIkiRKGS5g0ccLwCZQoUhhOoVLFCsMrWLJoYbiFSxcvDL+ACSOG4RgyZcw0PIMmjRqFa9i0cROg4Rs4ceQonEOnjp2Hd/Dk0YNwD58+fv48BBRI0CBChQgaOoQokaJFERk1cvQIUiRJkyhVsnQJU6aJmjZx6uTpE6hQokaRKoXR1ClUqVStGGLVytUrkQJhxZI1i1Yt9PDjy59Pvz76gAAh+QQFAQAAACwAAAAAIAAgAIcBEA1socRqn8OUu9O81eTY5/Do8fbp8fbX5u+91uSSv86KvsaHsszB2eXW5e7H3Oi81uO1096009291uPH3Ofa6e7L4eiCtsOJrsHK3em71OKhxdiQutCEtcqKucuPvc6DtsmQvM+mzdbB3eHJ4OaIr75+nqu80dulxteIt814rceUv9KTvtF2scKSwsyqzta91dqAo6uctL6Zush1rMF1rsR7tcR8tMCewcigur94j5ibtb1wobFko7ljpbdwpa6bubt2lJZ7k5t6nadYkqOKu8mLu8lYm52MtK98oZl+lpxOb3hLe4dJiplJmpKArqlXi356mplsiY44YGcZWWUJZXUkhYIYd2Y4c21njYxxjZEsWF4jZW0FbHkqio0ifXYsbmtjlIp+nJ4nYGMuiIwKi48Kg38wj4I6iHlvpZAqh4ktp6khtbZdxchov74dlZQ2mY1ipZo1pKcZx8Zy5uZn1NQetLJPvLsYl489mHlcwsYt29qm+vnM9PSn4d8uxL4+ycY9wL4ZoJl7s59K1di3/v3Z/f3K9/au6eaE2ddZ0ckqysNM19Na2tcTu7dAt5Zs2d1f6urF/v/O/v7a/fx88/Ew494R19AR0Mkp1s9I3tmH6+hK4d0V0co2x6xj4t8/9++g/f18/v9//PyF+/qd+Ped9/SF8e9k7eov494e3NFC071C598r8Osa+fQf+fYj8/Ej7+sk6+Mj59gx3cNh37Zi585O4sYw5LE93axc37R45rgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpwYMYAAigcHEChg4ACCBAoWYGTQwMEDCBEkTKBQwcKFiRgyaNjAoYOHDyBCiBhBokREEydQpFCxgiCLFi5ewIgBUcYMGjUQ2riBI8dDHTt49FDo4weQIA6FDCFSRKGRI0iSNFSyhEkThk6eQInCUMoUKlUYWrmCJQtDLVu4dGHo5QuYMAzFjCFThqGZM2jSNFSzhk0bhW7ewInjUM4cOnUU2rmDJ49DPXv49PGD8A+gQIIGPSRUyNAhRIkIKlrEqJGjRxAhRZI0iVIlS5cwZdK0iVMnTxI/gQolahSpUqZOoUqlahVGVq1cvRyCFUvWLFq1MA60dQtXLl271MufT7++/fv4AQQEADs=\\\")\\n}\\n\\n.win7 menu[role=tablist] {\\n\\tdisplay: flex;\\n\\tlist-style-type: none;\\n\\tmargin: 0 0 -2px;\\n\\tpadding-left: 3px;\\n\\tposition: relative;\\n\\ttext-indent: 0\\n}\\n\\n.win7 menu[role=tablist] button {\\n\\tborder-radius: 0;\\n\\tcolor: #222;\\n\\tdisplay: block;\\n\\tmin-width: unset;\\n\\tpadding: 2px 6px;\\n\\ttext-decoration: none;\\n\\tz-index: 1\\n}\\n\\n.win7 menu[role=tablist] button[aria-selected=true] {\\n\\tbackground: #fff;\\n\\tborder-bottom: 0;\\n\\tbox-shadow: none;\\n\\tmargin: -2px 0 1px -3px;\\n\\tpadding-bottom: 4px;\\n\\tposition: relative;\\n\\tz-index: 8\\n}\\n\\n.win7 menu[role=tablist] button:focus {\\n\\toutline: 1px dotted #222;\\n\\toutline-offset: -4px\\n}\\n\\n.win7 menu[role=tablist] button:disabled {\\n\\topacity: .6\\n}\\n\\n.win7 menu[role=tablist].justified button {\\n\\tflex-grow: 1;\\n\\ttext-align: center\\n}\\n\\n.win7 [role=tabpanel] {\\n\\tbackground: #fff;\\n\\tborder: 1px solid #888;\\n\\tclear: both;\\n\\tmargin-bottom: 9px;\\n\\tpadding: 14px;\\n\\tposition: relative;\\n\\tz-index: 2\\n}\\n\\n.win7 input[type=email],\\n.win7 input[type=number],\\n.win7 input[type=password],\\n.win7 input[type=text] {\\n\\theight: 23px\\n}\\n\\n.win7 input[type=email],\\n.win7 input[type=number],\\n.win7 input[type=password],\\n.win7 input[type=text],\\n.win7 textarea {\\n\\tbackground-color: #fff;\\n\\tborder: 1px solid #ccc;\\n\\tborder-radius: 2px;\\n\\tborder-top-color: #8e8f8f;\\n\\tbox-sizing: border-box;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tpadding: 3px 4px 5px\\n}\\n\\n.win7 input[type=email]:focus,\\n.win7 input[type=number]:focus,\\n.win7 input[type=password]:focus,\\n.win7 input[type=text]:focus,\\n.win7 textarea:focus {\\n\\tborder-color: #86c6e8 #b3e0f9 #b3e0f9;\\n\\toutline: none\\n}\\n\\n.win7 ul.tree-view {\\n\\tdisplay: block;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tmargin: 0;\\n\\tpadding: 6px 6px 6px 20px\\n}\\n\\n.win7 ul.tree-view li {\\n\\tlist-style-type: none;\\n\\tmargin-top: 4px;\\n\\tposition: relative\\n}\\n\\n.win7 ul.tree-view a {\\n\\tcolor: #000;\\n\\ttext-decoration: none\\n}\\n\\n.win7 ul.tree-view ul {\\n\\tmargin-top: 4px;\\n\\tpadding-left: 20px\\n}\\n\\n.win7 ul.tree-view.has-container {\\n\\tbackground: #fff;\\n\\tborder: 1px solid #8e8f8f\\n}\\n\\n.win7 ul.tree-view.has-collapse-button details>summary:before {\\n\\tbackground: linear-gradient(180deg, #eee 45%, #ddd);\\n\\tborder: 1px solid #919191;\\n\\tborder-radius: 1px;\\n\\tcolor: #4b63a7;\\n\\tcontent: \\\"\\\\002b\\\";\\n\\tfont-size: 8pt;\\n\\tfont-weight: 700;\\n\\theight: 8px;\\n\\tleft: -16px;\\n\\tline-height: .5;\\n\\tmargin: 0;\\n\\tright: unset;\\n\\ttext-align: center;\\n\\ttop: calc(50% - 4px);\\n\\twidth: 8px\\n}\\n\\n.win7 ul.tree-view.has-collapse-button details[open]>summary:before {\\n\\tcontent: \\\"\\\\2013\\\";\\n\\ttransform: none\\n}\\n\\n.win7 ul.tree-view.has-connector ul {\\n\\tposition: relative\\n}\\n\\n.win7 ul.tree-view.has-connector ul:before {\\n\\tborder-left: 1px dotted #000;\\n\\tcontent: \\\"\\\";\\n\\theight: calc(100% - 8px);\\n\\tleft: 8px;\\n\\tposition: absolute;\\n\\ttop: 0\\n}\\n\\n.win7 ul.tree-view.has-connector ul li:before {\\n\\tborder-bottom: 1px dotted #000;\\n\\tcontent: \\\"\\\";\\n\\tposition: absolute;\\n\\tright: calc(100% + 2px);\\n\\ttop: 8px;\\n\\twidth: 10px\\n}\\n\\n.win7 a {\\n\\tcolor: #06c;\\n\\ttext-decoration: none\\n}\\n\\n.win7 a:focus {\\n\\toutline: 1px dotted #06c\\n}\\n\\n.win7 a:hover {\\n\\tcolor: #39f;\\n\\ttext-decoration: underline\\n}\\n\\n.win7 .instruction {\\n\\tcolor: #000;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tfont-weight: 400;\\n\\tmargin: 0 0 20px\\n}\\n\\n.win7 .instruction-primary {\\n\\tcolor: #039;\\n\\tfont-size: 12pt\\n}\\n\\n.win7 .header {\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tfont-weight: 400\\n}\\n\\n.win7 .header-document {\\n\\tcolor: #000;\\n\\tfont-family: Calibri;\\n\\tfont-size: 17pt\\n}\\n\\n.win7 .header-group {\\n\\tcolor: #039;\\n\\tfont-size: 11pt\\n}\\n\\n.win7 .window {\\n\\tborder: 1px solid rgba(0, 0, 0, .7);\\n\\tborder-radius: 6px;\\n\\tbox-shadow: 2px 2px 10px 1px rgba(0, 0, 0, .7);\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tposition: relative;\\n\\tz-index: 0\\n}\\n\\n.win7 .window:before {\\n\\tbackground: linear-gradient(transparent 20%, hsla(0, 0%, 100%, .7) 40%, transparent 41%), linear-gradient(90deg, hsla(0, 0%, 100%, .4), rgba(0, 0, 0, .1), hsla(0, 0%, 100%, .2)), linear-gradient(55deg, transparent, rgba(0, 0, 0, .1) 20%, rgba(0, 0, 0, .1) 50%, transparent 53%), #4580c4;\\n\\tborder-radius: 6px;\\n\\tcontent: \\\"\\\";\\n\\theight: 100%;\\n\\tposition: absolute;\\n\\twidth: 100%;\\n\\tz-index: -1\\n}\\n\\n.win7 .window-body {\\n\\tbackground: #f0f0f0;\\n\\tborder: 1px solid rgba(0, 0, 0, .7);\\n\\tbox-shadow: 0 0 1px .5px #fff;\\n\\tmargin: 0 6px 6px\\n}\\n\\n.win7 .window-body.has-space {\\n\\tpadding: 6px\\n}\\n\\n.win7 .window-body pre {\\n\\tmargin: -6px\\n}\\n\\n.win7 .window footer,\\n.win7 .window-footer {\\n\\tbackground: #f0f0f0;\\n\\tborder: 1px solid rgba(0, 0, 0, .7);\\n\\tborder-top: 0;\\n\\tbox-shadow: 0 .5px 1px .5px #fff;\\n\\tmargin: -7px 6px 6px;\\n\\tpadding: 10px;\\n\\tposition: relative\\n}\\n\\n.win7 .window footer:before,\\n.win7 .window-footer:before {\\n\\tbox-shadow: inset 0 1px rgba(0, 0, 0, .3), inset 0 -1px #fff;\\n\\tcontent: \\\"\\\";\\n\\theight: 2px;\\n\\tleft: 0;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\twidth: 100%\\n}\\n\\n.win7 .window.is-bright .window-body {\\n\\tbackground: #fff\\n}\\n\\n.win7 .window.is-bright .window-footer,\\n.win7 .window.is-bright footer {\\n\\tbackground: #eee;\\n\\tbox-shadow: inset 0 1px 3px #ddd\\n}\\n\\n.win7 .window.is-bright .window-footer:before,\\n.win7 .window.is-bright footer:before {\\n\\tcontent: none\\n}\\n\\n.win7 .window.glass {\\n\\t-webkit-backdrop-filter: blur(1.5px);\\n\\tbackdrop-filter: blur(1.5px)\\n}\\n\\n.win7 .window.glass:before {\\n\\tfilter: brightness(1.4);\\n\\topacity: .5\\n}\\n\\n.win7 .window.glass>.title-bar {\\n\\tbackground: linear-gradient(55deg, transparent 8%, hsla(0, 0%, 100%, .1) 10%, hsla(0, 0%, 100%, .3) 30%, rgba(0, 0, 0, .1) 32%, rgba(0, 0, 0, .3) 55%, transparent 57%, hsla(0, 0%, 100%, .3) 70%, transparent 72%)\\n}\\n\\n.win7 .window>.title-bar {\\n\\tborder: 0;\\n\\tbox-shadow: inset 0 .5px #fff\\n}\\n\\n.win7 .window fieldset {\\n\\tmargin-bottom: 9px\\n}\\n\\n.win7 .window[role=dialog] {\\n\\tleft: 50%;\\n\\topacity: 0;\\n\\tposition: fixed;\\n\\ttop: 50%;\\n\\ttransform: translate(-50%, -50%);\\n\\ttransition-duration: .2s;\\n\\ttransition-property: visibility, opacity;\\n\\tvisibility: hidden;\\n\\tz-index: 999\\n}\\n\\n.win7 .window[role=dialog]:target {\\n\\topacity: 1;\\n\\tvisibility: visible\\n}\\n\\n.win7 .title-bar {\\n\\talign-items: center;\\n\\tbackground: linear-gradient(90deg, hsla(0, 0%, 100%, .4), rgba(0, 0, 0, .1), hsla(0, 0%, 100%, .2)), linear-gradient(55deg, transparent, rgba(0, 0, 0, .1) 20%, rgba(0, 0, 0, .1) 50%, transparent 53%), #4580c4;\\n\\tborder: 1px solid rgba(0, 0, 0, .7);\\n\\tborder-radius: 6px 6px 0 0;\\n\\tbox-shadow: inset 0 0 .5px .5px #fff;\\n\\tdisplay: flex;\\n\\tfont: 9pt Segoe UI, sans-serif;\\n\\tjustify-content: space-between;\\n\\tpadding: 6px\\n}\\n\\n.win7 .title-bar-text {\\n\\tcolor: #000;\\n\\tletter-spacing: 0;\\n\\tline-height: 15px;\\n\\ttext-shadow: 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff, 0 0 10px #fff\\n}\\n\\n.win7 .title-bar-controls {\\n\\tbackground: hsla(0, 0%, 100%, .2);\\n\\tborder: 1px solid rgba(0, 0, 0, .3);\\n\\tborder-radius: 0 0 5px 5px;\\n\\tborder-top: 0;\\n\\tbox-shadow: 0 0 2px #fff;\\n\\tdisplay: flex;\\n\\tmargin-top: -6px\\n}\\n\\n.win7 .title-bar-controls button {\\n\\tbackground: none;\\n\\tborder: 0;\\n\\tborder-radius: 0;\\n\\tborder-right: 1px solid rgba(0, 0, 0, .3);\\n\\tbox-shadow: inset 0 0 0 1px #eee8;\\n\\tbox-sizing: border-box;\\n\\tmin-height: 19px;\\n\\tmin-width: 29px;\\n\\tpadding: 0;\\n\\tposition: relative\\n}\\n\\n.win7 .title-bar-controls button:active,\\n.win7 .title-bar-controls button:hover {\\n\\tbackground: none;\\n\\tborder-color: rgba(0, 0, 0, .3);\\n\\tbox-shadow: inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar-controls button:disabled:before {\\n\\topacity: .4\\n}\\n\\n.win7 .title-bar-controls button:before {\\n\\tbottom: 0;\\n\\tcontent: \\\"\\\";\\n\\tleft: 0;\\n\\tposition: absolute;\\n\\tright: 0;\\n\\ttop: 0\\n}\\n\\n.win7 .title-bar-controls button.is-minimize:before,\\n.win7 .title-bar-controls button[aria-label=Minimize]:before {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAFCAYAAABxeg0vAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAA7SURBVHgBlY+xDQAgDMNaiQ9B8AHcxAlI/NYtKwj6QOohUzxYc+1HAqQ3e03qXNpwwcyE5QsAaEGjDRf8ZAza6Bz6VQAAAABJRU5ErkJggg==\\\") no-repeat center 10px\\n}\\n\\n.win7 .title-bar-controls button.is-maximize:before,\\n.win7 .title-bar-controls button[aria-label=Maximize]:before {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAYAAACALL/6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABsSURBVHgBlZHBCYAwDEVT6YaKbqArOILgBLqBosP1VkhAaQ6S1lKad+ihPy8kxLT9+IACG57r2KqKu2GCBpTYtEMOOQELzrnv4z53I4vDjjJnwXsPJWTOAiJGHVNB5pGwLjPk+AlEBLUY7eFebCosBHOR7vYAAAAASUVORK5CYII=\\\") no-repeat 50%\\n}\\n\\n.win7 .title-bar-controls button.is-restore:before,\\n.win7 .title-bar-controls button[aria-label=Restore]:before {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACVSURBVHgBlVDLCoMwENwU/7ClvRYK7b2lCIJHEQQ/QEHwqujfBXJIQMnihg34iHPJ7GNm2AhYcL2/JwhAxIuhq3aXb48PiFBna2YFERVHzoQLnAQmSCmxeL5+3rBtSsdpBwVKKTcY+1rY197G+8RRoLVejed94igwxrgB/zXeJ+4Jijz2Erjg+8/WE7ZAt6EgSUsIxQwaJEWv7G6SSgAAAABJRU5ErkJggg==\\\") no-repeat 50%\\n}\\n\\n.win7 .title-bar-controls button.is-close,\\n.win7 .title-bar-controls button[aria-label=Close] {\\n\\tmin-width: 48px\\n}\\n\\n.win7 .title-bar-controls button.is-close:before,\\n.win7 .title-bar-controls button[aria-label=Close]:before {\\n\\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAKCAYAAABi8KSDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACUSURBVHgBlZFNCoQwDIVbmRvOMHOAAd0K/uDGlYKiCG4VPICi9yu0oCSQoFUXFtKEl6+voZXvr7sKay1TL690FOexY+Hz87i2decOuDKQsNGVe8AGYTRJIh0Y+orBvxszCPllOymlxN06jNE26Qnwg4zdHQLrMhFaawwAqAadDPE1ijwUxhiMKCmxCZk06OMYTz5lAx3xWDeXkLNAAAAAAElFTkSuQmCC\\\") no-repeat 50%\\n}\\n\\n.win7 .title-bar-controls button:first-child {\\n\\tborder-bottom-left-radius: 5px\\n}\\n\\n.win7 .title-bar-controls button:last-child {\\n\\tborder: 0;\\n\\tborder-bottom-right-radius: 5px\\n}\\n\\n.win7 .title-bar-controls button:focus {\\n\\toutline: none\\n}\\n\\n.win7 .title-bar.active .title-bar-controls,\\n.win7 .window.active .title-bar .title-bar-controls {\\n\\tborder-color: rgba(0, 0, 0, .7)\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button,\\n.win7 .window.active .title-bar .title-bar-controls button {\\n\\tbackground: linear-gradient(hsla(0, 0%, 100%, .5), hsla(0, 0%, 100%, .3) 45%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .1) 75%, hsla(0, 0%, 100%, .5));\\n\\tborder-color: rgba(0, 0, 0, .7);\\n\\tbox-shadow: inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button:hover,\\n.win7 .window.active .title-bar .title-bar-controls button:hover {\\n\\tbackground: radial-gradient(circle at bottom, #2aceda, transparent 60%), linear-gradient(#a9d2e8 50%, #196c9b 0);\\n\\tbox-shadow: 0 0 15px #2aceda, inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button:active,\\n.win7 .window.active .title-bar .title-bar-controls button:active {\\n\\tbackground: radial-gradient(circle at bottom, #0bfdfa, transparent 60%), linear-gradient(#86a7bc 50%, #092747 0);\\n\\tbox-shadow: 0 0 15px #2aceda, inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button.is-close,\\n.win7 .title-bar.active .title-bar-controls button[aria-label=Close],\\n.win7 .window.active .title-bar .title-bar-controls button.is-close,\\n.win7 .window.active .title-bar .title-bar-controls button[aria-label=Close] {\\n\\tbackground-color: #d04834;\\n\\tbox-shadow: inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button.is-close:hover,\\n.win7 .title-bar.active .title-bar-controls button[aria-label=Close]:hover,\\n.win7 .window.active .title-bar .title-bar-controls button.is-close:hover,\\n.win7 .window.active .title-bar .title-bar-controls button[aria-label=Close]:hover {\\n\\tbackground: linear-gradient(hsla(0, 0%, 100%, .5), hsla(0, 0%, 100%, .3) 45%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .1) 75%, hsla(0, 0%, 100%, .5)), radial-gradient(circle at 50% 170%, orange 10% 20%, #0000 60%), linear-gradient(#ee6d56 50%, #d42809 0);\\n\\tbox-shadow: 0 0 15px #e68e75, inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button.is-close:active,\\n.win7 .title-bar.active .title-bar-controls button[aria-label=Close]:active,\\n.win7 .window.active .title-bar .title-bar-controls button.is-close:active,\\n.win7 .window.active .title-bar .title-bar-controls button[aria-label=Close]:active {\\n\\tbackground: linear-gradient(hsla(0, 0%, 100%, .5), hsla(0, 0%, 100%, .3) 45%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .1) 75%, hsla(0, 0%, 100%, .5)), radial-gradient(circle at 50% 170%, #ff0 10% 20%, #0000 60%), linear-gradient(#b67562 50%, #780c01 0)\\n}\\n\\n.win7 .title-bar.active .title-bar-controls button:disabled:active,\\n.win7 .title-bar.active .title-bar-controls button:disabled:hover,\\n.win7 .window.active .title-bar .title-bar-controls button:disabled:active,\\n.win7 .window.active .title-bar .title-bar-controls button:disabled:hover {\\n\\tbackground: linear-gradient(hsla(0, 0%, 100%, .5), hsla(0, 0%, 100%, .3) 45%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .1) 75%, hsla(0, 0%, 100%, .5));\\n\\tbox-shadow: inset 0 0 0 1px #eee8\\n}\\n\\n.win7 .status-bar {\\n\\tbackground: #f0f0f0;\\n\\tborder: 1px solid rgba(0, 0, 0, .7);\\n\\tborder-top: 0;\\n\\tbox-shadow: 0 .5px 1px .5px #fff;\\n\\tdisplay: flex;\\n\\tmargin: -6px 6px 6px\\n}\\n\\n.win7 .status-bar-field {\\n\\tborder-right: 1px solid #cfcfcf;\\n\\tflex-grow: 1;\\n\\tmargin: 0;\\n\\tpadding: 2px 3px\\n}\\n\\n.win7 .status-bar-field:last-child {\\n\\tborder-right: 0\\n}\\n    \";\n        return $plantilla;\n    })((estilos_finales))));\n}\n\n//Included:lib/999.finalizacion.part.js\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////// Aquí termina el script de Castelog //\n////////////////////////////////////////////////////////////////////////////////"